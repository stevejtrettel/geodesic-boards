{
  "version": 3,
  "sources": ["../../src/defaults.ts", "../../src/maps/keywordMap.ts", "../../src/maps/availabilityMap.ts", "../../src/maps/patchMap.ts", "../../src/maps/requiredPropsMap.ts", "../../src/sdbm.js", "../../src/utils.ts", "../../src/index.ts"],
  "sourcesContent": ["export const defaultCsmDefinitions = /* glsl */ `\r\n    \r\n#ifdef IS_VERTEX\r\n    vec3 csm_Position;\r\n    vec4 csm_PositionRaw;\r\n    vec3 csm_Normal;\r\n\r\n    // csm_PointSize\r\n    #ifdef IS_POINTSMATERIAL\r\n        float csm_PointSize;\r\n    #endif\r\n#else\r\n    vec4 csm_DiffuseColor;\r\n    vec4 csm_FragColor;\r\n    float csm_UnlitFac;\r\n\r\n    // csm_Emissive, csm_Roughness, csm_Metalness\r\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL\r\n        vec3 csm_Emissive;\r\n        float csm_Roughness;\r\n        float csm_Metalness;\r\n        float csm_Iridescence;\r\n        \r\n        #if defined IS_MESHPHYSICALMATERIAL\r\n            float csm_Clearcoat;\r\n            float csm_ClearcoatRoughness;\r\n            vec3 csm_ClearcoatNormal;\r\n            float csm_Transmission;\r\n            float csm_Thickness;\r\n        #endif\r\n    #endif\r\n\r\n    // csm_AO\r\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL\r\n        float csm_AO;\r\n    #endif\r\n\r\n    // csm_Bump\r\n    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL \r\n        vec3 csm_Bump;\r\n        vec3 csm_FragNormal;\r\n    #endif\r\n\r\n    float csm_DepthAlpha;\r\n#endif\r\n`;\r\n\r\nexport const defaultCsmMainDefinitions = /* glsl */ `\r\n\r\n#ifdef IS_VERTEX\r\n    // csm_Position & csm_PositionRaw\r\n    #ifdef IS_UNKNOWN\r\n        csm_Position = vec3(0.0);\r\n        csm_PositionRaw = vec4(0.0);\r\n        csm_Normal = vec3(0.0);\r\n    #else\r\n        csm_Position = position;\r\n        csm_PositionRaw = projectionMatrix * modelViewMatrix * vec4(position, 1.);\r\n        csm_Normal = normal;\r\n    #endif\r\n\r\n    // csm_PointSize\r\n    #ifdef IS_POINTSMATERIAL\r\n        csm_PointSize = size;\r\n    #endif\r\n#else\r\n    csm_UnlitFac = 0.0;\r\n\r\n    // csm_DiffuseColor & csm_FragColor\r\n    #if defined IS_UNKNOWN || defined IS_SHADERMATERIAL || defined IS_MESHDEPTHMATERIAL || defined IS_MESHDISTANCEMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_SHADOWMATERIAL\r\n        csm_DiffuseColor = vec4(1.0, 0.0, 1.0, 1.0);\r\n        csm_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\r\n    #else\r\n        #ifdef USE_MAP\r\n            vec4 _csm_sampledDiffuseColor = texture2D(map, vMapUv);\r\n\r\n            #ifdef DECODE_VIDEO_TEXTURE\r\n            // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)\r\n            _csm_sampledDiffuseColor = vec4(mix(pow(_csm_sampledDiffuseColor.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), _csm_sampledDiffuseColor.rgb * 0.0773993808, vec3(lessThanEqual(_csm_sampledDiffuseColor.rgb, vec3(0.04045)))), _csm_sampledDiffuseColor.w);\r\n            #endif\r\n\r\n            csm_DiffuseColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;\r\n            csm_FragColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;\r\n        #else\r\n            csm_DiffuseColor = vec4(diffuse, opacity);\r\n            csm_FragColor = vec4(diffuse, opacity);\r\n        #endif\r\n    #endif\r\n\r\n    // csm_Emissive, csm_Roughness, csm_Metalness\r\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL\r\n        csm_Emissive = emissive;\r\n        csm_Roughness = roughness;\r\n        csm_Metalness = metalness;\r\n\r\n        #ifdef USE_IRIDESCENCE\r\n            csm_Iridescence = iridescence;\r\n        #else\r\n            csm_Iridescence = 0.0;\r\n        #endif\r\n\r\n        #if defined IS_MESHPHYSICALMATERIAL\r\n            #ifdef USE_CLEARCOAT\r\n                csm_Clearcoat = clearcoat;\r\n                csm_ClearcoatRoughness = clearcoatRoughness;\r\n            #else\r\n                csm_Clearcoat = 0.0;\r\n                csm_ClearcoatRoughness = 0.0;\r\n            #endif\r\n\r\n            #ifdef USE_TRANSMISSION\r\n                csm_Transmission = transmission;\r\n                csm_Thickness = thickness;\r\n            #else\r\n                csm_Transmission = 0.0;\r\n                csm_Thickness = 0.0;\r\n            #endif\r\n        #endif\r\n    #endif\r\n\r\n    // csm_AO\r\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL\r\n        csm_AO = 0.0;\r\n    #endif\r\n\r\n    // csm_Bump\r\n    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL \r\n        csm_Bump = vec3(0.0);\r\n        #ifdef FLAT_SHADED\r\n            vec3 fdx = dFdx( vViewPosition );\r\n            vec3 fdy = dFdy( vViewPosition );\r\n            csm_FragNormal = normalize( cross( fdx, fdy ) );\r\n        #else\r\n            csm_FragNormal = normalize(vNormal);\r\n            #ifdef DOUBLE_SIDED\r\n                csm_FragNormal *= gl_FrontFacing ? 1.0 : - 1.0;\r\n            #endif\r\n        #endif\r\n    #endif\r\n\r\n    csm_DepthAlpha = 1.0;\r\n#endif\r\n`;\r\n\r\nexport const defaultVertDefinitions = /* glsl */ `\r\n    varying mat4 csm_internal_vModelViewMatrix;\r\n`;\r\n\r\nexport const defaultVertMain = /* glsl */ `\r\n    csm_internal_vModelViewMatrix = modelViewMatrix;\r\n`;\r\n\r\nexport const defaultFragDefinitions = /* glsl */ `\r\n    varying mat4 csm_internal_vModelViewMatrix;\r\n`;\r\n\r\nexport const defaultFragMain = /* glsl */ `\r\n    \r\n`;\r\n", "export const keywordMap = {\r\n  // PBR (frag)\r\n  diffuse: \"csm_DiffuseColor\", // Color + alpha\r\n  roughness: \"csm_Roughness\", // Roughness\r\n  metalness: \"csm_Metalness\", // Metalness\r\n  emissive: \"csm_Emissive\", // Emissive\r\n  ao: \"csm_AO\", // AO\r\n  bump: \"csm_Bump\", // Bump\r\n  fragNormal: \"csm_FragNormal\", // Fragment Normal\r\n  clearcoat: \"csm_Clearcoat\", // Clearcoat factor\r\n  clearcoatRoughness: \"csm_ClearcoatRoughness\", // Clearcoat roughness\r\n  clearcoatNormal: \"csm_ClearcoatNormal\", // Clearcoat normals\r\n  transmission: \"csm_Transmission\", // Transmission\r\n  thickness: \"csm_Thickness\", // Thickness\r\n  iridescence: \"csm_Iridescence\", // Iridescence\r\n\r\n  // Extras\r\n  pointSize: \"csm_PointSize\", // gl_PointSize (Frag)\r\n  fragColor: \"csm_FragColor\", // gl_FragColor (Frag)\r\n  depthAlpha: \"csm_DepthAlpha\", // Depth (MeshDepthMaterial)\r\n  unlitFac: \"csm_UnlitFac\", // Unlit factor (mix between csm_FragColor and csm_DiffuseColor)\r\n\r\n  // Vert\r\n  position: \"csm_Position\", // gl_Position\r\n  positionRaw: \"csm_PositionRaw\", // gl_Position (without projection)\r\n  normal: \"csm_Normal\", // Vertex Normal\r\n};\r\n", "import { keywordMap } from \"./keywordMap\";\r\n\r\n// Map of CSM keywords to the materials they are available in\r\n// Some keywords are only available in certain materials\r\nexport const availabilityMap = {\r\n  [`${keywordMap.position}`]: \"*\",\r\n  [`${keywordMap.positionRaw}`]: \"*\",\r\n  [`${keywordMap.normal}`]: \"*\",\r\n  [`${keywordMap.depthAlpha}`]: \"*\",\r\n  [`${keywordMap.pointSize}`]: [\"PointsMaterial\"],\r\n\r\n  [`${keywordMap.diffuse}`]: \"*\",\r\n  [`${keywordMap.fragColor}`]: \"*\",\r\n  [`${keywordMap.fragNormal}`]: \"*\",\r\n  [`${keywordMap.unlitFac}`]: \"*\",\r\n  [`${keywordMap.emissive}`]: [\"MeshStandardMaterial\", \"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.roughness}`]: [\"MeshStandardMaterial\", \"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.metalness}`]: [\"MeshStandardMaterial\", \"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.iridescence}`]: [\r\n    \"MeshStandardMaterial\",\r\n    \"MeshPhysicalMaterial\",\r\n  ],\r\n  [`${keywordMap.ao}`]: [\r\n    \"MeshStandardMaterial\",\r\n    \"MeshPhysicalMaterial\",\r\n    \"MeshBasicMaterial\",\r\n    \"MeshLambertMaterial\",\r\n    \"MeshPhongMaterial\",\r\n    \"MeshToonMaterial\",\r\n  ],\r\n  [`${keywordMap.bump}`]: [\r\n    \"MeshLambertMaterial\",\r\n    \"MeshMatcapMaterial\",\r\n    \"MeshNormalMaterial\",\r\n    \"MeshPhongMaterial\",\r\n    \"MeshPhysicalMaterial\",\r\n    \"MeshStandardMaterial\",\r\n    \"MeshToonMaterial\",\r\n    \"ShadowMaterial\",\r\n  ],\r\n  [`${keywordMap.clearcoat}`]: [\"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.clearcoatRoughness}`]: [\"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.clearcoatNormal}`]: [\"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.transmission}`]: [\"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.thickness}`]: [\"MeshPhysicalMaterial\"],\r\n};\r\n", "import * as THREE from \"three\";\r\nimport { CSMPatchMap } from \"../types\";\r\nimport { keywordMap } from \"./keywordMap\";\r\n\r\n// Map of CSM keywords to their substitutions\r\nexport const defaultPatchMap: CSMPatchMap = {\r\n  // VERT\r\n  \"*\": {\r\n    \"#include <lights_physical_fragment>\":\r\n      THREE.ShaderChunk.lights_physical_fragment,\r\n    \"#include <transmission_fragment>\": THREE.ShaderChunk.transmission_fragment,\r\n  },\r\n  [`${keywordMap.normal}`]: {\r\n    \"#include <beginnormal_vertex>\": `\r\n    vec3 objectNormal = ${keywordMap.normal};\r\n    #ifdef USE_TANGENT\r\n\t    vec3 objectTangent = vec3( tangent.xyz );\r\n    #endif\r\n    `,\r\n  },\r\n  [`${keywordMap.position}`]: {\r\n    \"#include <begin_vertex>\": `\r\n    vec3 transformed = ${keywordMap.position};\r\n  `,\r\n  },\r\n  [`${keywordMap.positionRaw}`]: {\r\n    \"#include <begin_vertex>\": `\r\n    vec4 csm_internal_positionUnprojected = ${keywordMap.positionRaw};\r\n    mat4x4 csm_internal_unprojectMatrix = projectionMatrix * modelViewMatrix;\r\n    #ifdef USE_INSTANCING\r\n      csm_internal_unprojectMatrix = csm_internal_unprojectMatrix * instanceMatrix;\r\n    #endif\r\n    csm_internal_positionUnprojected = inverse(csm_internal_unprojectMatrix) * csm_internal_positionUnprojected;\r\n    vec3 transformed = csm_internal_positionUnprojected.xyz;\r\n  `,\r\n  },\r\n  [`${keywordMap.pointSize}`]: {\r\n    \"gl_PointSize = size;\": `\r\n    gl_PointSize = ${keywordMap.pointSize};\r\n    `,\r\n  },\r\n\r\n  // FRAG\r\n\r\n  [`${keywordMap.diffuse}`]: {\r\n    \"#include <color_fragment>\": `\r\n    #include <color_fragment>\r\n    diffuseColor = ${keywordMap.diffuse};\r\n  `,\r\n  },\r\n  [`${keywordMap.fragColor}`]: {\r\n    \"#include <opaque_fragment>\": `\r\n    #include <opaque_fragment>\r\n    gl_FragColor = mix(gl_FragColor, ${keywordMap.fragColor}, ${keywordMap.unlitFac});\r\n  `,\r\n  },\r\n  [`${keywordMap.emissive}`]: {\r\n    \"vec3 totalEmissiveRadiance = emissive;\": `\r\n    vec3 totalEmissiveRadiance = ${keywordMap.emissive};\r\n    `,\r\n  },\r\n  [`${keywordMap.roughness}`]: {\r\n    \"#include <roughnessmap_fragment>\": `\r\n    #include <roughnessmap_fragment>\r\n    roughnessFactor = ${keywordMap.roughness};\r\n    `,\r\n  },\r\n  [`${keywordMap.metalness}`]: {\r\n    \"#include <metalnessmap_fragment>\": `\r\n    #include <metalnessmap_fragment>\r\n    metalnessFactor = ${keywordMap.metalness};\r\n    `,\r\n  },\r\n  [`${keywordMap.ao}`]: {\r\n    \"#include <aomap_fragment>\": `\r\n    #include <aomap_fragment>\r\n    reflectedLight.indirectDiffuse *= 1. - ${keywordMap.ao};\r\n    `,\r\n  },\r\n  [`${keywordMap.bump}`]: {\r\n    \"#include <normal_fragment_maps>\": `\r\n    #include <normal_fragment_maps>\r\n\r\n    vec3 csm_internal_orthogonal = ${keywordMap.bump} - (dot(${keywordMap.bump}, normal) * normal);\r\n    vec3 csm_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_internal_orthogonal;\r\n    normal = normalize(normal - csm_internal_projectedbump);\r\n    `,\r\n  },\r\n  [`${keywordMap.fragNormal}`]: {\r\n    \"#include <normal_fragment_maps>\": `\r\n      #include <normal_fragment_maps>\r\n      normal = ${keywordMap.fragNormal};\r\n    `,\r\n  },\r\n  [`${keywordMap.depthAlpha}`]: {\r\n    \"gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\": `\r\n      gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity * 1.0 - ${keywordMap.depthAlpha} );\r\n    `,\r\n    \"gl_FragColor = packDepthToRGBA( fragCoordZ );\": `\r\n      if(${keywordMap.depthAlpha} < 1.0) discard;\r\n      gl_FragColor = packDepthToRGBA( dist );\r\n    `,\r\n    \"gl_FragColor = packDepthToRGBA( dist );\": `\r\n      if(${keywordMap.depthAlpha} < 1.0) discard;\r\n      gl_FragColor = packDepthToRGBA( dist );\r\n    `,\r\n  },\r\n  [`${keywordMap.clearcoat}`]: {\r\n    \"material.clearcoat = clearcoat;\": `material.clearcoat = ${keywordMap.clearcoat};`,\r\n  },\r\n  [`${keywordMap.clearcoatRoughness}`]: {\r\n    \"material.clearcoatRoughness = clearcoatRoughness;\": `material.clearcoatRoughness = ${keywordMap.clearcoatRoughness};`,\r\n  },\r\n  [`${keywordMap.clearcoatNormal}`]: {\r\n    \"#include <clearcoat_normal_fragment_begin>\": `\r\n      vec3 csm_coat_internal_orthogonal = csm_ClearcoatNormal - (dot(csm_ClearcoatNormal, nonPerturbedNormal) * nonPerturbedNormal);\r\n      vec3 csm_coat_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_coat_internal_orthogonal;\r\n      vec3 clearcoatNormal = normalize(nonPerturbedNormal - csm_coat_internal_projectedbump);\r\n    `,\r\n  },\r\n  [`${keywordMap.transmission}`]: {\r\n    \"material.transmission = transmission;\": `\r\n      material.transmission = ${keywordMap.transmission};\r\n    `,\r\n  },\r\n  [`${keywordMap.thickness}`]: {\r\n    \"material.thickness = thickness;\": `\r\n      material.thickness = ${keywordMap.thickness};\r\n    `,\r\n  },\r\n  [`${keywordMap.iridescence}`]: {\r\n    \"material.iridescence = iridescence;\": `\r\n      material.iridescence = ${keywordMap.iridescence};\r\n    `,\r\n  },\r\n};\r\n", "import { keywordMap } from \"./keywordMap\";\r\n\r\n/**\r\n * Map of props to their keywords\r\n * this is because Three only injects some defines if certain properties are set in the material options.\r\n *\r\n * For example, \"clearcoat\" must be set for 3js to include the #USE_CLEARCOAT define in the shader.\r\n * and thus for our custom clearcoar variant to work\r\n */\r\nexport const requiredPropsMap = {\r\n  clearcoat: [\r\n    keywordMap.clearcoat,\r\n    keywordMap.clearcoatNormal,\r\n    keywordMap.clearcoatRoughness,\r\n  ],\r\n  transmission: [keywordMap.transmission],\r\n  iridescence: [keywordMap.iridescence],\r\n};\r\n", "//https://github.com/sindresorhus/sdbm\r\n\r\nexport default function sdbm(string) {\r\n  let hash = 0;\r\n\r\n  for (let i = 0; i < string.length; i++) {\r\n    hash = string.charCodeAt(i) + (hash << 6) + (hash << 16) - hash;\r\n  }\r\n\r\n  // Convert it to an unsigned 32-bit integer.\r\n  const h = hash >>> 0;\r\n  const str = String(h);\r\n  return str;\r\n}\r\n", "import { MaterialConstructor } from \"./types\";\r\n\r\n// Hacky, yikes!\r\nexport function isConstructor<T extends MaterialConstructor>(\r\n  f: T | InstanceType<T>\r\n): f is T {\r\n  try {\r\n    // @ts-ignore\r\n    new f();\r\n  } catch (err) {\r\n    if ((err as any).message.indexOf(\"is not a constructor\") >= 0) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n// Remove all comments in a string\r\n// both block and inline comments\r\nexport function stripComments(str: string) {\r\n  return str.replace(/\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*/g, \"\");\r\n}\r\n", "import * as THREE from \"three\";\r\nimport {\r\n  defaultCsmDefinitions,\r\n  defaultCsmMainDefinitions,\r\n  defaultFragDefinitions,\r\n  defaultFragMain,\r\n  defaultVertDefinitions,\r\n  defaultVertMain,\r\n} from \"./defaults\";\r\nimport { availabilityMap, defaultPatchMap, keywordMap } from \"./maps\";\r\nimport { requiredPropsMap } from \"./maps/requiredPropsMap\";\r\nimport hash from \"./sdbm\";\r\nimport * as TYPES from \"./types\";\r\nimport { isConstructor, stripComments } from \"./utils\";\r\n\r\nexport default class CustomShaderMaterial<\r\n  T extends TYPES.MaterialConstructor = typeof THREE.Material\r\n> extends THREE.Material {\r\n  uniforms: TYPES.Uniform = {};\r\n  vertexShader: string = \"\";\r\n  fragmentShader: string = \"\";\r\n\r\n  constructor({\r\n    baseMaterial,\r\n    vertexShader,\r\n    fragmentShader,\r\n    uniforms,\r\n    patchMap,\r\n    cacheKey,\r\n    ...opts\r\n  }: TYPES.CustomShaderMaterialParameters<T>) {\r\n    if (!baseMaterial) {\r\n      throw new Error(\"CustomShaderMaterial: baseMaterial is required.\");\r\n    }\r\n\r\n    let base: THREE.Material;\r\n    if (isConstructor(baseMaterial)) {\r\n      // If base material is a constructor, instantiate it\r\n      // if opts is empty, replace it with undefined\r\n      const isEmptyOpts = Object.keys(opts).length === 0;\r\n      base = new baseMaterial(isEmptyOpts ? undefined : opts);\r\n    } else {\r\n      // Else, use the already created instance as the base material\r\n      // and copy options onto it\r\n      base = baseMaterial;\r\n      Object.assign(base, opts);\r\n    }\r\n\r\n    // Blacklist some materials that are not supported\r\n    const blackList = [\"ShaderMaterial\", \"RawShaderMaterial\"];\r\n    if (blackList.includes(base.type)) {\r\n      throw new Error(\r\n        `CustomShaderMaterial does not support ${base.type} as a base material.`\r\n      );\r\n    }\r\n\r\n    super();\r\n\r\n    // Return a proxy to the base material with CSM types and methods\r\n    const extendedBase = base as typeof base & TYPES.CSMProxy<T>;\r\n    extendedBase.name = `CustomShaderMaterial<${base.name || base.type}>`;\r\n    extendedBase.update = this.update.bind(extendedBase);\r\n    extendedBase.__csm = {\r\n      prevOnBeforeCompile: base.onBeforeCompile,\r\n      baseMaterial: base,\r\n      vertexShader,\r\n      fragmentShader,\r\n      uniforms,\r\n      patchMap,\r\n      cacheKey,\r\n    };\r\n\r\n    const prevUniforms = extendedBase.uniforms || {};\r\n    const newUniforms = uniforms || {};\r\n    const mergedUniforms = { ...prevUniforms, ...newUniforms };\r\n\r\n    extendedBase.uniforms = this.uniforms = mergedUniforms;\r\n    extendedBase.vertexShader = this.vertexShader = vertexShader || \"\";\r\n    extendedBase.fragmentShader = this.fragmentShader = fragmentShader || \"\";\r\n\r\n    // Initialize custom shaders\r\n    extendedBase.update({\r\n      fragmentShader: extendedBase.fragmentShader,\r\n      vertexShader: extendedBase.vertexShader,\r\n      uniforms: extendedBase.uniforms,\r\n      patchMap,\r\n      cacheKey,\r\n    });\r\n\r\n    // Merge \"this\" with the extended base\r\n    Object.assign(this, extendedBase);\r\n\r\n    // Copy getters and setters from the base material\r\n    const gettersAndSetters = Object.getOwnPropertyDescriptors(\r\n      Object.getPrototypeOf(extendedBase)\r\n    );\r\n\r\n    for (const key in gettersAndSetters) {\r\n      const descriptor = gettersAndSetters[key];\r\n      if (descriptor.get || descriptor.set) {\r\n        Object.defineProperty(this, key, descriptor);\r\n      }\r\n    }\r\n\r\n    // Override type setter because of this BS: https://github.com/mrdoob/three.js/blob/841ca14e89f3ec925e071a321958e49a883343c0/src/materials/Material.js#L22\r\n    Object.defineProperty(this, \"type\", {\r\n      get() {\r\n        return base.type;\r\n      },\r\n      set(value) {\r\n        base.type = value;\r\n      },\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  update({\r\n    fragmentShader: _fs,\r\n    vertexShader: _vs,\r\n    uniforms,\r\n    cacheKey,\r\n    patchMap,\r\n  }: Omit<TYPES.CustomShaderMaterialBaseParameters<T>, \"baseMaterial\">) {\r\n    // Strip comments from shaders, makes it so that commented keywords are not detected\r\n    const vertexShader = stripComments(_vs || \"\");\r\n    const fragmentShader = stripComments(_fs || \"\");\r\n\r\n    // Get typed `this` for the proxy\r\n    const self = this as typeof this & TYPES.CSMProxy<T>;\r\n\r\n    // Replace the shaders if they are provided\r\n    if (uniforms) self.uniforms = uniforms;\r\n    if (_vs) self.vertexShader = _vs;\r\n    if (_fs) self.fragmentShader = _fs;\r\n\r\n    // Some keywords require certain properties to be set for their chunks to be included via #ifdef\r\n    // so we must check if the shaders contain these keywords and set the properties accordingly\r\n    Object.entries(requiredPropsMap).forEach(([prop, matchKeywords]) => {\r\n      for (const keyword in matchKeywords) {\r\n        const matchKeyword = matchKeywords[keyword];\r\n        if (\r\n          (fragmentShader && fragmentShader.includes(matchKeyword)) ||\r\n          (vertexShader && vertexShader.includes(matchKeyword))\r\n        ) {\r\n          // @ts-ignore\r\n          if (!self[prop]) {\r\n            // @ts-ignore\r\n            self[prop] = 1;\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    // Check it the previous onBeforeCompile exists\r\n    const prevOnBeforeCompile = self.__csm.prevOnBeforeCompile;\r\n\r\n    // Helper function to extend the shader\r\n    const extendShader = (\r\n      prevShader: string,\r\n      newShader?: string,\r\n      isFrag?: boolean\r\n    ) => {\r\n      let mainBody: string | undefined;\r\n      let beforeMain: string = \"\";\r\n\r\n      // Prepare the main body and beforeMain\r\n      if (newShader) {\r\n        // Simpler approach to extract main function body\r\n        const mainStartIndex = newShader.search(/void\\s+main\\s*\\(\\s*\\)\\s*{/);\r\n        if (mainStartIndex !== -1) {\r\n          // Get everything before main function\r\n          beforeMain = newShader.slice(0, mainStartIndex);\r\n\r\n          // Find the matching closing brace using brace counting\r\n          let braceCount = 0;\r\n          let mainEndIndex = -1;\r\n\r\n          for (let i = mainStartIndex; i < newShader.length; i++) {\r\n            if (newShader[i] === \"{\") braceCount++;\r\n            if (newShader[i] === \"}\") {\r\n              braceCount--;\r\n              if (braceCount === 0) {\r\n                mainEndIndex = i;\r\n                break;\r\n              }\r\n            }\r\n          }\r\n\r\n          if (mainEndIndex !== -1) {\r\n            // Extract main body without the outer braces\r\n            const fullMain = newShader.slice(mainStartIndex, mainEndIndex + 1);\r\n            mainBody = fullMain.slice(fullMain.indexOf(\"{\") + 1, -1);\r\n          }\r\n        } else {\r\n          beforeMain = newShader;\r\n        }\r\n      }\r\n\r\n      // Set csm_UnlitFac if csm_FragColor is used to preserve\r\n      // legacy behavior.\r\n      if (isFrag) {\r\n        const hasFragColor = newShader\r\n          ? newShader.includes(keywordMap.fragColor)\r\n          : false;\r\n        if (hasFragColor && mainBody) {\r\n          mainBody = \"csm_UnlitFac = 1.0;\\n\" + mainBody;\r\n        }\r\n      }\r\n\r\n      const defaultsAlreadyIncluded = prevShader.includes(\"//~CSM_DEFAULTS\");\r\n\r\n      // Inject\r\n      if (defaultsAlreadyIncluded) {\r\n        prevShader = prevShader.replace(\r\n          \"void main() {\",\r\n          `\r\n          // THREE-CustomShaderMaterial by Faraz Shaikh: https://github.com/FarazzShaikh/THREE-CustomShaderMaterial\r\n  \r\n          ${beforeMain}\r\n          \r\n          void main() {\r\n          `\r\n        );\r\n\r\n        const lastMainEndIndex = prevShader.lastIndexOf(\"//~CSM_MAIN_END\");\r\n\r\n        if (lastMainEndIndex !== -1) {\r\n          const toAppend = `\r\n            ${mainBody ? `${mainBody}` : \"\"}\r\n            //~CSM_MAIN_END\r\n          `;\r\n          prevShader =\r\n            prevShader.slice(0, lastMainEndIndex) +\r\n            toAppend +\r\n            prevShader.slice(lastMainEndIndex);\r\n        }\r\n      } else {\r\n        const regex = /void\\s*main\\s*\\(\\s*\\)\\s*{/gm;\r\n\r\n        prevShader = prevShader.replace(\r\n          regex,\r\n          `\r\n          // THREE-CustomShaderMaterial by Faraz Shaikh: https://github.com/FarazzShaikh/THREE-CustomShaderMaterial\r\n  \r\n          //~CSM_DEFAULTS\r\n          ${isFrag ? defaultFragDefinitions : defaultVertDefinitions}\r\n          ${defaultCsmDefinitions}\r\n  \r\n          ${beforeMain}\r\n          \r\n          void main() {\r\n            {\r\n              ${defaultCsmMainDefinitions}\r\n            }\r\n            ${isFrag ? defaultFragMain : defaultVertMain}\r\n\r\n            ${mainBody ? `${mainBody}` : \"\"}\r\n            //~CSM_MAIN_END\r\n          `\r\n        );\r\n      }\r\n\r\n      return prevShader;\r\n    };\r\n\r\n    // Override onBeforeCompile\r\n    self.onBeforeCompile = (\r\n      shader: THREE.WebGLProgramParametersWithUniforms,\r\n      renderer: THREE.WebGLRenderer\r\n    ) => {\r\n      // Apply previous onBeforeCompile\r\n      prevOnBeforeCompile?.(shader, renderer);\r\n\r\n      const userPatchMap = patchMap || {};\r\n      // const mergedPatchMap = { ...defaultPatchMap, ...userPatchMap };\r\n\r\n      // Append some defines\r\n      const type = self.type;\r\n      const typeDefine = type\r\n        ? `#define IS_${type.toUpperCase()};\\n`\r\n        : `#define IS_UNKNOWN;\\n`;\r\n      shader.vertexShader =\r\n        typeDefine + \"#define IS_VERTEX\\n\" + shader.vertexShader;\r\n      shader.fragmentShader =\r\n        typeDefine + \"#define IS_FRAGMENT\\n\" + shader.fragmentShader;\r\n\r\n      // Check if the keyword is available in the current material type\r\n      const runPatchMap = (_patchMap: TYPES.CSMPatchMap) => {\r\n        for (const keyword in _patchMap) {\r\n          const doesIncludeInVert =\r\n            keyword === \"*\" || (vertexShader && vertexShader.includes(keyword));\r\n          const doesIncludeInFrag =\r\n            keyword === \"*\" ||\r\n            (fragmentShader && fragmentShader.includes(keyword));\r\n\r\n          if (doesIncludeInFrag || doesIncludeInVert) {\r\n            const availableIn = availabilityMap[keyword];\r\n\r\n            if (\r\n              availableIn &&\r\n              availableIn !== \"*\" &&\r\n              (Array.isArray(availableIn)\r\n                ? !availableIn.includes(type)\r\n                : availableIn !== type)\r\n            ) {\r\n              console.error(\r\n                `CustomShaderMaterial: ${keyword} is not available in ${type}. Shader cannot compile.`\r\n              );\r\n              return;\r\n            }\r\n\r\n            const patchMap = _patchMap[keyword];\r\n\r\n            for (const toReplace in patchMap) {\r\n              const replaceWith = patchMap[toReplace];\r\n\r\n              if (typeof replaceWith === \"object\") {\r\n                const type = replaceWith.type;\r\n                const value = replaceWith.value;\r\n\r\n                if (type === \"fs\") {\r\n                  shader.fragmentShader = shader.fragmentShader.replace(\r\n                    toReplace,\r\n                    value\r\n                  );\r\n                } else if (type === \"vs\") {\r\n                  shader.vertexShader = shader.vertexShader.replace(\r\n                    toReplace,\r\n                    value\r\n                  );\r\n                }\r\n              } else if (replaceWith) {\r\n                shader.vertexShader = shader.vertexShader.replace(\r\n                  toReplace,\r\n                  replaceWith\r\n                );\r\n                shader.fragmentShader = shader.fragmentShader.replace(\r\n                  toReplace,\r\n                  replaceWith\r\n                );\r\n              }\r\n            }\r\n          }\r\n        }\r\n      };\r\n\r\n      runPatchMap(defaultPatchMap);\r\n      runPatchMap(userPatchMap);\r\n\r\n      // Extend the shaders\r\n      shader.vertexShader = extendShader(\r\n        shader.vertexShader,\r\n        vertexShader,\r\n        false\r\n      );\r\n\r\n      shader.fragmentShader = extendShader(\r\n        shader.fragmentShader,\r\n        fragmentShader,\r\n        true\r\n      );\r\n\r\n      if (uniforms) {\r\n        shader.uniforms = { ...shader.uniforms, ...self.uniforms };\r\n      }\r\n\r\n      self.uniforms = shader.uniforms;\r\n    };\r\n\r\n    const prevCacheKey = self.customProgramCacheKey;\r\n\r\n    self.customProgramCacheKey = () => {\r\n      return (\r\n        (cacheKey?.() || hash((vertexShader || \"\") + (fragmentShader || \"\"))) +\r\n        prevCacheKey?.call(self)\r\n      );\r\n    };\r\n\r\n    self.needsUpdate = true;\r\n  }\r\n\r\n  clone() {\r\n    // Get typed `this` for the proxy\r\n    const self = this as typeof this & TYPES.CSMProxy<T>;\r\n\r\n    // @ts-ignore\r\n    const newObj = new self.constructor({\r\n      baseMaterial: self.__csm.baseMaterial.clone(),\r\n      vertexShader: self.__csm.vertexShader,\r\n      fragmentShader: self.__csm.fragmentShader,\r\n      uniforms: self.__csm.uniforms,\r\n      patchMap: self.__csm.patchMap,\r\n      cacheKey: self.__csm.cacheKey,\r\n    });\r\n\r\n    return newObj;\r\n  }\r\n}\r\n\r\nexport {\r\n  type CSMPatchMap,\r\n  type CSMProxy,\r\n  type CustomShaderMaterialParameters,\r\n  type MaterialConstructor,\r\n} from \"./types\";\r\n"],
  "mappings": "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",
  "names": ["defaultCsmDefinitions", "defaultCsmMainDefinitions", "defaultVertDefinitions", "defaultVertMain", "defaultFragDefinitions", "defaultFragMain", "keywordMap", "availabilityMap", "defaultPatchMap", "requiredPropsMap", "sdbm", "string", "hash", "i", "h", "isConstructor", "f", "err", "stripComments", "str", "CustomShaderMaterial", "baseMaterial", "vertexShader", "fragmentShader", "uniforms", "patchMap", "cacheKey", "opts", "base", "isEmptyOpts", "extendedBase", "mergedUniforms", "gettersAndSetters", "key", "descriptor", "value", "_fs", "_vs", "self", "prop", "matchKeywords", "keyword", "matchKeyword", "prevOnBeforeCompile", "extendShader", "prevShader", "newShader", "isFrag", "mainBody", "beforeMain", "mainStartIndex", "braceCount", "mainEndIndex", "fullMain", "lastMainEndIndex", "toAppend", "regex", "shader", "renderer", "userPatchMap", "type", "typeDefine", "runPatchMap", "_patchMap", "doesIncludeInVert", "availableIn", "toReplace", "replaceWith", "prevCacheKey"]
}
