import {
  ArgumentsError,
  DimensionError,
  IndexError,
  _defineProperty,
  _extends,
  absNumber,
  acoshNumber,
  acotNumber,
  acothNumber,
  acscNumber,
  acschNumber,
  addNumber,
  andNumber,
  arraySize,
  asecNumber,
  asechNumber,
  asinhNumber,
  atanhNumber,
  bitAndNumber,
  bitNotNumber,
  bitOrNumber,
  bitXorNumber,
  broadcastTo,
  cbrtNumber,
  clone,
  combinationsNumber,
  concat,
  config,
  copysign,
  cosh,
  cotNumber,
  cothNumber,
  create,
  createAccessorNode,
  createArrayNode,
  createAssignmentNode,
  createBellNumbers,
  createBigNumberPi,
  createBigint,
  createBlockNode,
  createBoolean,
  createCatalan,
  createCeil,
  createChain,
  createChainClass,
  createClone,
  createCombinationsWithRep,
  createCompare,
  createCompareNatural,
  createCompareText,
  createCompile,
  createComposition,
  createConditionalNode,
  createConstantNode,
  createCorr,
  createCumSum,
  createCumSumTransform,
  createDeepEqual,
  createDerivative,
  createE,
  createEqual,
  createEqualScalar,
  createEqualText,
  createErf,
  createEvaluate,
  createFactorial,
  createFalse,
  createFilter,
  createFilterTransform,
  createFix,
  createFloor,
  createForEach,
  createForEachTransform,
  createFormat,
  createFunctionAssignmentNode,
  createFunctionNode,
  createHasNumericValue,
  createHelp,
  createHelpClass,
  createHypot,
  createI,
  createIndexNode,
  createInfinity,
  createIsNumeric,
  createIsPrime,
  createLN10,
  createLN2,
  createLOG10E,
  createLOG2E,
  createLarger,
  createLargerEq,
  createMad,
  createMap,
  createMapSlices,
  createMapSlicesTransform,
  createMapTransform,
  createMatAlgo03xDSf,
  createMatAlgo05xSfSf,
  createMatAlgo07xSSf,
  createMatAlgo11xS0s,
  createMatAlgo12xSfs,
  createMatAlgo14xDs,
  createMatrixAlgorithmSuite,
  createMax,
  createMaxTransform,
  createMean,
  createMeanTransform,
  createMedian,
  createMin,
  createMinTransform,
  createMode,
  createMultinomial,
  createNaN,
  createNode,
  createNull,
  createNumber,
  createNumeric,
  createObjectNode,
  createOperatorNode,
  createParenthesisNode,
  createParse,
  createParser,
  createParserClass,
  createPartitionSelect,
  createPermutations,
  createPhi,
  createPi,
  createPickRandom,
  createPrint,
  createProd,
  createQuantileSeq,
  createRandom,
  createRandomInt,
  createRange,
  createRangeClass,
  createRangeNode,
  createRangeTransform,
  createRationalize,
  createRelationalNode,
  createReplacer,
  createResolve,
  createResultSet,
  createReviver,
  createSQRT1_2,
  createSQRT2,
  createSimplify,
  createSimplifyConstant,
  createSimplifyCore,
  createSize,
  createSmaller,
  createSmallerEq,
  createStd,
  createStdTransform,
  createStirlingS2,
  createString,
  createSum,
  createSumTransform,
  createSymbolNode,
  createTau,
  createTrue,
  createTypeOf,
  createTyped,
  createUnequal,
  createUppercaseE,
  createUppercasePi,
  createVariance,
  createVarianceTransform,
  createVersion,
  createZeta,
  cscNumber,
  cschNumber,
  cubeNumber,
  decimal_default,
  deepMap,
  deepStrictEqual,
  embeddedDocs,
  endsWith,
  errorTransform,
  expNumber,
  expm1Number,
  extend,
  factory,
  flatten,
  format,
  format2,
  gammaG,
  gammaNumber,
  gammaP,
  generalize,
  get,
  getArrayDataType,
  getSafeProperty,
  hasOwnProperty,
  identify,
  isAccessorNode,
  isArray,
  isArrayNode,
  isAssignmentNode,
  isBigInt,
  isBigNumber,
  isBlockNode,
  isBoolean,
  isChain,
  isCollection,
  isComplex,
  isConditionalNode,
  isConstantNode,
  isDate,
  isDenseMatrix,
  isEmptyIndex,
  isFraction,
  isFunction,
  isFunctionAssignmentNode,
  isFunctionNode,
  isHelp,
  isIndex,
  isIndexNode,
  isInteger,
  isMap,
  isMatrix,
  isNaNNumber,
  isNegativeNumber,
  isNode,
  isNull,
  isNumber,
  isObject,
  isObjectNode,
  isObjectWrappingMap,
  isOperatorNode,
  isParenthesisNode,
  isPartitionedMap,
  isPositiveNumber,
  isRange,
  isRangeNode,
  isRegExp,
  isRelationalNode,
  isResultSet,
  isSparseMatrix,
  isString,
  isSymbolNode,
  isUndefined,
  isUnit,
  lastDimToZeroBase,
  lcmNumber,
  leftShiftNumber,
  lgammaNumber,
  lnSqrt2PI,
  log10Number,
  log1p,
  log2Number,
  logNumber,
  memoize,
  multiplyNumber,
  nearlyEqual,
  nearlyEqual2,
  notNumber,
  nthRootNumber,
  optimizeCallback,
  orNumber,
  powNumber,
  printTemplate,
  processSizesWildcard,
  reshape,
  resize,
  rightArithShiftNumber,
  rightLogShiftNumber,
  roundNumber,
  safeNumberType,
  scatter,
  secNumber,
  sechNumber,
  setSafeProperty,
  signNumber,
  sinhNumber,
  splitNumber,
  squareNumber,
  squeeze,
  subtractNumber,
  tanh,
  typeOf,
  unaryMinusNumber,
  unaryPlusNumber,
  unsqueeze,
  validate,
  validateIndex,
  validateIndexSourceSize,
  xgcdNumber,
  xorNumber
} from "./chunk-REKEB2EB.js";
import {
  __export
} from "./chunk-G3PMV62Z.js";

// node_modules/mathjs/lib/esm/factoriesAny.js
var factoriesAny_exports = {};
__export(factoriesAny_exports, {
  createAbs: () => createAbs,
  createAccessorNode: () => createAccessorNode,
  createAcos: () => createAcos,
  createAcosh: () => createAcosh,
  createAcot: () => createAcot,
  createAcoth: () => createAcoth,
  createAcsc: () => createAcsc,
  createAcsch: () => createAcsch,
  createAdd: () => createAdd,
  createAddScalar: () => createAddScalar,
  createAnd: () => createAnd,
  createAndTransform: () => createAndTransform,
  createArg: () => createArg,
  createArrayNode: () => createArrayNode,
  createAsec: () => createAsec,
  createAsech: () => createAsech,
  createAsin: () => createAsin,
  createAsinh: () => createAsinh,
  createAssignmentNode: () => createAssignmentNode,
  createAtan: () => createAtan,
  createAtan2: () => createAtan2,
  createAtanh: () => createAtanh,
  createAtomicMass: () => createAtomicMass,
  createAvogadro: () => createAvogadro,
  createBellNumbers: () => createBellNumbers,
  createBigNumberClass: () => createBigNumberClass,
  createBigint: () => createBigint,
  createBignumber: () => createBignumber,
  createBin: () => createBin,
  createBitAnd: () => createBitAnd,
  createBitAndTransform: () => createBitAndTransform,
  createBitNot: () => createBitNot,
  createBitOr: () => createBitOr,
  createBitOrTransform: () => createBitOrTransform,
  createBitXor: () => createBitXor,
  createBlockNode: () => createBlockNode,
  createBohrMagneton: () => createBohrMagneton,
  createBohrRadius: () => createBohrRadius,
  createBoltzmann: () => createBoltzmann,
  createBoolean: () => createBoolean,
  createCatalan: () => createCatalan,
  createCbrt: () => createCbrt,
  createCeil: () => createCeil,
  createChain: () => createChain,
  createChainClass: () => createChainClass,
  createClassicalElectronRadius: () => createClassicalElectronRadius,
  createClone: () => createClone,
  createColumn: () => createColumn,
  createColumnTransform: () => createColumnTransform,
  createCombinations: () => createCombinations,
  createCombinationsWithRep: () => createCombinationsWithRep,
  createCompare: () => createCompare,
  createCompareNatural: () => createCompareNatural,
  createCompareText: () => createCompareText,
  createCompile: () => createCompile,
  createComplex: () => createComplex,
  createComplexClass: () => createComplexClass,
  createComposition: () => createComposition,
  createConcat: () => createConcat,
  createConcatTransform: () => createConcatTransform,
  createConditionalNode: () => createConditionalNode,
  createConductanceQuantum: () => createConductanceQuantum,
  createConj: () => createConj,
  createConstantNode: () => createConstantNode,
  createCorr: () => createCorr,
  createCos: () => createCos,
  createCosh: () => createCosh,
  createCot: () => createCot,
  createCoth: () => createCoth,
  createCoulomb: () => createCoulomb,
  createCount: () => createCount,
  createCreateUnit: () => createCreateUnit,
  createCross: () => createCross,
  createCsc: () => createCsc,
  createCsch: () => createCsch,
  createCtranspose: () => createCtranspose,
  createCube: () => createCube,
  createCumSum: () => createCumSum,
  createCumSumTransform: () => createCumSumTransform,
  createDeepEqual: () => createDeepEqual,
  createDenseMatrixClass: () => createDenseMatrixClass,
  createDerivative: () => createDerivative,
  createDet: () => createDet,
  createDeuteronMass: () => createDeuteronMass,
  createDiag: () => createDiag,
  createDiff: () => createDiff,
  createDiffTransform: () => createDiffTransform,
  createDistance: () => createDistance,
  createDivide: () => createDivide,
  createDivideScalar: () => createDivideScalar,
  createDot: () => createDot,
  createDotDivide: () => createDotDivide,
  createDotMultiply: () => createDotMultiply,
  createDotPow: () => createDotPow,
  createE: () => createE,
  createEfimovFactor: () => createEfimovFactor,
  createEigs: () => createEigs,
  createElectricConstant: () => createElectricConstant,
  createElectronMass: () => createElectronMass,
  createElementaryCharge: () => createElementaryCharge,
  createEqual: () => createEqual,
  createEqualScalar: () => createEqualScalar,
  createEqualText: () => createEqualText,
  createErf: () => createErf,
  createEvaluate: () => createEvaluate,
  createExp: () => createExp,
  createExpm: () => createExpm,
  createExpm1: () => createExpm1,
  createFactorial: () => createFactorial,
  createFalse: () => createFalse,
  createFaraday: () => createFaraday,
  createFermiCoupling: () => createFermiCoupling,
  createFft: () => createFft,
  createFibonacciHeapClass: () => createFibonacciHeapClass,
  createFilter: () => createFilter,
  createFilterTransform: () => createFilterTransform,
  createFineStructure: () => createFineStructure,
  createFirstRadiation: () => createFirstRadiation,
  createFix: () => createFix,
  createFlatten: () => createFlatten,
  createFloor: () => createFloor,
  createForEach: () => createForEach,
  createForEachTransform: () => createForEachTransform,
  createFormat: () => createFormat,
  createFraction: () => createFraction,
  createFractionClass: () => createFractionClass,
  createFreqz: () => createFreqz,
  createFunctionAssignmentNode: () => createFunctionAssignmentNode,
  createFunctionNode: () => createFunctionNode,
  createGamma: () => createGamma,
  createGasConstant: () => createGasConstant,
  createGcd: () => createGcd,
  createGetMatrixDataType: () => createGetMatrixDataType,
  createGravitationConstant: () => createGravitationConstant,
  createGravity: () => createGravity,
  createHartreeEnergy: () => createHartreeEnergy,
  createHasNumericValue: () => createHasNumericValue,
  createHelp: () => createHelp,
  createHelpClass: () => createHelpClass,
  createHex: () => createHex,
  createHypot: () => createHypot,
  createI: () => createI,
  createIdentity: () => createIdentity,
  createIfft: () => createIfft,
  createIm: () => createIm,
  createImmutableDenseMatrixClass: () => createImmutableDenseMatrixClass,
  createIndex: () => createIndex,
  createIndexClass: () => createIndexClass,
  createIndexNode: () => createIndexNode,
  createIndexTransform: () => createIndexTransform,
  createInfinity: () => createInfinity,
  createIntersect: () => createIntersect,
  createInv: () => createInv,
  createInverseConductanceQuantum: () => createInverseConductanceQuantum,
  createInvmod: () => createInvmod,
  createIsInteger: () => createIsInteger,
  createIsNaN: () => createIsNaN,
  createIsNegative: () => createIsNegative,
  createIsNumeric: () => createIsNumeric,
  createIsPositive: () => createIsPositive,
  createIsPrime: () => createIsPrime,
  createIsZero: () => createIsZero,
  createKldivergence: () => createKldivergence,
  createKlitzing: () => createKlitzing,
  createKron: () => createKron,
  createLN10: () => createLN10,
  createLN2: () => createLN2,
  createLOG10E: () => createLOG10E,
  createLOG2E: () => createLOG2E,
  createLarger: () => createLarger,
  createLargerEq: () => createLargerEq,
  createLcm: () => createLcm,
  createLeafCount: () => createLeafCount,
  createLeftShift: () => createLeftShift,
  createLgamma: () => createLgamma,
  createLog: () => createLog,
  createLog10: () => createLog10,
  createLog1p: () => createLog1p,
  createLog2: () => createLog2,
  createLoschmidt: () => createLoschmidt,
  createLsolve: () => createLsolve,
  createLsolveAll: () => createLsolveAll,
  createLup: () => createLup,
  createLusolve: () => createLusolve,
  createLyap: () => createLyap,
  createMad: () => createMad,
  createMagneticConstant: () => createMagneticConstant,
  createMagneticFluxQuantum: () => createMagneticFluxQuantum,
  createMap: () => createMap,
  createMapSlices: () => createMapSlices,
  createMapSlicesTransform: () => createMapSlicesTransform,
  createMapTransform: () => createMapTransform,
  createMatrix: () => createMatrix,
  createMatrixClass: () => createMatrixClass,
  createMatrixFromColumns: () => createMatrixFromColumns,
  createMatrixFromFunction: () => createMatrixFromFunction,
  createMatrixFromRows: () => createMatrixFromRows,
  createMax: () => createMax,
  createMaxTransform: () => createMaxTransform,
  createMean: () => createMean,
  createMeanTransform: () => createMeanTransform,
  createMedian: () => createMedian,
  createMin: () => createMin,
  createMinTransform: () => createMinTransform,
  createMod: () => createMod,
  createMode: () => createMode,
  createMolarMass: () => createMolarMass,
  createMolarMassC12: () => createMolarMassC12,
  createMolarPlanckConstant: () => createMolarPlanckConstant,
  createMolarVolume: () => createMolarVolume,
  createMultinomial: () => createMultinomial,
  createMultiply: () => createMultiply,
  createMultiplyScalar: () => createMultiplyScalar,
  createNaN: () => createNaN,
  createNeutronMass: () => createNeutronMass,
  createNode: () => createNode,
  createNorm: () => createNorm,
  createNot: () => createNot,
  createNthRoot: () => createNthRoot,
  createNthRoots: () => createNthRoots,
  createNuclearMagneton: () => createNuclearMagneton,
  createNull: () => createNull,
  createNumber: () => createNumber,
  createNumeric: () => createNumeric,
  createObjectNode: () => createObjectNode,
  createOct: () => createOct,
  createOnes: () => createOnes,
  createOperatorNode: () => createOperatorNode,
  createOr: () => createOr,
  createOrTransform: () => createOrTransform,
  createParenthesisNode: () => createParenthesisNode,
  createParse: () => createParse,
  createParser: () => createParser,
  createParserClass: () => createParserClass,
  createPartitionSelect: () => createPartitionSelect,
  createPermutations: () => createPermutations,
  createPhi: () => createPhi,
  createPi: () => createPi,
  createPickRandom: () => createPickRandom,
  createPinv: () => createPinv,
  createPlanckCharge: () => createPlanckCharge,
  createPlanckConstant: () => createPlanckConstant,
  createPlanckLength: () => createPlanckLength,
  createPlanckMass: () => createPlanckMass,
  createPlanckTemperature: () => createPlanckTemperature,
  createPlanckTime: () => createPlanckTime,
  createPolynomialRoot: () => createPolynomialRoot,
  createPow: () => createPow,
  createPrint: () => createPrint,
  createPrintTransform: () => createPrintTransform,
  createProd: () => createProd,
  createProtonMass: () => createProtonMass,
  createQr: () => createQr,
  createQuantileSeq: () => createQuantileSeq,
  createQuantileSeqTransform: () => createQuantileSeqTransform,
  createQuantumOfCirculation: () => createQuantumOfCirculation,
  createRandom: () => createRandom,
  createRandomInt: () => createRandomInt,
  createRange: () => createRange,
  createRangeClass: () => createRangeClass,
  createRangeNode: () => createRangeNode,
  createRangeTransform: () => createRangeTransform,
  createRationalize: () => createRationalize,
  createRe: () => createRe,
  createReducedPlanckConstant: () => createReducedPlanckConstant,
  createRelationalNode: () => createRelationalNode,
  createReplacer: () => createReplacer,
  createReshape: () => createReshape,
  createResize: () => createResize,
  createResolve: () => createResolve,
  createResultSet: () => createResultSet,
  createReviver: () => createReviver,
  createRightArithShift: () => createRightArithShift,
  createRightLogShift: () => createRightLogShift,
  createRotate: () => createRotate,
  createRotationMatrix: () => createRotationMatrix,
  createRound: () => createRound,
  createRow: () => createRow,
  createRowTransform: () => createRowTransform,
  createRydberg: () => createRydberg,
  createSQRT1_2: () => createSQRT1_2,
  createSQRT2: () => createSQRT2,
  createSackurTetrode: () => createSackurTetrode,
  createSchur: () => createSchur,
  createSec: () => createSec,
  createSech: () => createSech,
  createSecondRadiation: () => createSecondRadiation,
  createSetCartesian: () => createSetCartesian,
  createSetDifference: () => createSetDifference,
  createSetDistinct: () => createSetDistinct,
  createSetIntersect: () => createSetIntersect,
  createSetIsSubset: () => createSetIsSubset,
  createSetMultiplicity: () => createSetMultiplicity,
  createSetPowerset: () => createSetPowerset,
  createSetSize: () => createSetSize,
  createSetSymDifference: () => createSetSymDifference,
  createSetUnion: () => createSetUnion,
  createSign: () => createSign,
  createSimplify: () => createSimplify,
  createSimplifyConstant: () => createSimplifyConstant,
  createSimplifyCore: () => createSimplifyCore,
  createSin: () => createSin,
  createSinh: () => createSinh,
  createSize: () => createSize,
  createSlu: () => createSlu,
  createSmaller: () => createSmaller,
  createSmallerEq: () => createSmallerEq,
  createSolveODE: () => createSolveODE,
  createSort: () => createSort,
  createSpaClass: () => createSpaClass,
  createSparse: () => createSparse,
  createSparseMatrixClass: () => createSparseMatrixClass,
  createSpeedOfLight: () => createSpeedOfLight,
  createSplitUnit: () => createSplitUnit,
  createSqrt: () => createSqrt,
  createSqrtm: () => createSqrtm,
  createSquare: () => createSquare,
  createSqueeze: () => createSqueeze,
  createStd: () => createStd,
  createStdTransform: () => createStdTransform,
  createStefanBoltzmann: () => createStefanBoltzmann,
  createStirlingS2: () => createStirlingS2,
  createString: () => createString,
  createSubset: () => createSubset,
  createSubsetTransform: () => createSubsetTransform,
  createSubtract: () => createSubtract,
  createSubtractScalar: () => createSubtractScalar,
  createSum: () => createSum,
  createSumTransform: () => createSumTransform,
  createSylvester: () => createSylvester,
  createSymbolNode: () => createSymbolNode,
  createSymbolicEqual: () => createSymbolicEqual,
  createTan: () => createTan,
  createTanh: () => createTanh,
  createTau: () => createTau,
  createThomsonCrossSection: () => createThomsonCrossSection,
  createTo: () => createTo,
  createTrace: () => createTrace,
  createTranspose: () => createTranspose,
  createTrue: () => createTrue,
  createTypeOf: () => createTypeOf,
  createTyped: () => createTyped,
  createUnaryMinus: () => createUnaryMinus,
  createUnaryPlus: () => createUnaryPlus,
  createUnequal: () => createUnequal,
  createUnitClass: () => createUnitClass,
  createUnitFunction: () => createUnitFunction,
  createUppercaseE: () => createUppercaseE,
  createUppercasePi: () => createUppercasePi,
  createUsolve: () => createUsolve,
  createUsolveAll: () => createUsolveAll,
  createVacuumImpedance: () => createVacuumImpedance,
  createVariance: () => createVariance,
  createVarianceTransform: () => createVarianceTransform,
  createVersion: () => createVersion,
  createWeakMixingAngle: () => createWeakMixingAngle,
  createWienDisplacement: () => createWienDisplacement,
  createXgcd: () => createXgcd,
  createXor: () => createXor,
  createZeros: () => createZeros,
  createZeta: () => createZeta,
  createZpk2tf: () => createZpk2tf
});

// node_modules/mathjs/lib/esm/type/bignumber/BigNumber.js
var name = "BigNumber";
var dependencies = ["?on", "config"];
var createBigNumberClass = factory(name, dependencies, (_ref) => {
  var {
    on,
    config: config2
  } = _ref;
  var BigNumber2 = decimal_default.clone({
    precision: config2.precision,
    modulo: decimal_default.EUCLID
  });
  BigNumber2.prototype = Object.create(BigNumber2.prototype);
  BigNumber2.prototype.type = "BigNumber";
  BigNumber2.prototype.isBigNumber = true;
  BigNumber2.prototype.toJSON = function() {
    return {
      mathjs: "BigNumber",
      value: this.toString()
    };
  };
  BigNumber2.fromJSON = function(json) {
    return new BigNumber2(json.value);
  };
  if (on) {
    on("config", function(curr, prev) {
      if (curr.precision !== prev.precision) {
        BigNumber2.config({
          precision: curr.precision
        });
      }
    });
  }
  return BigNumber2;
}, {
  isClass: true
});

// node_modules/complex.js/dist/complex.mjs
var cosh2 = Math.cosh || function(x) {
  return Math.abs(x) < 1e-9 ? 1 - x : (Math.exp(x) + Math.exp(-x)) * 0.5;
};
var sinh = Math.sinh || function(x) {
  return Math.abs(x) < 1e-9 ? x : (Math.exp(x) - Math.exp(-x)) * 0.5;
};
var cosm1 = function(x) {
  const b = Math.PI / 4;
  if (-b > x || x > b) {
    return Math.cos(x) - 1;
  }
  const xx = x * x;
  return xx * (xx * (xx * (xx * (xx * (xx * (xx * (xx / 20922789888e3 - 1 / 87178291200) + 1 / 479001600) - 1 / 3628800) + 1 / 40320) - 1 / 720) + 1 / 24) - 1 / 2);
};
var hypot = function(x, y) {
  x = Math.abs(x);
  y = Math.abs(y);
  if (x < y) [x, y] = [y, x];
  if (x < 1e8) return Math.sqrt(x * x + y * y);
  y /= x;
  return x * Math.sqrt(1 + y * y);
};
var parser_exit = function() {
  throw SyntaxError("Invalid Param");
};
function logHypot(a, b) {
  const _a = Math.abs(a);
  const _b = Math.abs(b);
  if (a === 0) {
    return Math.log(_b);
  }
  if (b === 0) {
    return Math.log(_a);
  }
  if (_a < 3e3 && _b < 3e3) {
    return Math.log(a * a + b * b) * 0.5;
  }
  a = a * 0.5;
  b = b * 0.5;
  return 0.5 * Math.log(a * a + b * b) + Math.LN2;
}
var P = { "re": 0, "im": 0 };
var parse = function(a, b) {
  const z = P;
  if (a === void 0 || a === null) {
    z["re"] = z["im"] = 0;
  } else if (b !== void 0) {
    z["re"] = a;
    z["im"] = b;
  } else
    switch (typeof a) {
      case "object":
        if ("im" in a && "re" in a) {
          z["re"] = a["re"];
          z["im"] = a["im"];
        } else if ("abs" in a && "arg" in a) {
          if (!isFinite(a["abs"]) && isFinite(a["arg"])) {
            return Complex["INFINITY"];
          }
          z["re"] = a["abs"] * Math.cos(a["arg"]);
          z["im"] = a["abs"] * Math.sin(a["arg"]);
        } else if ("r" in a && "phi" in a) {
          if (!isFinite(a["r"]) && isFinite(a["phi"])) {
            return Complex["INFINITY"];
          }
          z["re"] = a["r"] * Math.cos(a["phi"]);
          z["im"] = a["r"] * Math.sin(a["phi"]);
        } else if (a.length === 2) {
          z["re"] = a[0];
          z["im"] = a[1];
        } else {
          parser_exit();
        }
        break;
      case "string":
        z["im"] = /* void */
        z["re"] = 0;
        const tokens = a.replace(/_/g, "").match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g);
        let plus = 1;
        let minus = 0;
        if (tokens === null) {
          parser_exit();
        }
        for (let i2 = 0; i2 < tokens.length; i2++) {
          const c = tokens[i2];
          if (c === " " || c === "	" || c === "\n") {
          } else if (c === "+") {
            plus++;
          } else if (c === "-") {
            minus++;
          } else if (c === "i" || c === "I") {
            if (plus + minus === 0) {
              parser_exit();
            }
            if (tokens[i2 + 1] !== " " && !isNaN(tokens[i2 + 1])) {
              z["im"] += parseFloat((minus % 2 ? "-" : "") + tokens[i2 + 1]);
              i2++;
            } else {
              z["im"] += parseFloat((minus % 2 ? "-" : "") + "1");
            }
            plus = minus = 0;
          } else {
            if (plus + minus === 0 || isNaN(c)) {
              parser_exit();
            }
            if (tokens[i2 + 1] === "i" || tokens[i2 + 1] === "I") {
              z["im"] += parseFloat((minus % 2 ? "-" : "") + c);
              i2++;
            } else {
              z["re"] += parseFloat((minus % 2 ? "-" : "") + c);
            }
            plus = minus = 0;
          }
        }
        if (plus + minus > 0) {
          parser_exit();
        }
        break;
      case "number":
        z["im"] = 0;
        z["re"] = a;
        break;
      default:
        parser_exit();
    }
  if (isNaN(z["re"]) || isNaN(z["im"])) {
  }
  return z;
};
function Complex(a, b) {
  if (!(this instanceof Complex)) {
    return new Complex(a, b);
  }
  const z = parse(a, b);
  this["re"] = z["re"];
  this["im"] = z["im"];
}
Complex.prototype = {
  "re": 0,
  "im": 0,
  /**
   * Calculates the sign of a complex number, which is a normalized complex
   *
   * @returns {Complex}
   */
  "sign": function() {
    const abs2 = hypot(this["re"], this["im"]);
    return new Complex(
      this["re"] / abs2,
      this["im"] / abs2
    );
  },
  /**
   * Adds two complex numbers
   *
   * @returns {Complex}
   */
  "add": function(a, b) {
    const z = parse(a, b);
    const tInfin = this["isInfinite"]();
    const zInfin = !(isFinite(z["re"]) && isFinite(z["im"]));
    if (tInfin || zInfin) {
      if (tInfin && zInfin) {
        return Complex["NAN"];
      }
      return Complex["INFINITY"];
    }
    return new Complex(
      this["re"] + z["re"],
      this["im"] + z["im"]
    );
  },
  /**
   * Subtracts two complex numbers
   *
   * @returns {Complex}
   */
  "sub": function(a, b) {
    const z = parse(a, b);
    const tInfin = this["isInfinite"]();
    const zInfin = !(isFinite(z["re"]) && isFinite(z["im"]));
    if (tInfin || zInfin) {
      if (tInfin && zInfin) {
        return Complex["NAN"];
      }
      return Complex["INFINITY"];
    }
    return new Complex(
      this["re"] - z["re"],
      this["im"] - z["im"]
    );
  },
  /**
   * Multiplies two complex numbers
   *
   * @returns {Complex}
   */
  "mul": function(a, b) {
    const z = parse(a, b);
    const tInfin = this["isInfinite"]();
    const zInfin = !(isFinite(z["re"]) && isFinite(z["im"]));
    const tIsZero = this["re"] === 0 && this["im"] === 0;
    const zIsZero = z["re"] === 0 && z["im"] === 0;
    if (tInfin && zIsZero || zInfin && tIsZero) {
      return Complex["NAN"];
    }
    if (tInfin || zInfin) {
      return Complex["INFINITY"];
    }
    if (z["im"] === 0 && this["im"] === 0) {
      return new Complex(this["re"] * z["re"], 0);
    }
    return new Complex(
      this["re"] * z["re"] - this["im"] * z["im"],
      this["re"] * z["im"] + this["im"] * z["re"]
    );
  },
  /**
   * Divides two complex numbers
   *
   * @returns {Complex}
   */
  "div": function(a, b) {
    const z = parse(a, b);
    const tInfin = this["isInfinite"]();
    const zInfin = !(isFinite(z["re"]) && isFinite(z["im"]));
    const tIsZero = this["re"] === 0 && this["im"] === 0;
    const zIsZero = z["re"] === 0 && z["im"] === 0;
    if (tIsZero && zIsZero || tInfin && zInfin) {
      return Complex["NAN"];
    }
    if (zIsZero || tInfin) {
      return Complex["INFINITY"];
    }
    if (tIsZero || zInfin) {
      return Complex["ZERO"];
    }
    if (0 === z["im"]) {
      return new Complex(this["re"] / z["re"], this["im"] / z["re"]);
    }
    if (Math.abs(z["re"]) < Math.abs(z["im"])) {
      const x = z["re"] / z["im"];
      const t = z["re"] * x + z["im"];
      return new Complex(
        (this["re"] * x + this["im"]) / t,
        (this["im"] * x - this["re"]) / t
      );
    } else {
      const x = z["im"] / z["re"];
      const t = z["im"] * x + z["re"];
      return new Complex(
        (this["re"] + this["im"] * x) / t,
        (this["im"] - this["re"] * x) / t
      );
    }
  },
  /**
   * Calculate the power of two complex numbers
   *
   * @returns {Complex}
   */
  "pow": function(a, b) {
    const z = parse(a, b);
    const tIsZero = this["re"] === 0 && this["im"] === 0;
    const zIsZero = z["re"] === 0 && z["im"] === 0;
    if (zIsZero) {
      return Complex["ONE"];
    }
    if (z["im"] === 0) {
      if (this["im"] === 0 && this["re"] > 0) {
        return new Complex(Math.pow(this["re"], z["re"]), 0);
      } else if (this["re"] === 0) {
        switch ((z["re"] % 4 + 4) % 4) {
          case 0:
            return new Complex(Math.pow(this["im"], z["re"]), 0);
          case 1:
            return new Complex(0, Math.pow(this["im"], z["re"]));
          case 2:
            return new Complex(-Math.pow(this["im"], z["re"]), 0);
          case 3:
            return new Complex(0, -Math.pow(this["im"], z["re"]));
        }
      }
    }
    if (tIsZero && z["re"] > 0) {
      return Complex["ZERO"];
    }
    const arg2 = Math.atan2(this["im"], this["re"]);
    const loh = logHypot(this["re"], this["im"]);
    let re2 = Math.exp(z["re"] * loh - z["im"] * arg2);
    let im2 = z["im"] * loh + z["re"] * arg2;
    return new Complex(
      re2 * Math.cos(im2),
      re2 * Math.sin(im2)
    );
  },
  /**
   * Calculate the complex square root
   *
   * @returns {Complex}
   */
  "sqrt": function() {
    const a = this["re"];
    const b = this["im"];
    if (b === 0) {
      if (a >= 0) {
        return new Complex(Math.sqrt(a), 0);
      } else {
        return new Complex(0, Math.sqrt(-a));
      }
    }
    const r = hypot(a, b);
    let re2 = Math.sqrt(0.5 * (r + Math.abs(a)));
    let im2 = Math.abs(b) / (2 * re2);
    if (a >= 0) {
      return new Complex(re2, b < 0 ? -im2 : im2);
    } else {
      return new Complex(im2, b < 0 ? -re2 : re2);
    }
  },
  /**
   * Calculate the complex exponent
   *
   * @returns {Complex}
   */
  "exp": function() {
    const er = Math.exp(this["re"]);
    if (this["im"] === 0) {
      return new Complex(er, 0);
    }
    return new Complex(
      er * Math.cos(this["im"]),
      er * Math.sin(this["im"])
    );
  },
  /**
   * Calculate the complex exponent and subtracts one.
   *
   * This may be more accurate than `Complex(x).exp().sub(1)` if
   * `x` is small.
   *
   * @returns {Complex}
   */
  "expm1": function() {
    const a = this["re"];
    const b = this["im"];
    return new Complex(
      Math.expm1(a) * Math.cos(b) + cosm1(b),
      Math.exp(a) * Math.sin(b)
    );
  },
  /**
   * Calculate the natural log
   *
   * @returns {Complex}
   */
  "log": function() {
    const a = this["re"];
    const b = this["im"];
    if (b === 0 && a > 0) {
      return new Complex(Math.log(a), 0);
    }
    return new Complex(
      logHypot(a, b),
      Math.atan2(b, a)
    );
  },
  /**
   * Calculate the magnitude of the complex number
   *
   * @returns {number}
   */
  "abs": function() {
    return hypot(this["re"], this["im"]);
  },
  /**
   * Calculate the angle of the complex number
   *
   * @returns {number}
   */
  "arg": function() {
    return Math.atan2(this["im"], this["re"]);
  },
  /**
   * Calculate the sine of the complex number
   *
   * @returns {Complex}
   */
  "sin": function() {
    const a = this["re"];
    const b = this["im"];
    return new Complex(
      Math.sin(a) * cosh2(b),
      Math.cos(a) * sinh(b)
    );
  },
  /**
   * Calculate the cosine
   *
   * @returns {Complex}
   */
  "cos": function() {
    const a = this["re"];
    const b = this["im"];
    return new Complex(
      Math.cos(a) * cosh2(b),
      -Math.sin(a) * sinh(b)
    );
  },
  /**
   * Calculate the tangent
   *
   * @returns {Complex}
   */
  "tan": function() {
    const a = 2 * this["re"];
    const b = 2 * this["im"];
    const d = Math.cos(a) + cosh2(b);
    return new Complex(
      Math.sin(a) / d,
      sinh(b) / d
    );
  },
  /**
   * Calculate the cotangent
   *
   * @returns {Complex}
   */
  "cot": function() {
    const a = 2 * this["re"];
    const b = 2 * this["im"];
    const d = Math.cos(a) - cosh2(b);
    return new Complex(
      -Math.sin(a) / d,
      sinh(b) / d
    );
  },
  /**
   * Calculate the secant
   *
   * @returns {Complex}
   */
  "sec": function() {
    const a = this["re"];
    const b = this["im"];
    const d = 0.5 * cosh2(2 * b) + 0.5 * Math.cos(2 * a);
    return new Complex(
      Math.cos(a) * cosh2(b) / d,
      Math.sin(a) * sinh(b) / d
    );
  },
  /**
   * Calculate the cosecans
   *
   * @returns {Complex}
   */
  "csc": function() {
    const a = this["re"];
    const b = this["im"];
    const d = 0.5 * cosh2(2 * b) - 0.5 * Math.cos(2 * a);
    return new Complex(
      Math.sin(a) * cosh2(b) / d,
      -Math.cos(a) * sinh(b) / d
    );
  },
  /**
   * Calculate the complex arcus sinus
   *
   * @returns {Complex}
   */
  "asin": function() {
    const a = this["re"];
    const b = this["im"];
    const t1 = new Complex(
      b * b - a * a + 1,
      -2 * a * b
    )["sqrt"]();
    const t2 = new Complex(
      t1["re"] - b,
      t1["im"] + a
    )["log"]();
    return new Complex(t2["im"], -t2["re"]);
  },
  /**
   * Calculate the complex arcus cosinus
   *
   * @returns {Complex}
   */
  "acos": function() {
    const a = this["re"];
    const b = this["im"];
    const t1 = new Complex(
      b * b - a * a + 1,
      -2 * a * b
    )["sqrt"]();
    const t2 = new Complex(
      t1["re"] - b,
      t1["im"] + a
    )["log"]();
    return new Complex(Math.PI / 2 - t2["im"], t2["re"]);
  },
  /**
   * Calculate the complex arcus tangent
   *
   * @returns {Complex}
   */
  "atan": function() {
    const a = this["re"];
    const b = this["im"];
    if (a === 0) {
      if (b === 1) {
        return new Complex(0, Infinity);
      }
      if (b === -1) {
        return new Complex(0, -Infinity);
      }
    }
    const d = a * a + (1 - b) * (1 - b);
    const t1 = new Complex(
      (1 - b * b - a * a) / d,
      -2 * a / d
    ).log();
    return new Complex(-0.5 * t1["im"], 0.5 * t1["re"]);
  },
  /**
   * Calculate the complex arcus cotangent
   *
   * @returns {Complex}
   */
  "acot": function() {
    const a = this["re"];
    const b = this["im"];
    if (b === 0) {
      return new Complex(Math.atan2(1, a), 0);
    }
    const d = a * a + b * b;
    return d !== 0 ? new Complex(
      a / d,
      -b / d
    ).atan() : new Complex(
      a !== 0 ? a / 0 : 0,
      b !== 0 ? -b / 0 : 0
    ).atan();
  },
  /**
   * Calculate the complex arcus secant
   *
   * @returns {Complex}
   */
  "asec": function() {
    const a = this["re"];
    const b = this["im"];
    if (a === 0 && b === 0) {
      return new Complex(0, Infinity);
    }
    const d = a * a + b * b;
    return d !== 0 ? new Complex(
      a / d,
      -b / d
    ).acos() : new Complex(
      a !== 0 ? a / 0 : 0,
      b !== 0 ? -b / 0 : 0
    ).acos();
  },
  /**
   * Calculate the complex arcus cosecans
   *
   * @returns {Complex}
   */
  "acsc": function() {
    const a = this["re"];
    const b = this["im"];
    if (a === 0 && b === 0) {
      return new Complex(Math.PI / 2, Infinity);
    }
    const d = a * a + b * b;
    return d !== 0 ? new Complex(
      a / d,
      -b / d
    ).asin() : new Complex(
      a !== 0 ? a / 0 : 0,
      b !== 0 ? -b / 0 : 0
    ).asin();
  },
  /**
   * Calculate the complex sinh
   *
   * @returns {Complex}
   */
  "sinh": function() {
    const a = this["re"];
    const b = this["im"];
    return new Complex(
      sinh(a) * Math.cos(b),
      cosh2(a) * Math.sin(b)
    );
  },
  /**
   * Calculate the complex cosh
   *
   * @returns {Complex}
   */
  "cosh": function() {
    const a = this["re"];
    const b = this["im"];
    return new Complex(
      cosh2(a) * Math.cos(b),
      sinh(a) * Math.sin(b)
    );
  },
  /**
   * Calculate the complex tanh
   *
   * @returns {Complex}
   */
  "tanh": function() {
    const a = 2 * this["re"];
    const b = 2 * this["im"];
    const d = cosh2(a) + Math.cos(b);
    return new Complex(
      sinh(a) / d,
      Math.sin(b) / d
    );
  },
  /**
   * Calculate the complex coth
   *
   * @returns {Complex}
   */
  "coth": function() {
    const a = 2 * this["re"];
    const b = 2 * this["im"];
    const d = cosh2(a) - Math.cos(b);
    return new Complex(
      sinh(a) / d,
      -Math.sin(b) / d
    );
  },
  /**
   * Calculate the complex coth
   *
   * @returns {Complex}
   */
  "csch": function() {
    const a = this["re"];
    const b = this["im"];
    const d = Math.cos(2 * b) - cosh2(2 * a);
    return new Complex(
      -2 * sinh(a) * Math.cos(b) / d,
      2 * cosh2(a) * Math.sin(b) / d
    );
  },
  /**
   * Calculate the complex sech
   *
   * @returns {Complex}
   */
  "sech": function() {
    const a = this["re"];
    const b = this["im"];
    const d = Math.cos(2 * b) + cosh2(2 * a);
    return new Complex(
      2 * cosh2(a) * Math.cos(b) / d,
      -2 * sinh(a) * Math.sin(b) / d
    );
  },
  /**
   * Calculate the complex asinh
   *
   * @returns {Complex}
   */
  "asinh": function() {
    let tmp = this["im"];
    this["im"] = -this["re"];
    this["re"] = tmp;
    const res = this["asin"]();
    this["re"] = -this["im"];
    this["im"] = tmp;
    tmp = res["re"];
    res["re"] = -res["im"];
    res["im"] = tmp;
    return res;
  },
  /**
   * Calculate the complex acosh
   *
   * @returns {Complex}
   */
  "acosh": function() {
    const res = this["acos"]();
    if (res["im"] <= 0) {
      const tmp = res["re"];
      res["re"] = -res["im"];
      res["im"] = tmp;
    } else {
      const tmp = res["im"];
      res["im"] = -res["re"];
      res["re"] = tmp;
    }
    return res;
  },
  /**
   * Calculate the complex atanh
   *
   * @returns {Complex}
   */
  "atanh": function() {
    const a = this["re"];
    const b = this["im"];
    const noIM = a > 1 && b === 0;
    const oneMinus = 1 - a;
    const onePlus = 1 + a;
    const d = oneMinus * oneMinus + b * b;
    const x = d !== 0 ? new Complex(
      (onePlus * oneMinus - b * b) / d,
      (b * oneMinus + onePlus * b) / d
    ) : new Complex(
      a !== -1 ? a / 0 : 0,
      b !== 0 ? b / 0 : 0
    );
    const temp = x["re"];
    x["re"] = logHypot(x["re"], x["im"]) / 2;
    x["im"] = Math.atan2(x["im"], temp) / 2;
    if (noIM) {
      x["im"] = -x["im"];
    }
    return x;
  },
  /**
   * Calculate the complex acoth
   *
   * @returns {Complex}
   */
  "acoth": function() {
    const a = this["re"];
    const b = this["im"];
    if (a === 0 && b === 0) {
      return new Complex(0, Math.PI / 2);
    }
    const d = a * a + b * b;
    return d !== 0 ? new Complex(
      a / d,
      -b / d
    ).atanh() : new Complex(
      a !== 0 ? a / 0 : 0,
      b !== 0 ? -b / 0 : 0
    ).atanh();
  },
  /**
   * Calculate the complex acsch
   *
   * @returns {Complex}
   */
  "acsch": function() {
    const a = this["re"];
    const b = this["im"];
    if (b === 0) {
      return new Complex(
        a !== 0 ? Math.log(a + Math.sqrt(a * a + 1)) : Infinity,
        0
      );
    }
    const d = a * a + b * b;
    return d !== 0 ? new Complex(
      a / d,
      -b / d
    ).asinh() : new Complex(
      a !== 0 ? a / 0 : 0,
      b !== 0 ? -b / 0 : 0
    ).asinh();
  },
  /**
   * Calculate the complex asech
   *
   * @returns {Complex}
   */
  "asech": function() {
    const a = this["re"];
    const b = this["im"];
    if (this["isZero"]()) {
      return Complex["INFINITY"];
    }
    const d = a * a + b * b;
    return d !== 0 ? new Complex(
      a / d,
      -b / d
    ).acosh() : new Complex(
      a !== 0 ? a / 0 : 0,
      b !== 0 ? -b / 0 : 0
    ).acosh();
  },
  /**
   * Calculate the complex inverse 1/z
   *
   * @returns {Complex}
   */
  "inverse": function() {
    if (this["isZero"]()) {
      return Complex["INFINITY"];
    }
    if (this["isInfinite"]()) {
      return Complex["ZERO"];
    }
    const a = this["re"];
    const b = this["im"];
    const d = a * a + b * b;
    return new Complex(a / d, -b / d);
  },
  /**
   * Returns the complex conjugate
   *
   * @returns {Complex}
   */
  "conjugate": function() {
    return new Complex(this["re"], -this["im"]);
  },
  /**
   * Gets the negated complex number
   *
   * @returns {Complex}
   */
  "neg": function() {
    return new Complex(-this["re"], -this["im"]);
  },
  /**
   * Ceils the actual complex number
   *
   * @returns {Complex}
   */
  "ceil": function(places) {
    places = Math.pow(10, places || 0);
    return new Complex(
      Math.ceil(this["re"] * places) / places,
      Math.ceil(this["im"] * places) / places
    );
  },
  /**
   * Floors the actual complex number
   *
   * @returns {Complex}
   */
  "floor": function(places) {
    places = Math.pow(10, places || 0);
    return new Complex(
      Math.floor(this["re"] * places) / places,
      Math.floor(this["im"] * places) / places
    );
  },
  /**
   * Ceils the actual complex number
   *
   * @returns {Complex}
   */
  "round": function(places) {
    places = Math.pow(10, places || 0);
    return new Complex(
      Math.round(this["re"] * places) / places,
      Math.round(this["im"] * places) / places
    );
  },
  /**
   * Compares two complex numbers
   *
   * **Note:** new Complex(Infinity).equals(Infinity) === false
   *
   * @returns {boolean}
   */
  "equals": function(a, b) {
    const z = parse(a, b);
    return Math.abs(z["re"] - this["re"]) <= Complex["EPSILON"] && Math.abs(z["im"] - this["im"]) <= Complex["EPSILON"];
  },
  /**
   * Clones the actual object
   *
   * @returns {Complex}
   */
  "clone": function() {
    return new Complex(this["re"], this["im"]);
  },
  /**
   * Gets a string of the actual complex number
   *
   * @returns {string}
   */
  "toString": function() {
    let a = this["re"];
    let b = this["im"];
    let ret = "";
    if (this["isNaN"]()) {
      return "NaN";
    }
    if (this["isInfinite"]()) {
      return "Infinity";
    }
    if (Math.abs(a) < Complex["EPSILON"]) {
      a = 0;
    }
    if (Math.abs(b) < Complex["EPSILON"]) {
      b = 0;
    }
    if (b === 0) {
      return ret + a;
    }
    if (a !== 0) {
      ret += a;
      ret += " ";
      if (b < 0) {
        b = -b;
        ret += "-";
      } else {
        ret += "+";
      }
      ret += " ";
    } else if (b < 0) {
      b = -b;
      ret += "-";
    }
    if (1 !== b) {
      ret += b;
    }
    return ret + "i";
  },
  /**
   * Returns the actual number as a vector
   *
   * @returns {Array}
   */
  "toVector": function() {
    return [this["re"], this["im"]];
  },
  /**
   * Returns the actual real value of the current object
   *
   * @returns {number|null}
   */
  "valueOf": function() {
    if (this["im"] === 0) {
      return this["re"];
    }
    return null;
  },
  /**
   * Determines whether a complex number is not on the Riemann sphere.
   *
   * @returns {boolean}
   */
  "isNaN": function() {
    return isNaN(this["re"]) || isNaN(this["im"]);
  },
  /**
   * Determines whether or not a complex number is at the zero pole of the
   * Riemann sphere.
   *
   * @returns {boolean}
   */
  "isZero": function() {
    return this["im"] === 0 && this["re"] === 0;
  },
  /**
   * Determines whether a complex number is not at the infinity pole of the
   * Riemann sphere.
   *
   * @returns {boolean}
   */
  "isFinite": function() {
    return isFinite(this["re"]) && isFinite(this["im"]);
  },
  /**
   * Determines whether or not a complex number is at the infinity pole of the
   * Riemann sphere.
   *
   * @returns {boolean}
   */
  "isInfinite": function() {
    return !this["isFinite"]();
  }
};
Complex["ZERO"] = new Complex(0, 0);
Complex["ONE"] = new Complex(1, 0);
Complex["I"] = new Complex(0, 1);
Complex["PI"] = new Complex(Math.PI, 0);
Complex["E"] = new Complex(Math.E, 0);
Complex["INFINITY"] = new Complex(Infinity, Infinity);
Complex["NAN"] = new Complex(NaN, NaN);
Complex["EPSILON"] = 1e-15;

// node_modules/mathjs/lib/esm/type/complex/Complex.js
var name2 = "Complex";
var dependencies2 = [];
var createComplexClass = factory(name2, dependencies2, () => {
  Object.defineProperty(Complex, "name", {
    value: "Complex"
  });
  Complex.prototype.constructor = Complex;
  Complex.prototype.type = "Complex";
  Complex.prototype.isComplex = true;
  Complex.prototype.toJSON = function() {
    return {
      mathjs: "Complex",
      re: this.re,
      im: this.im
    };
  };
  Complex.prototype.toPolar = function() {
    return {
      r: this.abs(),
      phi: this.arg()
    };
  };
  Complex.prototype.format = function(options) {
    var str = "";
    var im2 = this.im;
    var re2 = this.re;
    var strRe = format(this.re, options);
    var strIm = format(this.im, options);
    var precision = isNumber(options) ? options : options ? options.precision : null;
    if (precision !== null) {
      var epsilon = Math.pow(10, -precision);
      if (Math.abs(re2 / im2) < epsilon) {
        re2 = 0;
      }
      if (Math.abs(im2 / re2) < epsilon) {
        im2 = 0;
      }
    }
    if (im2 === 0) {
      str = strRe;
    } else if (re2 === 0) {
      if (im2 === 1) {
        str = "i";
      } else if (im2 === -1) {
        str = "-i";
      } else {
        str = strIm + "i";
      }
    } else {
      if (im2 < 0) {
        if (im2 === -1) {
          str = strRe + " - i";
        } else {
          str = strRe + " - " + strIm.substring(1) + "i";
        }
      } else {
        if (im2 === 1) {
          str = strRe + " + i";
        } else {
          str = strRe + " + " + strIm + "i";
        }
      }
    }
    return str;
  };
  Complex.fromPolar = function(args) {
    switch (arguments.length) {
      case 1: {
        var arg2 = arguments[0];
        if (typeof arg2 === "object") {
          return Complex(arg2);
        } else {
          throw new TypeError("Input has to be an object with r and phi keys.");
        }
      }
      case 2: {
        var r = arguments[0];
        var phi2 = arguments[1];
        if (isNumber(r)) {
          if (isUnit(phi2) && phi2.hasBase("ANGLE")) {
            phi2 = phi2.toNumber("rad");
          }
          if (isNumber(phi2)) {
            return new Complex({
              r,
              phi: phi2
            });
          }
          throw new TypeError("Phi is not a number nor an angle unit.");
        } else {
          throw new TypeError("Radius r is not a number.");
        }
      }
      default:
        throw new SyntaxError("Wrong number of arguments in function fromPolar");
    }
  };
  Complex.prototype.valueOf = Complex.prototype.toString;
  Complex.fromJSON = function(json) {
    return new Complex(json);
  };
  Complex.compare = function(a, b) {
    if (a.re > b.re) {
      return 1;
    }
    if (a.re < b.re) {
      return -1;
    }
    if (a.im > b.im) {
      return 1;
    }
    if (a.im < b.im) {
      return -1;
    }
    return 0;
  };
  return Complex;
}, {
  isClass: true
});

// node_modules/fraction.js/dist/fraction.mjs
if (typeof BigInt === "undefined") BigInt = function(n) {
  if (isNaN(n)) throw new Error("");
  return n;
};
var C_ZERO = BigInt(0);
var C_ONE = BigInt(1);
var C_TWO = BigInt(2);
var C_FIVE = BigInt(5);
var C_TEN = BigInt(10);
var MAX_CYCLE_LEN = 2e3;
var P2 = {
  "s": C_ONE,
  "n": C_ZERO,
  "d": C_ONE
};
function assign(n, s) {
  try {
    n = BigInt(n);
  } catch (e2) {
    throw InvalidParameter();
  }
  return n * s;
}
function trunc(x) {
  return typeof x === "bigint" ? x : Math.floor(x);
}
function newFraction(n, d) {
  if (d === C_ZERO) {
    throw DivisionByZero();
  }
  const f = Object.create(Fraction.prototype);
  f["s"] = n < C_ZERO ? -C_ONE : C_ONE;
  n = n < C_ZERO ? -n : n;
  const a = gcd(n, d);
  f["n"] = n / a;
  f["d"] = d / a;
  return f;
}
function factorize(num) {
  const factors = {};
  let n = num;
  let i2 = C_TWO;
  let s = C_FIVE - C_ONE;
  while (s <= n) {
    while (n % i2 === C_ZERO) {
      n /= i2;
      factors[i2] = (factors[i2] || C_ZERO) + C_ONE;
    }
    s += C_ONE + C_TWO * i2++;
  }
  if (n !== num) {
    if (n > 1)
      factors[n] = (factors[n] || C_ZERO) + C_ONE;
  } else {
    factors[num] = (factors[num] || C_ZERO) + C_ONE;
  }
  return factors;
}
var parse2 = function(p1, p2) {
  let n = C_ZERO, d = C_ONE, s = C_ONE;
  if (p1 === void 0 || p1 === null) {
  } else if (p2 !== void 0) {
    if (typeof p1 === "bigint") {
      n = p1;
    } else if (isNaN(p1)) {
      throw InvalidParameter();
    } else if (p1 % 1 !== 0) {
      throw NonIntegerParameter();
    } else {
      n = BigInt(p1);
    }
    if (typeof p2 === "bigint") {
      d = p2;
    } else if (isNaN(p2)) {
      throw InvalidParameter();
    } else if (p2 % 1 !== 0) {
      throw NonIntegerParameter();
    } else {
      d = BigInt(p2);
    }
    s = n * d;
  } else if (typeof p1 === "object") {
    if ("d" in p1 && "n" in p1) {
      n = BigInt(p1["n"]);
      d = BigInt(p1["d"]);
      if ("s" in p1)
        n *= BigInt(p1["s"]);
    } else if (0 in p1) {
      n = BigInt(p1[0]);
      if (1 in p1)
        d = BigInt(p1[1]);
    } else if (typeof p1 === "bigint") {
      n = p1;
    } else {
      throw InvalidParameter();
    }
    s = n * d;
  } else if (typeof p1 === "number") {
    if (isNaN(p1)) {
      throw InvalidParameter();
    }
    if (p1 < 0) {
      s = -C_ONE;
      p1 = -p1;
    }
    if (p1 % 1 === 0) {
      n = BigInt(p1);
    } else {
      let z = 1;
      let A = 0, B = 1;
      let C = 1, D = 1;
      let N = 1e7;
      if (p1 >= 1) {
        z = 10 ** Math.floor(1 + Math.log10(p1));
        p1 /= z;
      }
      while (B <= N && D <= N) {
        let M = (A + C) / (B + D);
        if (p1 === M) {
          if (B + D <= N) {
            n = A + C;
            d = B + D;
          } else if (D > B) {
            n = C;
            d = D;
          } else {
            n = A;
            d = B;
          }
          break;
        } else {
          if (p1 > M) {
            A += C;
            B += D;
          } else {
            C += A;
            D += B;
          }
          if (B > N) {
            n = C;
            d = D;
          } else {
            n = A;
            d = B;
          }
        }
      }
      n = BigInt(n) * BigInt(z);
      d = BigInt(d);
    }
  } else if (typeof p1 === "string") {
    let ndx = 0;
    let v = C_ZERO, w = C_ZERO, x = C_ZERO, y = C_ONE, z = C_ONE;
    let match = p1.replace(/_/g, "").match(/\d+|./g);
    if (match === null)
      throw InvalidParameter();
    if (match[ndx] === "-") {
      s = -C_ONE;
      ndx++;
    } else if (match[ndx] === "+") {
      ndx++;
    }
    if (match.length === ndx + 1) {
      w = assign(match[ndx++], s);
    } else if (match[ndx + 1] === "." || match[ndx] === ".") {
      if (match[ndx] !== ".") {
        v = assign(match[ndx++], s);
      }
      ndx++;
      if (ndx + 1 === match.length || match[ndx + 1] === "(" && match[ndx + 3] === ")" || match[ndx + 1] === "'" && match[ndx + 3] === "'") {
        w = assign(match[ndx], s);
        y = C_TEN ** BigInt(match[ndx].length);
        ndx++;
      }
      if (match[ndx] === "(" && match[ndx + 2] === ")" || match[ndx] === "'" && match[ndx + 2] === "'") {
        x = assign(match[ndx + 1], s);
        z = C_TEN ** BigInt(match[ndx + 1].length) - C_ONE;
        ndx += 3;
      }
    } else if (match[ndx + 1] === "/" || match[ndx + 1] === ":") {
      w = assign(match[ndx], s);
      y = assign(match[ndx + 2], C_ONE);
      ndx += 3;
    } else if (match[ndx + 3] === "/" && match[ndx + 1] === " ") {
      v = assign(match[ndx], s);
      w = assign(match[ndx + 2], s);
      y = assign(match[ndx + 4], C_ONE);
      ndx += 5;
    }
    if (match.length <= ndx) {
      d = y * z;
      s = /* void */
      n = x + d * v + z * w;
    } else {
      throw InvalidParameter();
    }
  } else if (typeof p1 === "bigint") {
    n = p1;
    s = p1;
    d = C_ONE;
  } else {
    throw InvalidParameter();
  }
  if (d === C_ZERO) {
    throw DivisionByZero();
  }
  P2["s"] = s < C_ZERO ? -C_ONE : C_ONE;
  P2["n"] = n < C_ZERO ? -n : n;
  P2["d"] = d < C_ZERO ? -d : d;
};
function modpow(b, e2, m) {
  let r = C_ONE;
  for (; e2 > C_ZERO; b = b * b % m, e2 >>= C_ONE) {
    if (e2 & C_ONE) {
      r = r * b % m;
    }
  }
  return r;
}
function cycleLen(n, d) {
  for (; d % C_TWO === C_ZERO; d /= C_TWO) {
  }
  for (; d % C_FIVE === C_ZERO; d /= C_FIVE) {
  }
  if (d === C_ONE)
    return C_ZERO;
  let rem = C_TEN % d;
  let t = 1;
  for (; rem !== C_ONE; t++) {
    rem = rem * C_TEN % d;
    if (t > MAX_CYCLE_LEN)
      return C_ZERO;
  }
  return BigInt(t);
}
function cycleStart(n, d, len) {
  let rem1 = C_ONE;
  let rem2 = modpow(C_TEN, len, d);
  for (let t = 0; t < 300; t++) {
    if (rem1 === rem2)
      return BigInt(t);
    rem1 = rem1 * C_TEN % d;
    rem2 = rem2 * C_TEN % d;
  }
  return 0;
}
function gcd(a, b) {
  if (!a)
    return b;
  if (!b)
    return a;
  while (1) {
    a %= b;
    if (!a)
      return b;
    b %= a;
    if (!b)
      return a;
  }
}
function Fraction(a, b) {
  parse2(a, b);
  if (this instanceof Fraction) {
    a = gcd(P2["d"], P2["n"]);
    this["s"] = P2["s"];
    this["n"] = P2["n"] / a;
    this["d"] = P2["d"] / a;
  } else {
    return newFraction(P2["s"] * P2["n"], P2["d"]);
  }
}
var DivisionByZero = function() {
  return new Error("Division by Zero");
};
var InvalidParameter = function() {
  return new Error("Invalid argument");
};
var NonIntegerParameter = function() {
  return new Error("Parameters must be integer");
};
Fraction.prototype = {
  "s": C_ONE,
  "n": C_ZERO,
  "d": C_ONE,
  /**
   * Calculates the absolute value
   *
   * Ex: new Fraction(-4).abs() => 4
   **/
  "abs": function() {
    return newFraction(this["n"], this["d"]);
  },
  /**
   * Inverts the sign of the current fraction
   *
   * Ex: new Fraction(-4).neg() => 4
   **/
  "neg": function() {
    return newFraction(-this["s"] * this["n"], this["d"]);
  },
  /**
   * Adds two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
   **/
  "add": function(a, b) {
    parse2(a, b);
    return newFraction(
      this["s"] * this["n"] * P2["d"] + P2["s"] * this["d"] * P2["n"],
      this["d"] * P2["d"]
    );
  },
  /**
   * Subtracts two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
   **/
  "sub": function(a, b) {
    parse2(a, b);
    return newFraction(
      this["s"] * this["n"] * P2["d"] - P2["s"] * this["d"] * P2["n"],
      this["d"] * P2["d"]
    );
  },
  /**
   * Multiplies two rational numbers
   *
   * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
   **/
  "mul": function(a, b) {
    parse2(a, b);
    return newFraction(
      this["s"] * P2["s"] * this["n"] * P2["n"],
      this["d"] * P2["d"]
    );
  },
  /**
   * Divides two rational numbers
   *
   * Ex: new Fraction("-17.(345)").inverse().div(3)
   **/
  "div": function(a, b) {
    parse2(a, b);
    return newFraction(
      this["s"] * P2["s"] * this["n"] * P2["d"],
      this["d"] * P2["n"]
    );
  },
  /**
   * Clones the actual object
   *
   * Ex: new Fraction("-17.(345)").clone()
   **/
  "clone": function() {
    return newFraction(this["s"] * this["n"], this["d"]);
  },
  /**
   * Calculates the modulo of two rational numbers - a more precise fmod
   *
   * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
   * Ex: new Fraction(20, 10).mod().equals(0) ? "is Integer"
   **/
  "mod": function(a, b) {
    if (a === void 0) {
      return newFraction(this["s"] * this["n"] % this["d"], C_ONE);
    }
    parse2(a, b);
    if (C_ZERO === P2["n"] * this["d"]) {
      throw DivisionByZero();
    }
    return newFraction(
      this["s"] * (P2["d"] * this["n"]) % (P2["n"] * this["d"]),
      P2["d"] * this["d"]
    );
  },
  /**
   * Calculates the fractional gcd of two rational numbers
   *
   * Ex: new Fraction(5,8).gcd(3,7) => 1/56
   */
  "gcd": function(a, b) {
    parse2(a, b);
    return newFraction(gcd(P2["n"], this["n"]) * gcd(P2["d"], this["d"]), P2["d"] * this["d"]);
  },
  /**
   * Calculates the fractional lcm of two rational numbers
   *
   * Ex: new Fraction(5,8).lcm(3,7) => 15
   */
  "lcm": function(a, b) {
    parse2(a, b);
    if (P2["n"] === C_ZERO && this["n"] === C_ZERO) {
      return newFraction(C_ZERO, C_ONE);
    }
    return newFraction(P2["n"] * this["n"], gcd(P2["n"], this["n"]) * gcd(P2["d"], this["d"]));
  },
  /**
   * Gets the inverse of the fraction, means numerator and denominator are exchanged
   *
   * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
   **/
  "inverse": function() {
    return newFraction(this["s"] * this["d"], this["n"]);
  },
  /**
   * Calculates the fraction to some integer exponent
   *
   * Ex: new Fraction(-1,2).pow(-3) => -8
   */
  "pow": function(a, b) {
    parse2(a, b);
    if (P2["d"] === C_ONE) {
      if (P2["s"] < C_ZERO) {
        return newFraction((this["s"] * this["d"]) ** P2["n"], this["n"] ** P2["n"]);
      } else {
        return newFraction((this["s"] * this["n"]) ** P2["n"], this["d"] ** P2["n"]);
      }
    }
    if (this["s"] < C_ZERO) return null;
    let N = factorize(this["n"]);
    let D = factorize(this["d"]);
    let n = C_ONE;
    let d = C_ONE;
    for (let k in N) {
      if (k === "1") continue;
      if (k === "0") {
        n = C_ZERO;
        break;
      }
      N[k] *= P2["n"];
      if (N[k] % P2["d"] === C_ZERO) {
        N[k] /= P2["d"];
      } else return null;
      n *= BigInt(k) ** N[k];
    }
    for (let k in D) {
      if (k === "1") continue;
      D[k] *= P2["n"];
      if (D[k] % P2["d"] === C_ZERO) {
        D[k] /= P2["d"];
      } else return null;
      d *= BigInt(k) ** D[k];
    }
    if (P2["s"] < C_ZERO) {
      return newFraction(d, n);
    }
    return newFraction(n, d);
  },
  /**
   * Calculates the logarithm of a fraction to a given rational base
   *
   * Ex: new Fraction(27, 8).log(9, 4) => 3/2
   */
  "log": function(a, b) {
    parse2(a, b);
    if (this["s"] <= C_ZERO || P2["s"] <= C_ZERO) return null;
    const allPrimes = {};
    const baseFactors = factorize(P2["n"]);
    const T1 = factorize(P2["d"]);
    const numberFactors = factorize(this["n"]);
    const T2 = factorize(this["d"]);
    for (const prime in T1) {
      baseFactors[prime] = (baseFactors[prime] || C_ZERO) - T1[prime];
    }
    for (const prime in T2) {
      numberFactors[prime] = (numberFactors[prime] || C_ZERO) - T2[prime];
    }
    for (const prime in baseFactors) {
      if (prime === "1") continue;
      allPrimes[prime] = true;
    }
    for (const prime in numberFactors) {
      if (prime === "1") continue;
      allPrimes[prime] = true;
    }
    let retN = null;
    let retD = null;
    for (const prime in allPrimes) {
      const baseExponent = baseFactors[prime] || C_ZERO;
      const numberExponent = numberFactors[prime] || C_ZERO;
      if (baseExponent === C_ZERO) {
        if (numberExponent !== C_ZERO) {
          return null;
        }
        continue;
      }
      let curN = numberExponent;
      let curD = baseExponent;
      const gcdValue = gcd(curN, curD);
      curN /= gcdValue;
      curD /= gcdValue;
      if (retN === null && retD === null) {
        retN = curN;
        retD = curD;
      } else if (curN * retD !== retN * curD) {
        return null;
      }
    }
    return retN !== null && retD !== null ? newFraction(retN, retD) : null;
  },
  /**
   * Check if two rational numbers are the same
   *
   * Ex: new Fraction(19.6).equals([98, 5]);
   **/
  "equals": function(a, b) {
    parse2(a, b);
    return this["s"] * this["n"] * P2["d"] === P2["s"] * P2["n"] * this["d"];
  },
  /**
   * Check if this rational number is less than another
   *
   * Ex: new Fraction(19.6).lt([98, 5]);
   **/
  "lt": function(a, b) {
    parse2(a, b);
    return this["s"] * this["n"] * P2["d"] < P2["s"] * P2["n"] * this["d"];
  },
  /**
   * Check if this rational number is less than or equal another
   *
   * Ex: new Fraction(19.6).lt([98, 5]);
   **/
  "lte": function(a, b) {
    parse2(a, b);
    return this["s"] * this["n"] * P2["d"] <= P2["s"] * P2["n"] * this["d"];
  },
  /**
   * Check if this rational number is greater than another
   *
   * Ex: new Fraction(19.6).lt([98, 5]);
   **/
  "gt": function(a, b) {
    parse2(a, b);
    return this["s"] * this["n"] * P2["d"] > P2["s"] * P2["n"] * this["d"];
  },
  /**
   * Check if this rational number is greater than or equal another
   *
   * Ex: new Fraction(19.6).lt([98, 5]);
   **/
  "gte": function(a, b) {
    parse2(a, b);
    return this["s"] * this["n"] * P2["d"] >= P2["s"] * P2["n"] * this["d"];
  },
  /**
   * Compare two rational numbers
   * < 0 iff this < that
   * > 0 iff this > that
   * = 0 iff this = that
   *
   * Ex: new Fraction(19.6).compare([98, 5]);
   **/
  "compare": function(a, b) {
    parse2(a, b);
    let t = this["s"] * this["n"] * P2["d"] - P2["s"] * P2["n"] * this["d"];
    return (C_ZERO < t) - (t < C_ZERO);
  },
  /**
   * Calculates the ceil of a rational number
   *
   * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
   **/
  "ceil": function(places) {
    places = C_TEN ** BigInt(places || 0);
    return newFraction(
      trunc(this["s"] * places * this["n"] / this["d"]) + (places * this["n"] % this["d"] > C_ZERO && this["s"] >= C_ZERO ? C_ONE : C_ZERO),
      places
    );
  },
  /**
   * Calculates the floor of a rational number
   *
   * Ex: new Fraction('4.(3)').floor() => (4 / 1)
   **/
  "floor": function(places) {
    places = C_TEN ** BigInt(places || 0);
    return newFraction(
      trunc(this["s"] * places * this["n"] / this["d"]) - (places * this["n"] % this["d"] > C_ZERO && this["s"] < C_ZERO ? C_ONE : C_ZERO),
      places
    );
  },
  /**
   * Rounds a rational numbers
   *
   * Ex: new Fraction('4.(3)').round() => (4 / 1)
   **/
  "round": function(places) {
    places = C_TEN ** BigInt(places || 0);
    return newFraction(
      trunc(this["s"] * places * this["n"] / this["d"]) + this["s"] * ((this["s"] >= C_ZERO ? C_ONE : C_ZERO) + C_TWO * (places * this["n"] % this["d"]) > this["d"] ? C_ONE : C_ZERO),
      places
    );
  },
  /**
    * Rounds a rational number to a multiple of another rational number
    *
    * Ex: new Fraction('0.9').roundTo("1/8") => 7 / 8
    **/
  "roundTo": function(a, b) {
    parse2(a, b);
    const n = this["n"] * P2["d"];
    const d = this["d"] * P2["n"];
    const r = n % d;
    let k = trunc(n / d);
    if (r + r >= d) {
      k++;
    }
    return newFraction(this["s"] * k * P2["n"], P2["d"]);
  },
  /**
   * Check if two rational numbers are divisible
   *
   * Ex: new Fraction(19.6).divisible(1.5);
   */
  "divisible": function(a, b) {
    parse2(a, b);
    return !(!(P2["n"] * this["d"]) || this["n"] * P2["d"] % (P2["n"] * this["d"]));
  },
  /**
   * Returns a decimal representation of the fraction
   *
   * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
   **/
  "valueOf": function() {
    return Number(this["s"] * this["n"]) / Number(this["d"]);
  },
  /**
   * Creates a string representation of a fraction with all digits
   *
   * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
   **/
  "toString": function(dec) {
    let N = this["n"];
    let D = this["d"];
    dec = dec || 15;
    let cycLen = cycleLen(N, D);
    let cycOff = cycleStart(N, D, cycLen);
    let str = this["s"] < C_ZERO ? "-" : "";
    str += trunc(N / D);
    N %= D;
    N *= C_TEN;
    if (N)
      str += ".";
    if (cycLen) {
      for (let i2 = cycOff; i2--; ) {
        str += trunc(N / D);
        N %= D;
        N *= C_TEN;
      }
      str += "(";
      for (let i2 = cycLen; i2--; ) {
        str += trunc(N / D);
        N %= D;
        N *= C_TEN;
      }
      str += ")";
    } else {
      for (let i2 = dec; N && i2--; ) {
        str += trunc(N / D);
        N %= D;
        N *= C_TEN;
      }
    }
    return str;
  },
  /**
   * Returns a string-fraction representation of a Fraction object
   *
   * Ex: new Fraction("1.'3'").toFraction() => "4 1/3"
   **/
  "toFraction": function(showMixed) {
    let n = this["n"];
    let d = this["d"];
    let str = this["s"] < C_ZERO ? "-" : "";
    if (d === C_ONE) {
      str += n;
    } else {
      let whole = trunc(n / d);
      if (showMixed && whole > C_ZERO) {
        str += whole;
        str += " ";
        n %= d;
      }
      str += n;
      str += "/";
      str += d;
    }
    return str;
  },
  /**
   * Returns a latex representation of a Fraction object
   *
   * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
   **/
  "toLatex": function(showMixed) {
    let n = this["n"];
    let d = this["d"];
    let str = this["s"] < C_ZERO ? "-" : "";
    if (d === C_ONE) {
      str += n;
    } else {
      let whole = trunc(n / d);
      if (showMixed && whole > C_ZERO) {
        str += whole;
        n %= d;
      }
      str += "\\frac{";
      str += n;
      str += "}{";
      str += d;
      str += "}";
    }
    return str;
  },
  /**
   * Returns an array of continued fraction elements
   *
   * Ex: new Fraction("7/8").toContinued() => [0,1,7]
   */
  "toContinued": function() {
    let a = this["n"];
    let b = this["d"];
    let res = [];
    do {
      res.push(trunc(a / b));
      let t = a % b;
      a = b;
      b = t;
    } while (a !== C_ONE);
    return res;
  },
  "simplify": function(eps) {
    const ieps = BigInt(1 / (eps || 1e-3) | 0);
    const thisABS = this["abs"]();
    const cont = thisABS["toContinued"]();
    for (let i2 = 1; i2 < cont.length; i2++) {
      let s = newFraction(cont[i2 - 1], C_ONE);
      for (let k = i2 - 2; k >= 0; k--) {
        s = s["inverse"]()["add"](cont[k]);
      }
      let t = s["sub"](thisABS);
      if (t["n"] * ieps < t["d"]) {
        return s["mul"](this["s"]);
      }
    }
    return this;
  }
};

// node_modules/mathjs/lib/esm/type/fraction/Fraction.js
var name3 = "Fraction";
var dependencies3 = [];
var createFractionClass = factory(name3, dependencies3, () => {
  Object.defineProperty(Fraction, "name", {
    value: "Fraction"
  });
  Fraction.prototype.constructor = Fraction;
  Fraction.prototype.type = "Fraction";
  Fraction.prototype.isFraction = true;
  Fraction.prototype.toJSON = function() {
    return {
      mathjs: "Fraction",
      n: String(this.s * this.n),
      d: String(this.d)
    };
  };
  Fraction.fromJSON = function(json) {
    return new Fraction(json);
  };
  return Fraction;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/matrix/Matrix.js
var name4 = "Matrix";
var dependencies4 = [];
var createMatrixClass = factory(name4, dependencies4, () => {
  function Matrix2() {
    if (!(this instanceof Matrix2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
  }
  Matrix2.prototype.type = "Matrix";
  Matrix2.prototype.isMatrix = true;
  Matrix2.prototype.storage = function() {
    throw new Error("Cannot invoke storage on a Matrix interface");
  };
  Matrix2.prototype.datatype = function() {
    throw new Error("Cannot invoke datatype on a Matrix interface");
  };
  Matrix2.prototype.create = function(data, datatype) {
    throw new Error("Cannot invoke create on a Matrix interface");
  };
  Matrix2.prototype.subset = function(index2, replacement, defaultValue) {
    throw new Error("Cannot invoke subset on a Matrix interface");
  };
  Matrix2.prototype.get = function(index2) {
    throw new Error("Cannot invoke get on a Matrix interface");
  };
  Matrix2.prototype.set = function(index2, value, defaultValue) {
    throw new Error("Cannot invoke set on a Matrix interface");
  };
  Matrix2.prototype.resize = function(size2, defaultValue) {
    throw new Error("Cannot invoke resize on a Matrix interface");
  };
  Matrix2.prototype.reshape = function(size2, defaultValue) {
    throw new Error("Cannot invoke reshape on a Matrix interface");
  };
  Matrix2.prototype.clone = function() {
    throw new Error("Cannot invoke clone on a Matrix interface");
  };
  Matrix2.prototype.size = function() {
    throw new Error("Cannot invoke size on a Matrix interface");
  };
  Matrix2.prototype.map = function(callback, skipZeros) {
    throw new Error("Cannot invoke map on a Matrix interface");
  };
  Matrix2.prototype.forEach = function(callback) {
    throw new Error("Cannot invoke forEach on a Matrix interface");
  };
  Matrix2.prototype[Symbol.iterator] = function() {
    throw new Error("Cannot iterate a Matrix interface");
  };
  Matrix2.prototype.toArray = function() {
    throw new Error("Cannot invoke toArray on a Matrix interface");
  };
  Matrix2.prototype.valueOf = function() {
    throw new Error("Cannot invoke valueOf on a Matrix interface");
  };
  Matrix2.prototype.format = function(options) {
    throw new Error("Cannot invoke format on a Matrix interface");
  };
  Matrix2.prototype.toString = function() {
    throw new Error("Cannot invoke toString on a Matrix interface");
  };
  return Matrix2;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/matrix/DenseMatrix.js
var name5 = "DenseMatrix";
var dependencies5 = ["Matrix"];
var createDenseMatrixClass = factory(name5, dependencies5, (_ref) => {
  var {
    Matrix: Matrix2
  } = _ref;
  function DenseMatrix2(data, datatype) {
    if (!(this instanceof DenseMatrix2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (datatype && !isString(datatype)) {
      throw new Error("Invalid datatype: " + datatype);
    }
    if (isMatrix(data)) {
      if (data.type === "DenseMatrix") {
        this._data = clone(data._data);
        this._size = clone(data._size);
        this._datatype = datatype || data._datatype;
      } else {
        this._data = data.toArray();
        this._size = data.size();
        this._datatype = datatype || data._datatype;
      }
    } else if (data && isArray(data.data) && isArray(data.size)) {
      this._data = data.data;
      this._size = data.size;
      validate(this._data, this._size);
      this._datatype = datatype || data.datatype;
    } else if (isArray(data)) {
      this._data = preprocess(data);
      this._size = arraySize(this._data);
      validate(this._data, this._size);
      this._datatype = datatype;
    } else if (data) {
      throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
    } else {
      this._data = [];
      this._size = [0];
      this._datatype = datatype;
    }
  }
  DenseMatrix2.prototype = new Matrix2();
  DenseMatrix2.prototype.createDenseMatrix = function(data, datatype) {
    return new DenseMatrix2(data, datatype);
  };
  Object.defineProperty(DenseMatrix2, "name", {
    value: "DenseMatrix"
  });
  DenseMatrix2.prototype.constructor = DenseMatrix2;
  DenseMatrix2.prototype.type = "DenseMatrix";
  DenseMatrix2.prototype.isDenseMatrix = true;
  DenseMatrix2.prototype.getDataType = function() {
    return getArrayDataType(this._data, typeOf);
  };
  DenseMatrix2.prototype.storage = function() {
    return "dense";
  };
  DenseMatrix2.prototype.datatype = function() {
    return this._datatype;
  };
  DenseMatrix2.prototype.create = function(data, datatype) {
    return new DenseMatrix2(data, datatype);
  };
  DenseMatrix2.prototype.subset = function(index2, replacement, defaultValue) {
    switch (arguments.length) {
      case 1:
        return _get(this, index2);
      // intentional fall through
      case 2:
      case 3:
        return _set(this, index2, replacement, defaultValue);
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  };
  DenseMatrix2.prototype.get = function(index2) {
    return get(this._data, index2);
  };
  DenseMatrix2.prototype.set = function(index2, value, defaultValue) {
    if (!isArray(index2)) {
      throw new TypeError("Array expected");
    }
    if (index2.length < this._size.length) {
      throw new DimensionError(index2.length, this._size.length, "<");
    }
    var i2, ii, indexI;
    var size2 = index2.map(function(i3) {
      return i3 + 1;
    });
    _fit(this, size2, defaultValue);
    var data = this._data;
    for (i2 = 0, ii = index2.length - 1; i2 < ii; i2++) {
      indexI = index2[i2];
      validateIndex(indexI, data.length);
      data = data[indexI];
    }
    indexI = index2[index2.length - 1];
    validateIndex(indexI, data.length);
    data[indexI] = value;
    return this;
  };
  function _get(matrix2, index2) {
    if (!isIndex(index2)) {
      throw new TypeError("Invalid index");
    }
    var isScalar = index2.isScalar();
    if (isScalar) {
      return matrix2.get(index2.min());
    } else {
      var size2 = index2.size();
      if (size2.length !== matrix2._size.length) {
        throw new DimensionError(size2.length, matrix2._size.length);
      }
      var min2 = index2.min();
      var max2 = index2.max();
      for (var i2 = 0, ii = matrix2._size.length; i2 < ii; i2++) {
        validateIndex(min2[i2], matrix2._size[i2]);
        validateIndex(max2[i2], matrix2._size[i2]);
      }
      return new DenseMatrix2(_getSubmatrix(matrix2._data, index2, size2.length, 0), matrix2._datatype);
    }
  }
  function _getSubmatrix(data, index2, dims, dim) {
    var last = dim === dims - 1;
    var range2 = index2.dimension(dim);
    if (last) {
      return range2.map(function(i2) {
        validateIndex(i2, data.length);
        return data[i2];
      }).valueOf();
    } else {
      return range2.map(function(i2) {
        validateIndex(i2, data.length);
        var child = data[i2];
        return _getSubmatrix(child, index2, dims, dim + 1);
      }).valueOf();
    }
  }
  function _set(matrix2, index2, submatrix, defaultValue) {
    if (!index2 || index2.isIndex !== true) {
      throw new TypeError("Invalid index");
    }
    var iSize = index2.size();
    var isScalar = index2.isScalar();
    var sSize;
    if (isMatrix(submatrix)) {
      sSize = submatrix.size();
      submatrix = submatrix.valueOf();
    } else {
      sSize = arraySize(submatrix);
    }
    if (isScalar) {
      if (sSize.length !== 0) {
        throw new TypeError("Scalar expected");
      }
      matrix2.set(index2.min(), submatrix, defaultValue);
    } else {
      if (!deepStrictEqual(sSize, iSize)) {
        try {
          if (sSize.length === 0) {
            submatrix = broadcastTo([submatrix], iSize);
          } else {
            submatrix = broadcastTo(submatrix, iSize);
          }
          sSize = arraySize(submatrix);
        } catch (_unused) {
        }
      }
      if (iSize.length < matrix2._size.length) {
        throw new DimensionError(iSize.length, matrix2._size.length, "<");
      }
      if (sSize.length < iSize.length) {
        var i2 = 0;
        var outer = 0;
        while (iSize[i2] === 1 && sSize[i2] === 1) {
          i2++;
        }
        while (iSize[i2] === 1) {
          outer++;
          i2++;
        }
        submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
      }
      if (!deepStrictEqual(iSize, sSize)) {
        throw new DimensionError(iSize, sSize, ">");
      }
      var size2 = index2.max().map(function(i3) {
        return i3 + 1;
      });
      _fit(matrix2, size2, defaultValue);
      var dims = iSize.length;
      var dim = 0;
      _setSubmatrix(matrix2._data, index2, submatrix, dims, dim);
    }
    return matrix2;
  }
  function _setSubmatrix(data, index2, submatrix, dims, dim) {
    var last = dim === dims - 1;
    var range2 = index2.dimension(dim);
    if (last) {
      range2.forEach(function(dataIndex, subIndex) {
        validateIndex(dataIndex);
        data[dataIndex] = submatrix[subIndex[0]];
      });
    } else {
      range2.forEach(function(dataIndex, subIndex) {
        validateIndex(dataIndex);
        _setSubmatrix(data[dataIndex], index2, submatrix[subIndex[0]], dims, dim + 1);
      });
    }
  }
  DenseMatrix2.prototype.resize = function(size2, defaultValue, copy) {
    if (!isCollection(size2)) {
      throw new TypeError("Array or Matrix expected");
    }
    var sizeArray = size2.valueOf().map((value) => {
      return Array.isArray(value) && value.length === 1 ? value[0] : value;
    });
    var m = copy ? this.clone() : this;
    return _resize(m, sizeArray, defaultValue);
  };
  function _resize(matrix2, size2, defaultValue) {
    if (size2.length === 0) {
      var v = matrix2._data;
      while (isArray(v)) {
        v = v[0];
      }
      return v;
    }
    matrix2._size = size2.slice(0);
    matrix2._data = resize(matrix2._data, matrix2._size, defaultValue);
    return matrix2;
  }
  DenseMatrix2.prototype.reshape = function(size2, copy) {
    var m = copy ? this.clone() : this;
    m._data = reshape(m._data, size2);
    var currentLength = m._size.reduce((length, size3) => length * size3);
    m._size = processSizesWildcard(size2, currentLength);
    return m;
  };
  function _fit(matrix2, size2, defaultValue) {
    var newSize = matrix2._size.slice(0);
    var changed = false;
    while (newSize.length < size2.length) {
      newSize.push(0);
      changed = true;
    }
    for (var i2 = 0, ii = size2.length; i2 < ii; i2++) {
      if (size2[i2] > newSize[i2]) {
        newSize[i2] = size2[i2];
        changed = true;
      }
    }
    if (changed) {
      _resize(matrix2, newSize, defaultValue);
    }
  }
  DenseMatrix2.prototype.clone = function() {
    var m = new DenseMatrix2({
      data: clone(this._data),
      size: clone(this._size),
      datatype: this._datatype
    });
    return m;
  };
  DenseMatrix2.prototype.size = function() {
    return this._size.slice(0);
  };
  DenseMatrix2.prototype._forEach = function(callback) {
    var isUnary = callback.length === 2;
    var maxDepth = this._size.length - 1;
    if (maxDepth < 0) return;
    if (isUnary) {
      iterateUnary(this._data);
      return;
    }
    if (maxDepth === 0) {
      for (var i2 = 0; i2 < this._data.length; i2++) {
        callback(this._data, i2, [i2]);
      }
      return;
    }
    var index2 = new Array(maxDepth + 1);
    iterate(this._data);
    function iterate(data) {
      var depth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      if (depth < maxDepth) {
        for (var _i = 0; _i < data.length; _i++) {
          index2[depth] = _i;
          iterate(data[_i], depth + 1);
        }
      } else {
        for (var _i2 = 0; _i2 < data.length; _i2++) {
          index2[depth] = _i2;
          callback(data, _i2, index2.slice());
        }
      }
    }
    function iterateUnary(data) {
      var depth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      if (depth < maxDepth) {
        for (var _i3 = 0; _i3 < data.length; _i3++) {
          iterateUnary(data[_i3], depth + 1);
        }
      } else {
        for (var _i4 = 0; _i4 < data.length; _i4++) {
          callback(data, _i4);
        }
      }
    }
  };
  DenseMatrix2.prototype.map = function(callback) {
    var skipZeros = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var isUnary = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var me = this;
    var result = new DenseMatrix2(me);
    var fastCallback = optimizeCallback(callback, me._data, "map", isUnary);
    var applyCallback = isUnary || fastCallback.isUnary ? (arr, i2) => {
      arr[i2] = fastCallback.fn(arr[i2]);
    } : (arr, i2, index2) => {
      arr[i2] = fastCallback.fn(arr[i2], index2, me);
    };
    result._forEach(applyCallback);
    return result;
  };
  DenseMatrix2.prototype.forEach = function(callback) {
    var skipZeros = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var isUnary = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var me = this;
    var fastCallback = optimizeCallback(callback, me._data, "map", isUnary);
    var applyCallback = isUnary || fastCallback.isUnary ? (arr, i2) => {
      fastCallback.fn(arr[i2]);
    } : (arr, i2, index2) => {
      fastCallback.fn(arr[i2], index2, me);
    };
    me._forEach(applyCallback);
  };
  DenseMatrix2.prototype[Symbol.iterator] = function* () {
    var maxDepth = this._size.length - 1;
    if (maxDepth < 0) {
      return;
    }
    if (maxDepth === 0) {
      for (var i2 = 0; i2 < this._data.length; i2++) {
        yield {
          value: this._data[i2],
          index: [i2]
        };
      }
      return;
    }
    var index2 = [];
    var _recurse = function* recurse(value, depth) {
      if (depth < maxDepth) {
        for (var _i5 = 0; _i5 < value.length; _i5++) {
          index2[depth] = _i5;
          yield* _recurse(value[_i5], depth + 1);
        }
      } else {
        for (var _i6 = 0; _i6 < value.length; _i6++) {
          index2[depth] = _i6;
          yield {
            value: value[_i6],
            index: index2.slice()
          };
        }
      }
    };
    yield* _recurse(this._data, 0);
  };
  DenseMatrix2.prototype.rows = function() {
    var result = [];
    var s = this.size();
    if (s.length !== 2) {
      throw new TypeError("Rows can only be returned for a 2D matrix.");
    }
    var data = this._data;
    for (var row2 of data) {
      result.push(new DenseMatrix2([row2], this._datatype));
    }
    return result;
  };
  DenseMatrix2.prototype.columns = function() {
    var _this = this;
    var result = [];
    var s = this.size();
    if (s.length !== 2) {
      throw new TypeError("Rows can only be returned for a 2D matrix.");
    }
    var data = this._data;
    var _loop = function _loop2(i3) {
      var col = data.map((row2) => [row2[i3]]);
      result.push(new DenseMatrix2(col, _this._datatype));
    };
    for (var i2 = 0; i2 < s[1]; i2++) {
      _loop(i2);
    }
    return result;
  };
  DenseMatrix2.prototype.toArray = function() {
    return clone(this._data);
  };
  DenseMatrix2.prototype.valueOf = function() {
    return this._data;
  };
  DenseMatrix2.prototype.format = function(options) {
    return format2(this._data, options);
  };
  DenseMatrix2.prototype.toString = function() {
    return format2(this._data);
  };
  DenseMatrix2.prototype.toJSON = function() {
    return {
      mathjs: "DenseMatrix",
      data: this._data,
      size: this._size,
      datatype: this._datatype
    };
  };
  DenseMatrix2.prototype.diagonal = function(k) {
    if (k) {
      if (isBigNumber(k)) {
        k = k.toNumber();
      }
      if (!isNumber(k) || !isInteger(k)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k = 0;
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    var rows = this._size[0];
    var columns = this._size[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var data = [];
    for (var i2 = 0; i2 < n; i2++) {
      data[i2] = this._data[i2 + kSub][i2 + kSuper];
    }
    return new DenseMatrix2({
      data,
      size: [n],
      datatype: this._datatype
    });
  };
  DenseMatrix2.diagonal = function(size2, value, k, defaultValue) {
    if (!isArray(size2)) {
      throw new TypeError("Array expected, size parameter");
    }
    if (size2.length !== 2) {
      throw new Error("Only two dimensions matrix are supported");
    }
    size2 = size2.map(function(s) {
      if (isBigNumber(s)) {
        s = s.toNumber();
      }
      if (!isNumber(s) || !isInteger(s) || s < 1) {
        throw new Error("Size values must be positive integers");
      }
      return s;
    });
    if (k) {
      if (isBigNumber(k)) {
        k = k.toNumber();
      }
      if (!isNumber(k) || !isInteger(k)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k = 0;
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    var rows = size2[0];
    var columns = size2[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var _value;
    if (isArray(value)) {
      if (value.length !== n) {
        throw new Error("Invalid value array length");
      }
      _value = function _value2(i2) {
        return value[i2];
      };
    } else if (isMatrix(value)) {
      var ms = value.size();
      if (ms.length !== 1 || ms[0] !== n) {
        throw new Error("Invalid matrix length");
      }
      _value = function _value2(i2) {
        return value.get([i2]);
      };
    } else {
      _value = function _value2() {
        return value;
      };
    }
    if (!defaultValue) {
      defaultValue = isBigNumber(_value(0)) ? _value(0).mul(0) : 0;
    }
    var data = [];
    if (size2.length > 0) {
      data = resize(data, size2, defaultValue);
      for (var d = 0; d < n; d++) {
        data[d + kSub][d + kSuper] = _value(d);
      }
    }
    return new DenseMatrix2({
      data,
      size: [rows, columns]
    });
  };
  DenseMatrix2.fromJSON = function(json) {
    return new DenseMatrix2(json);
  };
  DenseMatrix2.prototype.swapRows = function(i2, j) {
    if (!isNumber(i2) || !isInteger(i2) || !isNumber(j) || !isInteger(j)) {
      throw new Error("Row index must be positive integers");
    }
    if (this._size.length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(i2, this._size[0]);
    validateIndex(j, this._size[0]);
    DenseMatrix2._swapRows(i2, j, this._data);
    return this;
  };
  DenseMatrix2._swapRows = function(i2, j, data) {
    var vi = data[i2];
    data[i2] = data[j];
    data[j] = vi;
  };
  function preprocess(data) {
    if (isMatrix(data)) {
      return preprocess(data.valueOf());
    }
    if (isArray(data)) {
      return data.map(preprocess);
    }
    return data;
  }
  return DenseMatrix2;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/function/utils/isInteger.js
var name6 = "isInteger";
var dependencies6 = ["typed"];
var createIsInteger = factory(name6, dependencies6, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name6, {
    number: isInteger,
    // TODO: what to do with isInteger(add(0.1, 0.2))  ?
    BigNumber: function BigNumber2(x) {
      return x.isInt();
    },
    bigint: function bigint2(x) {
      return true;
    },
    Fraction: function Fraction3(x) {
      return x.d === 1n;
    },
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self))
  });
});

// node_modules/mathjs/lib/esm/function/utils/isNegative.js
var name7 = "isNegative";
var dependencies7 = ["typed", "config"];
var createIsNegative = factory(name7, dependencies7, (_ref) => {
  var {
    typed: typed2,
    config: config2
  } = _ref;
  return typed2(name7, {
    number: (x) => nearlyEqual(x, 0, config2.relTol, config2.absTol) ? false : isNegativeNumber(x),
    BigNumber: (x) => nearlyEqual2(x, new x.constructor(0), config2.relTol, config2.absTol) ? false : x.isNeg() && !x.isZero() && !x.isNaN(),
    bigint: (x) => x < 0n,
    Fraction: (x) => x.s < 0n,
    // It's enough to decide on the sign
    Unit: typed2.referToSelf((self) => (x) => typed2.find(self, x.valueType())(x.value)),
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self))
  });
});

// node_modules/mathjs/lib/esm/function/utils/isPositive.js
var name8 = "isPositive";
var dependencies8 = ["typed", "config"];
var createIsPositive = factory(name8, dependencies8, (_ref) => {
  var {
    typed: typed2,
    config: config2
  } = _ref;
  return typed2(name8, {
    number: (x) => nearlyEqual(x, 0, config2.relTol, config2.absTol) ? false : isPositiveNumber(x),
    BigNumber: (x) => nearlyEqual2(x, new x.constructor(0), config2.relTol, config2.absTol) ? false : !x.isNeg() && !x.isZero() && !x.isNaN(),
    bigint: (x) => x > 0n,
    Fraction: (x) => x.s > 0n && x.n > 0n,
    Unit: typed2.referToSelf((self) => (x) => typed2.find(self, x.valueType())(x.value)),
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self))
  });
});

// node_modules/mathjs/lib/esm/function/utils/isZero.js
var name9 = "isZero";
var dependencies9 = ["typed", "equalScalar"];
var createIsZero = factory(name9, dependencies9, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2
  } = _ref;
  return typed2(name9, {
    "number | BigNumber | Complex | Fraction": (x) => equalScalar2(x, 0),
    bigint: (x) => x === 0n,
    Unit: typed2.referToSelf((self) => (x) => typed2.find(self, x.valueType())(x.value)),
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self))
  });
});

// node_modules/mathjs/lib/esm/function/utils/isNaN.js
var name10 = "isNaN";
var dependencies10 = ["typed"];
var createIsNaN = factory(name10, dependencies10, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name10, {
    number: isNaNNumber,
    BigNumber: function BigNumber2(x) {
      return x.isNaN();
    },
    bigint: function bigint2(x) {
      return false;
    },
    Fraction: function Fraction3(x) {
      return false;
    },
    Complex: function Complex3(x) {
      return x.isNaN();
    },
    Unit: function Unit2(x) {
      return Number.isNaN(x.value);
    },
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self))
  });
});

// node_modules/mathjs/lib/esm/type/matrix/SparseMatrix.js
var name11 = "SparseMatrix";
var dependencies11 = ["typed", "equalScalar", "Matrix"];
var createSparseMatrixClass = factory(name11, dependencies11, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2,
    Matrix: Matrix2
  } = _ref;
  function SparseMatrix2(data, datatype) {
    if (!(this instanceof SparseMatrix2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (datatype && !isString(datatype)) {
      throw new Error("Invalid datatype: " + datatype);
    }
    if (isMatrix(data)) {
      _createFromMatrix(this, data, datatype);
    } else if (data && isArray(data.index) && isArray(data.ptr) && isArray(data.size)) {
      this._values = data.values;
      this._index = data.index;
      this._ptr = data.ptr;
      this._size = data.size;
      this._datatype = datatype || data.datatype;
    } else if (isArray(data)) {
      _createFromArray(this, data, datatype);
    } else if (data) {
      throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
    } else {
      this._values = [];
      this._index = [];
      this._ptr = [0];
      this._size = [0, 0];
      this._datatype = datatype;
    }
  }
  function _createFromMatrix(matrix2, source, datatype) {
    if (source.type === "SparseMatrix") {
      matrix2._values = source._values ? clone(source._values) : void 0;
      matrix2._index = clone(source._index);
      matrix2._ptr = clone(source._ptr);
      matrix2._size = clone(source._size);
      matrix2._datatype = datatype || source._datatype;
    } else {
      _createFromArray(matrix2, source.valueOf(), datatype || source._datatype);
    }
  }
  function _createFromArray(matrix2, data, datatype) {
    matrix2._values = [];
    matrix2._index = [];
    matrix2._ptr = [];
    matrix2._datatype = datatype;
    var rows = data.length;
    var columns = 0;
    var eq = equalScalar2;
    var zero = 0;
    if (isString(datatype)) {
      eq = typed2.find(equalScalar2, [datatype, datatype]) || equalScalar2;
      zero = typed2.convert(0, datatype);
    }
    if (rows > 0) {
      var j = 0;
      do {
        matrix2._ptr.push(matrix2._index.length);
        for (var i2 = 0; i2 < rows; i2++) {
          var row2 = data[i2];
          if (isArray(row2)) {
            if (j === 0 && columns < row2.length) {
              columns = row2.length;
            }
            if (j < row2.length) {
              var v = row2[j];
              if (!eq(v, zero)) {
                matrix2._values.push(v);
                matrix2._index.push(i2);
              }
            }
          } else {
            if (j === 0 && columns < 1) {
              columns = 1;
            }
            if (!eq(row2, zero)) {
              matrix2._values.push(row2);
              matrix2._index.push(i2);
            }
          }
        }
        j++;
      } while (j < columns);
    }
    matrix2._ptr.push(matrix2._index.length);
    matrix2._size = [rows, columns];
  }
  SparseMatrix2.prototype = new Matrix2();
  SparseMatrix2.prototype.createSparseMatrix = function(data, datatype) {
    return new SparseMatrix2(data, datatype);
  };
  Object.defineProperty(SparseMatrix2, "name", {
    value: "SparseMatrix"
  });
  SparseMatrix2.prototype.constructor = SparseMatrix2;
  SparseMatrix2.prototype.type = "SparseMatrix";
  SparseMatrix2.prototype.isSparseMatrix = true;
  SparseMatrix2.prototype.getDataType = function() {
    return getArrayDataType(this._values, typeOf);
  };
  SparseMatrix2.prototype.storage = function() {
    return "sparse";
  };
  SparseMatrix2.prototype.datatype = function() {
    return this._datatype;
  };
  SparseMatrix2.prototype.create = function(data, datatype) {
    return new SparseMatrix2(data, datatype);
  };
  SparseMatrix2.prototype.density = function() {
    var rows = this._size[0];
    var columns = this._size[1];
    return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;
  };
  SparseMatrix2.prototype.subset = function(index2, replacement, defaultValue) {
    if (!this._values) {
      throw new Error("Cannot invoke subset on a Pattern only matrix");
    }
    switch (arguments.length) {
      case 1:
        return _getsubset(this, index2);
      // intentional fall through
      case 2:
      case 3:
        return _setsubset(this, index2, replacement, defaultValue);
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  };
  function _getsubset(matrix2, idx) {
    if (!isIndex(idx)) {
      throw new TypeError("Invalid index");
    }
    var isScalar = idx.isScalar();
    if (isScalar) {
      return matrix2.get(idx.min());
    }
    var size2 = idx.size();
    if (size2.length !== matrix2._size.length) {
      throw new DimensionError(size2.length, matrix2._size.length);
    }
    var i2, ii, k, kk;
    var min2 = idx.min();
    var max2 = idx.max();
    for (i2 = 0, ii = matrix2._size.length; i2 < ii; i2++) {
      validateIndex(min2[i2], matrix2._size[i2]);
      validateIndex(max2[i2], matrix2._size[i2]);
    }
    var mvalues = matrix2._values;
    var mindex = matrix2._index;
    var mptr = matrix2._ptr;
    var rows = idx.dimension(0);
    var columns = idx.dimension(1);
    var w = [];
    var pv = [];
    rows.forEach(function(i3, r) {
      pv[i3] = r[0];
      w[i3] = true;
    });
    var values = mvalues ? [] : void 0;
    var index2 = [];
    var ptr = [];
    columns.forEach(function(j) {
      ptr.push(index2.length);
      for (k = mptr[j], kk = mptr[j + 1]; k < kk; k++) {
        i2 = mindex[k];
        if (w[i2] === true) {
          index2.push(pv[i2]);
          if (values) {
            values.push(mvalues[k]);
          }
        }
      }
    });
    ptr.push(index2.length);
    return new SparseMatrix2({
      values,
      index: index2,
      ptr,
      size: size2,
      datatype: matrix2._datatype
    });
  }
  function _setsubset(matrix2, index2, submatrix, defaultValue) {
    if (!index2 || index2.isIndex !== true) {
      throw new TypeError("Invalid index");
    }
    var iSize = index2.size();
    var isScalar = index2.isScalar();
    var sSize;
    if (isMatrix(submatrix)) {
      sSize = submatrix.size();
      submatrix = submatrix.toArray();
    } else {
      sSize = arraySize(submatrix);
    }
    if (isScalar) {
      if (sSize.length !== 0) {
        throw new TypeError("Scalar expected");
      }
      matrix2.set(index2.min(), submatrix, defaultValue);
    } else {
      if (iSize.length !== 1 && iSize.length !== 2) {
        throw new DimensionError(iSize.length, matrix2._size.length, "<");
      }
      if (sSize.length < iSize.length) {
        var i2 = 0;
        var outer = 0;
        while (iSize[i2] === 1 && sSize[i2] === 1) {
          i2++;
        }
        while (iSize[i2] === 1) {
          outer++;
          i2++;
        }
        submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
      }
      if (!deepStrictEqual(iSize, sSize)) {
        throw new DimensionError(iSize, sSize, ">");
      }
      if (iSize.length === 1) {
        var range2 = index2.dimension(0);
        range2.forEach(function(dataIndex, subIndex) {
          validateIndex(dataIndex);
          matrix2.set([dataIndex, 0], submatrix[subIndex[0]], defaultValue);
        });
      } else {
        var firstDimensionRange = index2.dimension(0);
        var secondDimensionRange = index2.dimension(1);
        firstDimensionRange.forEach(function(firstDataIndex, firstSubIndex) {
          validateIndex(firstDataIndex);
          secondDimensionRange.forEach(function(secondDataIndex, secondSubIndex) {
            validateIndex(secondDataIndex);
            matrix2.set([firstDataIndex, secondDataIndex], submatrix[firstSubIndex[0]][secondSubIndex[0]], defaultValue);
          });
        });
      }
    }
    return matrix2;
  }
  SparseMatrix2.prototype.get = function(index2) {
    if (!isArray(index2)) {
      throw new TypeError("Array expected");
    }
    if (index2.length !== this._size.length) {
      throw new DimensionError(index2.length, this._size.length);
    }
    if (!this._values) {
      throw new Error("Cannot invoke get on a Pattern only matrix");
    }
    var i2 = index2[0];
    var j = index2[1];
    validateIndex(i2, this._size[0]);
    validateIndex(j, this._size[1]);
    var k = _getValueIndex(i2, this._ptr[j], this._ptr[j + 1], this._index);
    if (k < this._ptr[j + 1] && this._index[k] === i2) {
      return this._values[k];
    }
    return 0;
  };
  SparseMatrix2.prototype.set = function(index2, v, defaultValue) {
    if (!isArray(index2)) {
      throw new TypeError("Array expected");
    }
    if (index2.length !== this._size.length) {
      throw new DimensionError(index2.length, this._size.length);
    }
    if (!this._values) {
      throw new Error("Cannot invoke set on a Pattern only matrix");
    }
    var i2 = index2[0];
    var j = index2[1];
    var rows = this._size[0];
    var columns = this._size[1];
    var eq = equalScalar2;
    var zero = 0;
    if (isString(this._datatype)) {
      eq = typed2.find(equalScalar2, [this._datatype, this._datatype]) || equalScalar2;
      zero = typed2.convert(0, this._datatype);
    }
    if (i2 > rows - 1 || j > columns - 1) {
      _resize(this, Math.max(i2 + 1, rows), Math.max(j + 1, columns), defaultValue);
      rows = this._size[0];
      columns = this._size[1];
    }
    validateIndex(i2, rows);
    validateIndex(j, columns);
    var k = _getValueIndex(i2, this._ptr[j], this._ptr[j + 1], this._index);
    if (k < this._ptr[j + 1] && this._index[k] === i2) {
      if (!eq(v, zero)) {
        this._values[k] = v;
      } else {
        _remove(k, j, this._values, this._index, this._ptr);
      }
    } else {
      if (!eq(v, zero)) {
        _insert(k, i2, j, v, this._values, this._index, this._ptr);
      }
    }
    return this;
  };
  function _getValueIndex(i2, top, bottom, index2) {
    if (bottom - top === 0) {
      return bottom;
    }
    for (var r = top; r < bottom; r++) {
      if (index2[r] === i2) {
        return r;
      }
    }
    return top;
  }
  function _remove(k, j, values, index2, ptr) {
    values.splice(k, 1);
    index2.splice(k, 1);
    for (var x = j + 1; x < ptr.length; x++) {
      ptr[x]--;
    }
  }
  function _insert(k, i2, j, v, values, index2, ptr) {
    values.splice(k, 0, v);
    index2.splice(k, 0, i2);
    for (var x = j + 1; x < ptr.length; x++) {
      ptr[x]++;
    }
  }
  SparseMatrix2.prototype.resize = function(size2, defaultValue, copy) {
    if (!isCollection(size2)) {
      throw new TypeError("Array or Matrix expected");
    }
    var sizeArray = size2.valueOf().map((value) => {
      return Array.isArray(value) && value.length === 1 ? value[0] : value;
    });
    if (sizeArray.length !== 2) {
      throw new Error("Only two dimensions matrix are supported");
    }
    sizeArray.forEach(function(value) {
      if (!isNumber(value) || !isInteger(value) || value < 0) {
        throw new TypeError("Invalid size, must contain positive integers (size: " + format2(sizeArray) + ")");
      }
    });
    var m = copy ? this.clone() : this;
    return _resize(m, sizeArray[0], sizeArray[1], defaultValue);
  };
  function _resize(matrix2, rows, columns, defaultValue) {
    var value = defaultValue || 0;
    var eq = equalScalar2;
    var zero = 0;
    if (isString(matrix2._datatype)) {
      eq = typed2.find(equalScalar2, [matrix2._datatype, matrix2._datatype]) || equalScalar2;
      zero = typed2.convert(0, matrix2._datatype);
      value = typed2.convert(value, matrix2._datatype);
    }
    var ins = !eq(value, zero);
    var r = matrix2._size[0];
    var c = matrix2._size[1];
    var i2, j, k;
    if (columns > c) {
      for (j = c; j < columns; j++) {
        matrix2._ptr[j] = matrix2._values.length;
        if (ins) {
          for (i2 = 0; i2 < r; i2++) {
            matrix2._values.push(value);
            matrix2._index.push(i2);
          }
        }
      }
      matrix2._ptr[columns] = matrix2._values.length;
    } else if (columns < c) {
      matrix2._ptr.splice(columns + 1, c - columns);
      matrix2._values.splice(matrix2._ptr[columns], matrix2._values.length);
      matrix2._index.splice(matrix2._ptr[columns], matrix2._index.length);
    }
    c = columns;
    if (rows > r) {
      if (ins) {
        var n = 0;
        for (j = 0; j < c; j++) {
          matrix2._ptr[j] = matrix2._ptr[j] + n;
          k = matrix2._ptr[j + 1] + n;
          var p = 0;
          for (i2 = r; i2 < rows; i2++, p++) {
            matrix2._values.splice(k + p, 0, value);
            matrix2._index.splice(k + p, 0, i2);
            n++;
          }
        }
        matrix2._ptr[c] = matrix2._values.length;
      }
    } else if (rows < r) {
      var d = 0;
      for (j = 0; j < c; j++) {
        matrix2._ptr[j] = matrix2._ptr[j] - d;
        var k0 = matrix2._ptr[j];
        var k1 = matrix2._ptr[j + 1] - d;
        for (k = k0; k < k1; k++) {
          i2 = matrix2._index[k];
          if (i2 > rows - 1) {
            matrix2._values.splice(k, 1);
            matrix2._index.splice(k, 1);
            d++;
          }
        }
      }
      matrix2._ptr[j] = matrix2._values.length;
    }
    matrix2._size[0] = rows;
    matrix2._size[1] = columns;
    return matrix2;
  }
  SparseMatrix2.prototype.reshape = function(sizes, copy) {
    if (!isArray(sizes)) {
      throw new TypeError("Array expected");
    }
    if (sizes.length !== 2) {
      throw new Error("Sparse matrices can only be reshaped in two dimensions");
    }
    sizes.forEach(function(value) {
      if (!isNumber(value) || !isInteger(value) || value <= -2 || value === 0) {
        throw new TypeError("Invalid size, must contain positive integers or -1 (size: " + format2(sizes) + ")");
      }
    });
    var currentLength = this._size[0] * this._size[1];
    sizes = processSizesWildcard(sizes, currentLength);
    var newLength = sizes[0] * sizes[1];
    if (currentLength !== newLength) {
      throw new Error("Reshaping sparse matrix will result in the wrong number of elements");
    }
    var m = copy ? this.clone() : this;
    if (this._size[0] === sizes[0] && this._size[1] === sizes[1]) {
      return m;
    }
    var colIndex = [];
    for (var i2 = 0; i2 < m._ptr.length; i2++) {
      for (var j = 0; j < m._ptr[i2 + 1] - m._ptr[i2]; j++) {
        colIndex.push(i2);
      }
    }
    var values = m._values.slice();
    var rowIndex = m._index.slice();
    for (var _i = 0; _i < m._index.length; _i++) {
      var r1 = rowIndex[_i];
      var c1 = colIndex[_i];
      var flat = r1 * m._size[1] + c1;
      colIndex[_i] = flat % sizes[1];
      rowIndex[_i] = Math.floor(flat / sizes[1]);
    }
    m._values.length = 0;
    m._index.length = 0;
    m._ptr.length = sizes[1] + 1;
    m._size = sizes.slice();
    for (var _i2 = 0; _i2 < m._ptr.length; _i2++) {
      m._ptr[_i2] = 0;
    }
    for (var h = 0; h < values.length; h++) {
      var _i3 = rowIndex[h];
      var _j = colIndex[h];
      var v = values[h];
      var k = _getValueIndex(_i3, m._ptr[_j], m._ptr[_j + 1], m._index);
      _insert(k, _i3, _j, v, m._values, m._index, m._ptr);
    }
    return m;
  };
  SparseMatrix2.prototype.clone = function() {
    var m = new SparseMatrix2({
      values: this._values ? clone(this._values) : void 0,
      index: clone(this._index),
      ptr: clone(this._ptr),
      size: clone(this._size),
      datatype: this._datatype
    });
    return m;
  };
  SparseMatrix2.prototype.size = function() {
    return this._size.slice(0);
  };
  SparseMatrix2.prototype.map = function(callback, skipZeros) {
    if (!this._values) {
      throw new Error("Cannot invoke map on a Pattern only matrix");
    }
    var me = this;
    var rows = this._size[0];
    var columns = this._size[1];
    var fastCallback = optimizeCallback(callback, me, "map");
    var invoke = function invoke2(v, i2, j) {
      return fastCallback.fn(v, [i2, j], me);
    };
    return _map(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);
  };
  function _map(matrix2, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {
    var values = [];
    var index2 = [];
    var ptr = [];
    var eq = equalScalar2;
    var zero = 0;
    if (isString(matrix2._datatype)) {
      eq = typed2.find(equalScalar2, [matrix2._datatype, matrix2._datatype]) || equalScalar2;
      zero = typed2.convert(0, matrix2._datatype);
    }
    var invoke = function invoke2(v, x, y) {
      var value2 = callback(v, x, y);
      if (!eq(value2, zero)) {
        values.push(value2);
        index2.push(x);
      }
    };
    for (var j = minColumn; j <= maxColumn; j++) {
      ptr.push(values.length);
      var k0 = matrix2._ptr[j];
      var k1 = matrix2._ptr[j + 1];
      if (skipZeros) {
        for (var k = k0; k < k1; k++) {
          var i2 = matrix2._index[k];
          if (i2 >= minRow && i2 <= maxRow) {
            invoke(matrix2._values[k], i2 - minRow, j - minColumn);
          }
        }
      } else {
        var _values = {};
        for (var _k = k0; _k < k1; _k++) {
          var _i4 = matrix2._index[_k];
          _values[_i4] = matrix2._values[_k];
        }
        for (var _i5 = minRow; _i5 <= maxRow; _i5++) {
          var value = _i5 in _values ? _values[_i5] : 0;
          invoke(value, _i5 - minRow, j - minColumn);
        }
      }
    }
    ptr.push(values.length);
    return new SparseMatrix2({
      values,
      index: index2,
      ptr,
      size: [maxRow - minRow + 1, maxColumn - minColumn + 1]
    });
  }
  SparseMatrix2.prototype.forEach = function(callback, skipZeros) {
    if (!this._values) {
      throw new Error("Cannot invoke forEach on a Pattern only matrix");
    }
    var me = this;
    var rows = this._size[0];
    var columns = this._size[1];
    var fastCallback = optimizeCallback(callback, me, "forEach");
    for (var j = 0; j < columns; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      if (skipZeros) {
        for (var k = k0; k < k1; k++) {
          var i2 = this._index[k];
          fastCallback.fn(this._values[k], [i2, j], me);
        }
      } else {
        var values = {};
        for (var _k2 = k0; _k2 < k1; _k2++) {
          var _i6 = this._index[_k2];
          values[_i6] = this._values[_k2];
        }
        for (var _i7 = 0; _i7 < rows; _i7++) {
          var value = _i7 in values ? values[_i7] : 0;
          fastCallback.fn(value, [_i7, j], me);
        }
      }
    }
  };
  SparseMatrix2.prototype[Symbol.iterator] = function* () {
    if (!this._values) {
      throw new Error("Cannot iterate a Pattern only matrix");
    }
    var columns = this._size[1];
    for (var j = 0; j < columns; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      for (var k = k0; k < k1; k++) {
        var i2 = this._index[k];
        yield {
          value: this._values[k],
          index: [i2, j]
        };
      }
    }
  };
  SparseMatrix2.prototype.toArray = function() {
    return _toArray(this._values, this._index, this._ptr, this._size, true);
  };
  SparseMatrix2.prototype.valueOf = function() {
    return _toArray(this._values, this._index, this._ptr, this._size, false);
  };
  function _toArray(values, index2, ptr, size2, copy) {
    var rows = size2[0];
    var columns = size2[1];
    var a = [];
    var i2, j;
    for (i2 = 0; i2 < rows; i2++) {
      a[i2] = [];
      for (j = 0; j < columns; j++) {
        a[i2][j] = 0;
      }
    }
    for (j = 0; j < columns; j++) {
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      for (var k = k0; k < k1; k++) {
        i2 = index2[k];
        a[i2][j] = values ? copy ? clone(values[k]) : values[k] : 1;
      }
    }
    return a;
  }
  SparseMatrix2.prototype.format = function(options) {
    var rows = this._size[0];
    var columns = this._size[1];
    var density = this.density();
    var str = "Sparse Matrix [" + format2(rows, options) + " x " + format2(columns, options) + "] density: " + format2(density, options) + "\n";
    for (var j = 0; j < columns; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      for (var k = k0; k < k1; k++) {
        var i2 = this._index[k];
        str += "\n    (" + format2(i2, options) + ", " + format2(j, options) + ") ==> " + (this._values ? format2(this._values[k], options) : "X");
      }
    }
    return str;
  };
  SparseMatrix2.prototype.toString = function() {
    return format2(this.toArray());
  };
  SparseMatrix2.prototype.toJSON = function() {
    return {
      mathjs: "SparseMatrix",
      values: this._values,
      index: this._index,
      ptr: this._ptr,
      size: this._size,
      datatype: this._datatype
    };
  };
  SparseMatrix2.prototype.diagonal = function(k) {
    if (k) {
      if (isBigNumber(k)) {
        k = k.toNumber();
      }
      if (!isNumber(k) || !isInteger(k)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k = 0;
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    var rows = this._size[0];
    var columns = this._size[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var values = [];
    var index2 = [];
    var ptr = [];
    ptr[0] = 0;
    for (var j = kSuper; j < columns && values.length < n; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      for (var x = k0; x < k1; x++) {
        var i2 = this._index[x];
        if (i2 === j - kSuper + kSub) {
          values.push(this._values[x]);
          index2[values.length - 1] = i2 - kSub;
          break;
        }
      }
    }
    ptr.push(values.length);
    return new SparseMatrix2({
      values,
      index: index2,
      ptr,
      size: [n, 1]
    });
  };
  SparseMatrix2.fromJSON = function(json) {
    return new SparseMatrix2(json);
  };
  SparseMatrix2.diagonal = function(size2, value, k, defaultValue, datatype) {
    if (!isArray(size2)) {
      throw new TypeError("Array expected, size parameter");
    }
    if (size2.length !== 2) {
      throw new Error("Only two dimensions matrix are supported");
    }
    size2 = size2.map(function(s) {
      if (isBigNumber(s)) {
        s = s.toNumber();
      }
      if (!isNumber(s) || !isInteger(s) || s < 1) {
        throw new Error("Size values must be positive integers");
      }
      return s;
    });
    if (k) {
      if (isBigNumber(k)) {
        k = k.toNumber();
      }
      if (!isNumber(k) || !isInteger(k)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k = 0;
    }
    var eq = equalScalar2;
    var zero = 0;
    if (isString(datatype)) {
      eq = typed2.find(equalScalar2, [datatype, datatype]) || equalScalar2;
      zero = typed2.convert(0, datatype);
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    var rows = size2[0];
    var columns = size2[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var _value;
    if (isArray(value)) {
      if (value.length !== n) {
        throw new Error("Invalid value array length");
      }
      _value = function _value2(i3) {
        return value[i3];
      };
    } else if (isMatrix(value)) {
      var ms = value.size();
      if (ms.length !== 1 || ms[0] !== n) {
        throw new Error("Invalid matrix length");
      }
      _value = function _value2(i3) {
        return value.get([i3]);
      };
    } else {
      _value = function _value2() {
        return value;
      };
    }
    var values = [];
    var index2 = [];
    var ptr = [];
    for (var j = 0; j < columns; j++) {
      ptr.push(values.length);
      var i2 = j - kSuper;
      if (i2 >= 0 && i2 < n) {
        var v = _value(i2);
        if (!eq(v, zero)) {
          index2.push(i2 + kSub);
          values.push(v);
        }
      }
    }
    ptr.push(values.length);
    return new SparseMatrix2({
      values,
      index: index2,
      ptr,
      size: [rows, columns]
    });
  };
  SparseMatrix2.prototype.swapRows = function(i2, j) {
    if (!isNumber(i2) || !isInteger(i2) || !isNumber(j) || !isInteger(j)) {
      throw new Error("Row index must be positive integers");
    }
    if (this._size.length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(i2, this._size[0]);
    validateIndex(j, this._size[0]);
    SparseMatrix2._swapRows(i2, j, this._size[1], this._values, this._index, this._ptr);
    return this;
  };
  SparseMatrix2._forEachRow = function(j, values, index2, ptr, callback) {
    var k0 = ptr[j];
    var k1 = ptr[j + 1];
    for (var k = k0; k < k1; k++) {
      callback(index2[k], values[k]);
    }
  };
  SparseMatrix2._swapRows = function(x, y, columns, values, index2, ptr) {
    for (var j = 0; j < columns; j++) {
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      var kx = _getValueIndex(x, k0, k1, index2);
      var ky = _getValueIndex(y, k0, k1, index2);
      if (kx < k1 && ky < k1 && index2[kx] === x && index2[ky] === y) {
        if (values) {
          var v = values[kx];
          values[kx] = values[ky];
          values[ky] = v;
        }
        continue;
      }
      if (kx < k1 && index2[kx] === x && (ky >= k1 || index2[ky] !== y)) {
        var vx = values ? values[kx] : void 0;
        index2.splice(ky, 0, y);
        if (values) {
          values.splice(ky, 0, vx);
        }
        index2.splice(ky <= kx ? kx + 1 : kx, 1);
        if (values) {
          values.splice(ky <= kx ? kx + 1 : kx, 1);
        }
        continue;
      }
      if (ky < k1 && index2[ky] === y && (kx >= k1 || index2[kx] !== x)) {
        var vy = values ? values[ky] : void 0;
        index2.splice(kx, 0, x);
        if (values) {
          values.splice(kx, 0, vy);
        }
        index2.splice(kx <= ky ? ky + 1 : ky, 1);
        if (values) {
          values.splice(kx <= ky ? ky + 1 : ky, 1);
        }
      }
    }
  };
  return SparseMatrix2;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/bignumber/function/bignumber.js
var name12 = "bignumber";
var dependencies12 = ["typed", "BigNumber"];
var createBignumber = factory(name12, dependencies12, (_ref) => {
  var {
    typed: typed2,
    BigNumber: BigNumber2
  } = _ref;
  return typed2("bignumber", {
    "": function _() {
      return new BigNumber2(0);
    },
    number: function number2(x) {
      return new BigNumber2(x + "");
    },
    string: function string2(x) {
      var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
      if (wordSizeSuffixMatch) {
        var size2 = wordSizeSuffixMatch[2];
        var n = BigNumber2(wordSizeSuffixMatch[1]);
        var twoPowSize = new BigNumber2(2).pow(Number(size2));
        if (n.gt(twoPowSize.sub(1))) {
          throw new SyntaxError('String "'.concat(x, '" is out of range'));
        }
        var twoPowSizeSubOne = new BigNumber2(2).pow(Number(size2) - 1);
        if (n.gte(twoPowSizeSubOne)) {
          return n.sub(twoPowSize);
        } else {
          return n;
        }
      }
      return new BigNumber2(x);
    },
    BigNumber: function BigNumber3(x) {
      return x;
    },
    bigint: function bigint2(x) {
      return new BigNumber2(x.toString());
    },
    Unit: typed2.referToSelf((self) => (x) => {
      var clone3 = x.clone();
      clone3.value = self(x.value);
      return clone3;
    }),
    Fraction: function Fraction3(x) {
      return new BigNumber2(String(x.n)).div(String(x.d)).times(String(x.s));
    },
    null: function _null2(_x) {
      return new BigNumber2(0);
    },
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self))
  });
});

// node_modules/mathjs/lib/esm/type/complex/function/complex.js
var name13 = "complex";
var dependencies13 = ["typed", "Complex"];
var createComplex = factory(name13, dependencies13, (_ref) => {
  var {
    typed: typed2,
    Complex: Complex3
  } = _ref;
  return typed2("complex", {
    "": function _() {
      return Complex3.ZERO;
    },
    number: function number2(x) {
      return new Complex3(x, 0);
    },
    "number, number": function number_number(re2, im2) {
      return new Complex3(re2, im2);
    },
    // TODO: this signature should be redundant
    "BigNumber, BigNumber": function BigNumber_BigNumber(re2, im2) {
      return new Complex3(re2.toNumber(), im2.toNumber());
    },
    Fraction: function Fraction3(x) {
      return new Complex3(x.valueOf(), 0);
    },
    Complex: function Complex4(x) {
      return x.clone();
    },
    string: function string2(x) {
      return Complex3(x);
    },
    null: function _null2(x) {
      return Complex3(0);
    },
    Object: function Object2(x) {
      if ("re" in x && "im" in x) {
        return new Complex3(x.re, x.im);
      }
      if ("r" in x && "phi" in x || "abs" in x && "arg" in x) {
        return new Complex3(x);
      }
      throw new Error("Expected object with properties (re and im) or (r and phi) or (abs and arg)");
    },
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self))
  });
});

// node_modules/mathjs/lib/esm/type/fraction/function/fraction.js
var name14 = "fraction";
var dependencies14 = ["typed", "Fraction"];
var createFraction = factory(name14, dependencies14, (_ref) => {
  var {
    typed: typed2,
    Fraction: Fraction3
  } = _ref;
  return typed2("fraction", {
    number: function number2(x) {
      if (!isFinite(x) || isNaN(x)) {
        throw new Error(x + " cannot be represented as a fraction");
      }
      return new Fraction3(x);
    },
    string: function string2(x) {
      return new Fraction3(x);
    },
    "number, number": function number_number(numerator, denominator) {
      return new Fraction3(numerator, denominator);
    },
    "bigint, bigint": function bigint_bigint(numerator, denominator) {
      return new Fraction3(numerator, denominator);
    },
    null: function _null2(x) {
      return new Fraction3(0);
    },
    BigNumber: function BigNumber2(x) {
      return new Fraction3(x.toString());
    },
    bigint: function bigint2(x) {
      return new Fraction3(x.toString());
    },
    Fraction: function Fraction4(x) {
      return x;
    },
    Unit: typed2.referToSelf((self) => (x) => {
      var clone3 = x.clone();
      clone3.value = self(x.value);
      return clone3;
    }),
    Object: function Object2(x) {
      return new Fraction3(x);
    },
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self))
  });
});

// node_modules/mathjs/lib/esm/type/matrix/function/matrix.js
var name15 = "matrix";
var dependencies15 = ["typed", "Matrix", "DenseMatrix", "SparseMatrix"];
var createMatrix = factory(name15, dependencies15, (_ref) => {
  var {
    typed: typed2,
    Matrix: Matrix2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix: SparseMatrix2
  } = _ref;
  return typed2(name15, {
    "": function _() {
      return _create([]);
    },
    string: function string2(format4) {
      return _create([], format4);
    },
    "string, string": function string_string(format4, datatype) {
      return _create([], format4, datatype);
    },
    Array: function Array2(data) {
      return _create(data);
    },
    Matrix: function Matrix3(data) {
      return _create(data, data.storage());
    },
    "Array | Matrix, string": _create,
    "Array | Matrix, string, string": _create
  });
  function _create(data, format4, datatype) {
    if (format4 === "dense" || format4 === "default" || format4 === void 0) {
      return new DenseMatrix2(data, datatype);
    }
    if (format4 === "sparse") {
      return new SparseMatrix2(data, datatype);
    }
    throw new TypeError("Unknown matrix type " + JSON.stringify(format4) + ".");
  }
});

// node_modules/mathjs/lib/esm/function/matrix/matrixFromFunction.js
var name16 = "matrixFromFunction";
var dependencies16 = ["typed", "matrix", "isZero"];
var createMatrixFromFunction = factory(name16, dependencies16, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    isZero: isZero2
  } = _ref;
  return typed2(name16, {
    "Array | Matrix, function, string, string": function Array__Matrix_function_string_string(size2, fn, format4, datatype) {
      return _create(size2, fn, format4, datatype);
    },
    "Array | Matrix, function, string": function Array__Matrix_function_string(size2, fn, format4) {
      return _create(size2, fn, format4);
    },
    "Matrix, function": function Matrix_function(size2, fn) {
      return _create(size2, fn, "dense");
    },
    "Array, function": function Array_function(size2, fn) {
      return _create(size2, fn, "dense").toArray();
    },
    "Array | Matrix, string, function": function Array__Matrix_string_function(size2, format4, fn) {
      return _create(size2, fn, format4);
    },
    "Array | Matrix, string, string, function": function Array__Matrix_string_string_function(size2, format4, datatype, fn) {
      return _create(size2, fn, format4, datatype);
    }
  });
  function _create(size2, fn, format4, datatype) {
    var m;
    if (datatype !== void 0) {
      m = matrix2(format4, datatype);
    } else {
      m = matrix2(format4);
    }
    m.resize(size2);
    m.forEach(function(_, index2) {
      var val = fn(index2);
      if (isZero2(val)) return;
      m.set(index2, val);
    });
    return m;
  }
});

// node_modules/mathjs/lib/esm/function/matrix/matrixFromRows.js
var name17 = "matrixFromRows";
var dependencies17 = ["typed", "matrix", "flatten", "size"];
var createMatrixFromRows = factory(name17, dependencies17, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    flatten: flatten3,
    size: size2
  } = _ref;
  return typed2(name17, {
    "...Array": function Array2(arr) {
      return _createArray(arr);
    },
    "...Matrix": function Matrix2(arr) {
      return matrix2(_createArray(arr.map((m) => m.toArray())));
    }
    // TODO implement this properly for SparseMatrix
  });
  function _createArray(arr) {
    if (arr.length === 0) throw new TypeError("At least one row is needed to construct a matrix.");
    var N = checkVectorTypeAndReturnLength(arr[0]);
    var result = [];
    for (var row2 of arr) {
      var rowLength = checkVectorTypeAndReturnLength(row2);
      if (rowLength !== N) {
        throw new TypeError("The vectors had different length: " + (N | 0) + "  " + (rowLength | 0));
      }
      result.push(flatten3(row2));
    }
    return result;
  }
  function checkVectorTypeAndReturnLength(vec) {
    var s = size2(vec);
    if (s.length === 1) {
      return s[0];
    } else if (s.length === 2) {
      if (s[0] === 1) {
        return s[1];
      } else if (s[1] === 1) {
        return s[0];
      } else {
        throw new TypeError("At least one of the arguments is not a vector.");
      }
    } else {
      throw new TypeError("Only one- or two-dimensional vectors are supported.");
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/matrixFromColumns.js
var name18 = "matrixFromColumns";
var dependencies18 = ["typed", "matrix", "flatten", "size"];
var createMatrixFromColumns = factory(name18, dependencies18, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    flatten: flatten3,
    size: size2
  } = _ref;
  return typed2(name18, {
    "...Array": function Array2(arr) {
      return _createArray(arr);
    },
    "...Matrix": function Matrix2(arr) {
      return matrix2(_createArray(arr.map((m) => m.toArray())));
    }
    // TODO implement this properly for SparseMatrix
  });
  function _createArray(arr) {
    if (arr.length === 0) throw new TypeError("At least one column is needed to construct a matrix.");
    var N = checkVectorTypeAndReturnLength(arr[0]);
    var result = [];
    for (var i2 = 0; i2 < N; i2++) {
      result[i2] = [];
    }
    for (var col of arr) {
      var colLength = checkVectorTypeAndReturnLength(col);
      if (colLength !== N) {
        throw new TypeError("The vectors had different length: " + (N | 0) + "  " + (colLength | 0));
      }
      var f = flatten3(col);
      for (var _i = 0; _i < N; _i++) {
        result[_i].push(f[_i]);
      }
    }
    return result;
  }
  function checkVectorTypeAndReturnLength(vec) {
    var s = size2(vec);
    if (s.length === 1) {
      return s[0];
    } else if (s.length === 2) {
      if (s[0] === 1) {
        return s[1];
      } else if (s[1] === 1) {
        return s[0];
      } else {
        throw new TypeError("At least one of the arguments is not a vector.");
      }
    } else {
      throw new TypeError("Only one- or two-dimensional vectors are supported.");
    }
  }
});

// node_modules/mathjs/lib/esm/type/unit/function/splitUnit.js
var name19 = "splitUnit";
var dependencies19 = ["typed"];
var createSplitUnit = factory(name19, dependencies19, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name19, {
    "Unit, Array": function Unit_Array(unit2, parts) {
      return unit2.splitUnit(parts);
    }
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/unaryMinus.js
var name20 = "unaryMinus";
var dependencies20 = ["typed"];
var createUnaryMinus = factory(name20, dependencies20, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name20, {
    number: unaryMinusNumber,
    "Complex | BigNumber | Fraction": (x) => x.neg(),
    bigint: (x) => -x,
    Unit: typed2.referToSelf((self) => (x) => {
      var res = x.clone();
      res.value = typed2.find(self, res.valueType())(x.value);
      return res;
    }),
    // deep map collection, skip zeros since unaryMinus(0) = 0
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self, true))
    // TODO: add support for string
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/unaryPlus.js
var name21 = "unaryPlus";
var dependencies21 = ["typed", "config", "numeric"];
var createUnaryPlus = factory(name21, dependencies21, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    numeric: numeric2
  } = _ref;
  return typed2(name21, {
    number: unaryPlusNumber,
    Complex: function Complex3(x) {
      return x;
    },
    BigNumber: function BigNumber2(x) {
      return x;
    },
    bigint: function bigint2(x) {
      return x;
    },
    Fraction: function Fraction3(x) {
      return x;
    },
    Unit: function Unit2(x) {
      return x.clone();
    },
    // deep map collection, skip zeros since unaryPlus(0) = 0
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self, true)),
    boolean: function boolean2(x) {
      return numeric2(x ? 1 : 0, config2.number);
    },
    string: function string2(x) {
      return numeric2(x, safeNumberType(x, config2));
    }
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/abs.js
var name22 = "abs";
var dependencies22 = ["typed"];
var createAbs = factory(name22, dependencies22, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name22, {
    number: absNumber,
    "Complex | BigNumber | Fraction | Unit": (x) => x.abs(),
    bigint: (x) => x < 0n ? -x : x,
    // deep map collection, skip zeros since abs(0) = 0
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self, true))
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/addScalar.js
var name23 = "addScalar";
var dependencies23 = ["typed"];
var createAddScalar = factory(name23, dependencies23, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name23, {
    "number, number": addNumber,
    "Complex, Complex": function Complex_Complex(x, y) {
      return x.add(y);
    },
    "BigNumber, BigNumber": function BigNumber_BigNumber(x, y) {
      return x.plus(y);
    },
    "bigint, bigint": function bigint_bigint(x, y) {
      return x + y;
    },
    "Fraction, Fraction": function Fraction_Fraction(x, y) {
      return x.add(y);
    },
    "Unit, Unit": typed2.referToSelf((self) => (x, y) => {
      if (x.value === null || x.value === void 0) {
        throw new Error("Parameter x contains a unit with undefined value");
      }
      if (y.value === null || y.value === void 0) {
        throw new Error("Parameter y contains a unit with undefined value");
      }
      if (!x.equalBase(y)) throw new Error("Units do not match");
      var res = x.clone();
      res.value = typed2.find(self, [res.valueType(), y.valueType()])(res.value, y.value);
      res.fixPrefix = false;
      return res;
    })
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/subtractScalar.js
var name24 = "subtractScalar";
var dependencies24 = ["typed"];
var createSubtractScalar = factory(name24, dependencies24, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name24, {
    "number, number": subtractNumber,
    "Complex, Complex": function Complex_Complex(x, y) {
      return x.sub(y);
    },
    "BigNumber, BigNumber": function BigNumber_BigNumber(x, y) {
      return x.minus(y);
    },
    "bigint, bigint": function bigint_bigint(x, y) {
      return x - y;
    },
    "Fraction, Fraction": function Fraction_Fraction(x, y) {
      return x.sub(y);
    },
    "Unit, Unit": typed2.referToSelf((self) => (x, y) => {
      if (x.value === null || x.value === void 0) {
        throw new Error("Parameter x contains a unit with undefined value");
      }
      if (y.value === null || y.value === void 0) {
        throw new Error("Parameter y contains a unit with undefined value");
      }
      if (!x.equalBase(y)) throw new Error("Units do not match");
      var res = x.clone();
      res.value = typed2.find(self, [res.valueType(), y.valueType()])(res.value, y.value);
      res.fixPrefix = false;
      return res;
    })
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/cbrt.js
var name25 = "cbrt";
var dependencies25 = ["config", "typed", "isNegative", "unaryMinus", "matrix", "Complex", "BigNumber", "Fraction"];
var createCbrt = factory(name25, dependencies25, (_ref) => {
  var {
    config: config2,
    typed: typed2,
    isNegative: isNegative2,
    unaryMinus: unaryMinus2,
    matrix: matrix2,
    Complex: Complex3,
    BigNumber: BigNumber2,
    Fraction: Fraction3
  } = _ref;
  return typed2(name25, {
    number: cbrtNumber,
    // note: signature 'number, boolean' is also supported,
    //       created by typed as it knows how to convert number to Complex
    Complex: _cbrtComplex,
    "Complex, boolean": _cbrtComplex,
    BigNumber: function BigNumber3(x) {
      return x.cbrt();
    },
    Unit: _cbrtUnit
  });
  function _cbrtComplex(x, allRoots) {
    var arg3 = x.arg() / 3;
    var abs2 = x.abs();
    var principal = new Complex3(cbrtNumber(abs2), 0).mul(new Complex3(0, arg3).exp());
    if (allRoots) {
      var all2 = [principal, new Complex3(cbrtNumber(abs2), 0).mul(new Complex3(0, arg3 + Math.PI * 2 / 3).exp()), new Complex3(cbrtNumber(abs2), 0).mul(new Complex3(0, arg3 - Math.PI * 2 / 3).exp())];
      return config2.matrix === "Array" ? all2 : matrix2(all2);
    } else {
      return principal;
    }
  }
  function _cbrtUnit(x) {
    if (x.value && isComplex(x.value)) {
      var result = x.clone();
      result.value = 1;
      result = result.pow(1 / 3);
      result.value = _cbrtComplex(x.value);
      return result;
    } else {
      var negate = isNegative2(x.value);
      if (negate) {
        x.value = unaryMinus2(x.value);
      }
      var third;
      if (isBigNumber(x.value)) {
        third = new BigNumber2(1).div(3);
      } else if (isFraction(x.value)) {
        third = new Fraction3(1, 3);
      } else {
        third = 1 / 3;
      }
      var _result = x.pow(third);
      if (negate) {
        _result.value = unaryMinus2(_result.value);
      }
      return _result;
    }
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/cube.js
var name26 = "cube";
var dependencies26 = ["typed"];
var createCube = factory(name26, dependencies26, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name26, {
    number: cubeNumber,
    Complex: function Complex3(x) {
      return x.mul(x).mul(x);
    },
    BigNumber: function BigNumber2(x) {
      return x.times(x).times(x);
    },
    bigint: function bigint2(x) {
      return x * x * x;
    },
    Fraction: function Fraction3(x) {
      return x.pow(3);
    },
    Unit: function Unit2(x) {
      return x.pow(3);
    }
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/exp.js
var name27 = "exp";
var dependencies27 = ["typed"];
var createExp = factory(name27, dependencies27, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name27, {
    number: expNumber,
    Complex: function Complex3(x) {
      return x.exp();
    },
    BigNumber: function BigNumber2(x) {
      return x.exp();
    }
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/expm1.js
var name28 = "expm1";
var dependencies28 = ["typed", "Complex"];
var createExpm1 = factory(name28, dependencies28, (_ref) => {
  var {
    typed: typed2,
    Complex: _Complex
  } = _ref;
  return typed2(name28, {
    number: expm1Number,
    Complex: function Complex3(x) {
      var r = Math.exp(x.re);
      return new _Complex(r * Math.cos(x.im) - 1, r * Math.sin(x.im));
    },
    BigNumber: function BigNumber2(x) {
      return x.exp().minus(1);
    }
  });
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo02xDS0.js
var name29 = "matAlgo02xDS0";
var dependencies29 = ["typed", "equalScalar"];
var createMatAlgo02xDS0 = factory(name29, dependencies29, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2
  } = _ref;
  return function matAlgo02xDS0(denseMatrix, sparseMatrix, callback, inverse) {
    var adata = denseMatrix._data;
    var asize = denseMatrix._size;
    var adt = denseMatrix._datatype || denseMatrix.getDataType();
    var bvalues = sparseMatrix._values;
    var bindex = sparseMatrix._index;
    var bptr = sparseMatrix._ptr;
    var bsize = sparseMatrix._size;
    var bdt = sparseMatrix._datatype || sparseMatrix._data === void 0 ? sparseMatrix._datatype : sparseMatrix.getDataType();
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    if (!bvalues) {
      throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar2;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
      dt = adt;
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    for (var j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        var i2 = bindex[k];
        var cij = inverse ? cf(bvalues[k], adata[i2][j]) : cf(adata[i2][j], bvalues[k]);
        if (!eq(cij, zero)) {
          cindex.push(i2);
          cvalues.push(cij);
        }
      }
    }
    cptr[columns] = cindex.length;
    return sparseMatrix.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: adt === denseMatrix._datatype && bdt === sparseMatrix._datatype ? dt : void 0
    });
  };
});

// node_modules/mathjs/lib/esm/function/arithmetic/mod.js
var name30 = "mod";
var dependencies30 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
var createMod = factory(name30, dependencies30, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    round: round2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  } = _ref;
  var floor2 = createFloor({
    typed: typed2,
    config: config2,
    round: round2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo05xSfSf = createMatAlgo05xSfSf({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat3
  });
  return typed2(name30, {
    "number, number": _modNumber,
    "BigNumber, BigNumber": function BigNumber_BigNumber(x, y) {
      return y.isZero() ? x : x.sub(y.mul(floor2(x.div(y))));
    },
    "bigint, bigint": function bigint_bigint(x, y) {
      if (y === 0n) {
        return x;
      }
      if (x < 0) {
        var m = x % y;
        return m === 0n ? m : m + y;
      }
      return x % y;
    },
    "Fraction, Fraction": function Fraction_Fraction(x, y) {
      return y.equals(0) ? x : x.sub(y.mul(floor2(x.div(y))));
    }
  }, matrixAlgorithmSuite({
    SS: matAlgo05xSfSf,
    DS: matAlgo03xDSf,
    SD: matAlgo02xDS0,
    Ss: matAlgo11xS0s,
    sS: matAlgo12xSfs
  }));
  function _modNumber(x, y) {
    return y === 0 ? x : x - y * floor2(x / y);
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo01xDSid.js
var name31 = "matAlgo01xDSid";
var dependencies31 = ["typed"];
var createMatAlgo01xDSid = factory(name31, dependencies31, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return function algorithm1(denseMatrix, sparseMatrix, callback, inverse) {
    var adata = denseMatrix._data;
    var asize = denseMatrix._size;
    var adt = denseMatrix._datatype || denseMatrix.getDataType();
    var bvalues = sparseMatrix._values;
    var bindex = sparseMatrix._index;
    var bptr = sparseMatrix._ptr;
    var bsize = sparseMatrix._size;
    var bdt = sparseMatrix._datatype || sparseMatrix._data === void 0 ? sparseMatrix._datatype : sparseMatrix.getDataType();
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    if (!bvalues) {
      throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt = typeof adt === "string" && adt !== "mixed" && adt === bdt ? adt : void 0;
    var cf = dt ? typed2.find(callback, [dt, dt]) : callback;
    var i2, j;
    var cdata = [];
    for (i2 = 0; i2 < rows; i2++) {
      cdata[i2] = [];
    }
    var x = [];
    var w = [];
    for (j = 0; j < columns; j++) {
      var mark = j + 1;
      for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        i2 = bindex[k];
        x[i2] = inverse ? cf(bvalues[k], adata[i2][j]) : cf(adata[i2][j], bvalues[k]);
        w[i2] = mark;
      }
      for (i2 = 0; i2 < rows; i2++) {
        if (w[i2] === mark) {
          cdata[i2][j] = x[i2];
        } else {
          cdata[i2][j] = adata[i2][j];
        }
      }
    }
    return denseMatrix.createDenseMatrix({
      data: cdata,
      size: [rows, columns],
      datatype: adt === denseMatrix._datatype && bdt === sparseMatrix._datatype ? dt : void 0
    });
  };
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo04xSidSid.js
var name32 = "matAlgo04xSidSid";
var dependencies32 = ["typed", "equalScalar"];
var createMatAlgo04xSidSid = factory(name32, dependencies32, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2
  } = _ref;
  return function matAlgo04xSidSid(a, b, callback) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar2;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
      dt = adt;
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = avalues && bvalues ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var xa = avalues && bvalues ? [] : void 0;
    var xb = avalues && bvalues ? [] : void 0;
    var wa = [];
    var wb = [];
    var i2, j, k, k0, k1;
    for (j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        i2 = aindex[k];
        cindex.push(i2);
        wa[i2] = mark;
        if (xa) {
          xa[i2] = avalues[k];
        }
      }
      for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        i2 = bindex[k];
        if (wa[i2] === mark) {
          if (xa) {
            var v = cf(xa[i2], bvalues[k]);
            if (!eq(v, zero)) {
              xa[i2] = v;
            } else {
              wa[i2] = null;
            }
          }
        } else {
          cindex.push(i2);
          wb[i2] = mark;
          if (xb) {
            xb[i2] = bvalues[k];
          }
        }
      }
      if (xa && xb) {
        k = cptr[j];
        while (k < cindex.length) {
          i2 = cindex[k];
          if (wa[i2] === mark) {
            cvalues[k] = xa[i2];
            k++;
          } else if (wb[i2] === mark) {
            cvalues[k] = xb[i2];
            k++;
          } else {
            cindex.splice(k, 1);
          }
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
  };
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo10xSids.js
var name33 = "matAlgo10xSids";
var dependencies33 = ["typed", "DenseMatrix"];
var createMatAlgo10xSids = factory(name33, dependencies33, (_ref) => {
  var {
    typed: typed2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return function matAlgo10xSids(s, b, callback, inverse) {
    var avalues = s._values;
    var aindex = s._index;
    var aptr = s._ptr;
    var asize = s._size;
    var adt = s._datatype;
    if (!avalues) {
      throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var cf = callback;
    if (typeof adt === "string") {
      dt = adt;
      b = typed2.convert(b, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cdata = [];
    var x = [];
    var w = [];
    for (var j = 0; j < columns; j++) {
      var mark = j + 1;
      for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        var r = aindex[k];
        x[r] = avalues[k];
        w[r] = mark;
      }
      for (var i2 = 0; i2 < rows; i2++) {
        if (j === 0) {
          cdata[i2] = [];
        }
        if (w[i2] === mark) {
          cdata[i2][j] = inverse ? cf(b, x[i2]) : cf(x[i2], b);
        } else {
          cdata[i2][j] = b;
        }
      }
    }
    return new DenseMatrix2({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// node_modules/mathjs/lib/esm/function/arithmetic/gcd.js
var name34 = "gcd";
var dependencies34 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "BigNumber", "DenseMatrix", "concat"];
var gcdTypes = "number | BigNumber | Fraction | Matrix | Array";
var gcdManyTypesSignature = "".concat(gcdTypes, ", ").concat(gcdTypes, ", ...").concat(gcdTypes);
function is1d(array) {
  return !array.some((element) => Array.isArray(element));
}
var createGcd = factory(name34, dependencies34, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    config: config2,
    round: round2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    BigNumber: BigNumber2,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  } = _ref;
  var mod2 = createMod({
    typed: typed2,
    config: config2,
    round: round2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  });
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo04xSidSid = createMatAlgo04xSidSid({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat3
  });
  return typed2(name34, {
    "number, number": _gcdNumber,
    "BigNumber, BigNumber": _gcdBigNumber,
    "Fraction, Fraction": (x, y) => x.gcd(y)
  }, matrixAlgorithmSuite({
    SS: matAlgo04xSidSid,
    DS: matAlgo01xDSid,
    Ss: matAlgo10xSids
  }), {
    [gcdManyTypesSignature]: typed2.referToSelf((self) => (a, b, args) => {
      var res = self(a, b);
      for (var i2 = 0; i2 < args.length; i2++) {
        res = self(res, args[i2]);
      }
      return res;
    }),
    Array: typed2.referToSelf((self) => (array) => {
      if (array.length === 1 && Array.isArray(array[0]) && is1d(array[0])) {
        return self(...array[0]);
      }
      if (is1d(array)) {
        return self(...array);
      }
      throw new ArgumentsError("gcd() supports only 1d matrices!");
    }),
    Matrix: typed2.referToSelf((self) => (matrix3) => {
      return self(matrix3.toArray());
    })
  });
  function _gcdNumber(a, b) {
    if (!isInteger(a) || !isInteger(b)) {
      throw new Error("Parameters in function gcd must be integer numbers");
    }
    var r;
    while (b !== 0) {
      r = mod2(a, b);
      a = b;
      b = r;
    }
    return a < 0 ? -a : a;
  }
  function _gcdBigNumber(a, b) {
    if (!a.isInt() || !b.isInt()) {
      throw new Error("Parameters in function gcd must be integer numbers");
    }
    var zero = new BigNumber2(0);
    while (!b.isZero()) {
      var r = mod2(a, b);
      a = b;
      b = r;
    }
    return a.lt(zero) ? a.neg() : a;
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo06xS0S0.js
var name35 = "matAlgo06xS0S0";
var dependencies35 = ["typed", "equalScalar"];
var createMatAlgo06xS0S0 = factory(name35, dependencies35, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2
  } = _ref;
  return function matAlgo06xS0S0(a, b, callback) {
    var avalues = a._values;
    var asize = a._size;
    var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
    var bvalues = b._values;
    var bsize = b._size;
    var bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar2;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
      dt = adt;
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = avalues && bvalues ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var x = cvalues ? [] : void 0;
    var w = [];
    var u = [];
    for (var j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      scatter(a, j, w, x, u, mark, cindex, cf);
      scatter(b, j, w, x, u, mark, cindex, cf);
      if (x) {
        var k = cptr[j];
        while (k < cindex.length) {
          var i2 = cindex[k];
          if (u[i2] === mark) {
            var v = x[i2];
            if (!eq(v, zero)) {
              cvalues.push(v);
              k++;
            } else {
              cindex.splice(k, 1);
            }
          } else {
            cindex.splice(k, 1);
          }
        }
      } else {
        var p = cptr[j];
        while (p < cindex.length) {
          var r = cindex[p];
          if (u[r] !== mark) {
            cindex.splice(p, 1);
          } else {
            p++;
          }
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
  };
});

// node_modules/mathjs/lib/esm/function/arithmetic/lcm.js
var name36 = "lcm";
var dependencies36 = ["typed", "matrix", "equalScalar", "concat"];
var createLcm = factory(name36, dependencies36, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    concat: concat3
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo06xS0S0 = createMatAlgo06xS0S0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat3
  });
  var lcmTypes = "number | BigNumber | Fraction | Matrix | Array";
  var lcmManySignature = {};
  lcmManySignature["".concat(lcmTypes, ", ").concat(lcmTypes, ", ...").concat(lcmTypes)] = typed2.referToSelf((self) => (a, b, args) => {
    var res = self(a, b);
    for (var i2 = 0; i2 < args.length; i2++) {
      res = self(res, args[i2]);
    }
    return res;
  });
  return typed2(name36, {
    "number, number": lcmNumber,
    "BigNumber, BigNumber": _lcmBigNumber,
    "Fraction, Fraction": (x, y) => x.lcm(y)
  }, matrixAlgorithmSuite({
    SS: matAlgo06xS0S0,
    DS: matAlgo02xDS0,
    Ss: matAlgo11xS0s
  }), lcmManySignature);
  function _lcmBigNumber(a, b) {
    if (!a.isInt() || !b.isInt()) {
      throw new Error("Parameters in function lcm must be integer numbers");
    }
    if (a.isZero()) {
      return a;
    }
    if (b.isZero()) {
      return b;
    }
    var prod2 = a.times(b);
    while (!b.isZero()) {
      var t = b;
      b = a.mod(t);
      a = t;
    }
    return prod2.div(a).abs();
  }
});

// node_modules/mathjs/lib/esm/utils/bigint.js
function promoteLogarithm(log162, numberLog, config2, cplx) {
  return function(b) {
    if (b > 0 || config2.predictable) {
      if (b <= 0) return NaN;
      var s = b.toString(16);
      var s15 = s.substring(0, 15);
      return log162 * (s.length - s15.length) + numberLog(Number("0x" + s15));
    }
    return cplx(b.toNumber());
  };
}

// node_modules/mathjs/lib/esm/function/arithmetic/log10.js
var name37 = "log10";
var dependencies37 = ["typed", "config", "Complex"];
var log16 = log10Number(16);
var createLog10 = factory(name37, dependencies37, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    Complex: Complex3
  } = _ref;
  function complexLog(c) {
    return c.log().div(Math.LN10);
  }
  function complexLogNumber(x) {
    return complexLog(new Complex3(x, 0));
  }
  return typed2(name37, {
    number: function number2(x) {
      if (x >= 0 || config2.predictable) {
        return log10Number(x);
      } else {
        return complexLogNumber(x);
      }
    },
    bigint: promoteLogarithm(log16, log10Number, config2, complexLogNumber),
    Complex: complexLog,
    BigNumber: function BigNumber2(x) {
      if (!x.isNegative() || config2.predictable) {
        return x.log();
      } else {
        return complexLogNumber(x.toNumber());
      }
    },
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self))
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/log2.js
var name38 = "log2";
var dependencies38 = ["typed", "config", "Complex"];
var createLog2 = factory(name38, dependencies38, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    Complex: Complex3
  } = _ref;
  function complexLog2Number(x) {
    return _log2Complex(new Complex3(x, 0));
  }
  return typed2(name38, {
    number: function number2(x) {
      if (x >= 0 || config2.predictable) {
        return log2Number(x);
      } else {
        return complexLog2Number(x);
      }
    },
    bigint: promoteLogarithm(4, log2Number, config2, complexLog2Number),
    Complex: _log2Complex,
    BigNumber: function BigNumber2(x) {
      if (!x.isNegative() || config2.predictable) {
        return x.log(2);
      } else {
        return complexLog2Number(x.toNumber());
      }
    },
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self))
  });
  function _log2Complex(x) {
    var newX = Math.sqrt(x.re * x.re + x.im * x.im);
    return new Complex3(Math.log2 ? Math.log2(newX) : Math.log(newX) / Math.LN2, Math.atan2(x.im, x.re) / Math.LN2);
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/multiplyScalar.js
var name39 = "multiplyScalar";
var dependencies39 = ["typed"];
var createMultiplyScalar = factory(name39, dependencies39, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2("multiplyScalar", {
    "number, number": multiplyNumber,
    "Complex, Complex": function Complex_Complex(x, y) {
      return x.mul(y);
    },
    "BigNumber, BigNumber": function BigNumber_BigNumber(x, y) {
      return x.times(y);
    },
    "bigint, bigint": function bigint_bigint(x, y) {
      return x * y;
    },
    "Fraction, Fraction": function Fraction_Fraction(x, y) {
      return x.mul(y);
    },
    "number | Fraction | BigNumber | Complex, Unit": (x, y) => y.multiply(x),
    "Unit, number | Fraction | BigNumber | Complex | Unit": (x, y) => x.multiply(y)
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/multiply.js
var name40 = "multiply";
var dependencies40 = ["typed", "matrix", "addScalar", "multiplyScalar", "equalScalar", "dot"];
var createMultiply = factory(name40, dependencies40, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    addScalar: addScalar2,
    multiplyScalar: multiplyScalar2,
    equalScalar: equalScalar2,
    dot: dot2
  } = _ref;
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  function _validateMatrixDimensions(size1, size2) {
    switch (size1.length) {
      case 1:
        switch (size2.length) {
          case 1:
            if (size1[0] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Vectors must have the same length");
            }
            break;
          case 2:
            if (size1[0] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Vector length (" + size1[0] + ") must match Matrix rows (" + size2[0] + ")");
            }
            break;
          default:
            throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
        }
        break;
      case 2:
        switch (size2.length) {
          case 1:
            if (size1[1] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Matrix columns (" + size1[1] + ") must match Vector length (" + size2[0] + ")");
            }
            break;
          case 2:
            if (size1[1] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Matrix A columns (" + size1[1] + ") must match Matrix B rows (" + size2[0] + ")");
            }
            break;
          default:
            throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
        }
        break;
      default:
        throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix A has " + size1.length + " dimensions)");
    }
  }
  function _multiplyVectorVector(a, b, n) {
    if (n === 0) {
      throw new Error("Cannot multiply two empty vectors");
    }
    return dot2(a, b);
  }
  function _multiplyVectorMatrix(a, b) {
    if (b.storage() !== "dense") {
      throw new Error("Support for SparseMatrix not implemented");
    }
    return _multiplyVectorDenseMatrix(a, b);
  }
  function _multiplyVectorDenseMatrix(a, b) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype || a.getDataType();
    var bdata = b._data;
    var bsize = b._size;
    var bdt = b._datatype || b.getDataType();
    var alength = asize[0];
    var bcolumns = bsize[1];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
    }
    var c = [];
    for (var j = 0; j < bcolumns; j++) {
      var sum2 = mf(adata[0], bdata[0][j]);
      for (var i2 = 1; i2 < alength; i2++) {
        sum2 = af(sum2, mf(adata[i2], bdata[i2][j]));
      }
      c[j] = sum2;
    }
    return a.createDenseMatrix({
      data: c,
      size: [bcolumns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
  }
  var _multiplyMatrixVector = typed2("_multiplyMatrixVector", {
    "DenseMatrix, any": _multiplyDenseMatrixVector,
    "SparseMatrix, any": _multiplySparseMatrixVector
  });
  var _multiplyMatrixMatrix = typed2("_multiplyMatrixMatrix", {
    "DenseMatrix, DenseMatrix": _multiplyDenseMatrixDenseMatrix,
    "DenseMatrix, SparseMatrix": _multiplyDenseMatrixSparseMatrix,
    "SparseMatrix, DenseMatrix": _multiplySparseMatrixDenseMatrix,
    "SparseMatrix, SparseMatrix": _multiplySparseMatrixSparseMatrix
  });
  function _multiplyDenseMatrixVector(a, b) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype || a.getDataType();
    var bdata = b._data;
    var bdt = b._datatype || b.getDataType();
    var arows = asize[0];
    var acolumns = asize[1];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
    }
    var c = [];
    for (var i2 = 0; i2 < arows; i2++) {
      var row2 = adata[i2];
      var sum2 = mf(row2[0], bdata[0]);
      for (var j = 1; j < acolumns; j++) {
        sum2 = af(sum2, mf(row2[j], bdata[j]));
      }
      c[i2] = sum2;
    }
    return a.createDenseMatrix({
      data: c,
      size: [arows],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
  }
  function _multiplyDenseMatrixDenseMatrix(a, b) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype || a.getDataType();
    var bdata = b._data;
    var bsize = b._size;
    var bdt = b._datatype || b.getDataType();
    var arows = asize[0];
    var acolumns = asize[1];
    var bcolumns = bsize[1];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed" && adt !== "mixed") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
    }
    var c = [];
    for (var i2 = 0; i2 < arows; i2++) {
      var row2 = adata[i2];
      c[i2] = [];
      for (var j = 0; j < bcolumns; j++) {
        var sum2 = mf(row2[0], bdata[0][j]);
        for (var x = 1; x < acolumns; x++) {
          sum2 = af(sum2, mf(row2[x], bdata[x][j]));
        }
        c[i2][j] = sum2;
      }
    }
    return a.createDenseMatrix({
      data: c,
      size: [arows, bcolumns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
  }
  function _multiplyDenseMatrixSparseMatrix(a, b) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype || a.getDataType();
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
    if (!bvalues) {
      throw new Error("Cannot multiply Dense Matrix times Pattern only Matrix");
    }
    var arows = asize[0];
    var bcolumns = bsize[1];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    var eq = equalScalar2;
    var zero = 0;
    if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero = typed2.convert(0, dt);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var c = b.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, bcolumns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
    for (var jb = 0; jb < bcolumns; jb++) {
      cptr[jb] = cindex.length;
      var kb0 = bptr[jb];
      var kb1 = bptr[jb + 1];
      if (kb1 > kb0) {
        var last = 0;
        for (var i2 = 0; i2 < arows; i2++) {
          var mark = i2 + 1;
          var cij = void 0;
          for (var kb = kb0; kb < kb1; kb++) {
            var ib = bindex[kb];
            if (last !== mark) {
              cij = mf(adata[i2][ib], bvalues[kb]);
              last = mark;
            } else {
              cij = af(cij, mf(adata[i2][ib], bvalues[kb]));
            }
          }
          if (last === mark && !eq(cij, zero)) {
            cindex.push(i2);
            cvalues.push(cij);
          }
        }
      }
    }
    cptr[bcolumns] = cindex.length;
    return c;
  }
  function _multiplySparseMatrixVector(a, b) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
    if (!avalues) {
      throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
    }
    var bdata = b._data;
    var bdt = b._datatype || b.getDataType();
    var arows = a._size[0];
    var brows = b._size[0];
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    var eq = equalScalar2;
    var zero = 0;
    if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero = typed2.convert(0, dt);
    }
    var x = [];
    var w = [];
    cptr[0] = 0;
    for (var ib = 0; ib < brows; ib++) {
      var vbi = bdata[ib];
      if (!eq(vbi, zero)) {
        for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
          var ia = aindex[ka];
          if (!w[ia]) {
            w[ia] = true;
            cindex.push(ia);
            x[ia] = mf(vbi, avalues[ka]);
          } else {
            x[ia] = af(x[ia], mf(vbi, avalues[ka]));
          }
        }
      }
    }
    for (var p1 = cindex.length, p = 0; p < p1; p++) {
      var ic = cindex[p];
      cvalues[p] = x[ic];
    }
    cptr[1] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, 1],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
  }
  function _multiplySparseMatrixDenseMatrix(a, b) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
    if (!avalues) {
      throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
    }
    var bdata = b._data;
    var bdt = b._datatype || b.getDataType();
    var arows = a._size[0];
    var brows = b._size[0];
    var bcolumns = b._size[1];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    var eq = equalScalar2;
    var zero = 0;
    if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero = typed2.convert(0, dt);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var c = a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, bcolumns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
    var x = [];
    var w = [];
    for (var jb = 0; jb < bcolumns; jb++) {
      cptr[jb] = cindex.length;
      var mark = jb + 1;
      for (var ib = 0; ib < brows; ib++) {
        var vbij = bdata[ib][jb];
        if (!eq(vbij, zero)) {
          for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
            var ia = aindex[ka];
            if (w[ia] !== mark) {
              w[ia] = mark;
              cindex.push(ia);
              x[ia] = mf(vbij, avalues[ka]);
            } else {
              x[ia] = af(x[ia], mf(vbij, avalues[ka]));
            }
          }
        }
      }
      for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
        var ic = cindex[p];
        cvalues[p] = x[ic];
      }
    }
    cptr[bcolumns] = cindex.length;
    return c;
  }
  function _multiplySparseMatrixSparseMatrix(a, b) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
    var arows = a._size[0];
    var bcolumns = b._size[1];
    var values = avalues && bvalues;
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
    }
    var cvalues = values ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var c = a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, bcolumns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
    var x = values ? [] : void 0;
    var w = [];
    var ka, ka0, ka1, kb, kb0, kb1, ia, ib;
    for (var jb = 0; jb < bcolumns; jb++) {
      cptr[jb] = cindex.length;
      var mark = jb + 1;
      for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++) {
        ib = bindex[kb];
        if (values) {
          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
            ia = aindex[ka];
            if (w[ia] !== mark) {
              w[ia] = mark;
              cindex.push(ia);
              x[ia] = mf(bvalues[kb], avalues[ka]);
            } else {
              x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));
            }
          }
        } else {
          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
            ia = aindex[ka];
            if (w[ia] !== mark) {
              w[ia] = mark;
              cindex.push(ia);
            }
          }
        }
      }
      if (values) {
        for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
          var ic = cindex[p];
          cvalues[p] = x[ic];
        }
      }
    }
    cptr[bcolumns] = cindex.length;
    return c;
  }
  return typed2(name40, multiplyScalar2, {
    // we extend the signatures of multiplyScalar with signatures dealing with matrices
    "Array, Array": typed2.referTo("Matrix, Matrix", (selfMM) => (x, y) => {
      _validateMatrixDimensions(arraySize(x), arraySize(y));
      var m = selfMM(matrix2(x), matrix2(y));
      return isMatrix(m) ? m.valueOf() : m;
    }),
    "Matrix, Matrix": function Matrix_Matrix(x, y) {
      var xsize = x.size();
      var ysize = y.size();
      _validateMatrixDimensions(xsize, ysize);
      if (xsize.length === 1) {
        if (ysize.length === 1) {
          return _multiplyVectorVector(x, y, xsize[0]);
        }
        return _multiplyVectorMatrix(x, y);
      }
      if (ysize.length === 1) {
        return _multiplyMatrixVector(x, y);
      }
      return _multiplyMatrixMatrix(x, y);
    },
    "Matrix, Array": typed2.referTo("Matrix,Matrix", (selfMM) => (x, y) => selfMM(x, matrix2(y))),
    "Array, Matrix": typed2.referToSelf((self) => (x, y) => {
      return self(matrix2(x, y.storage()), y);
    }),
    "SparseMatrix, any": function SparseMatrix_any(x, y) {
      return matAlgo11xS0s(x, y, multiplyScalar2, false);
    },
    "DenseMatrix, any": function DenseMatrix_any(x, y) {
      return matAlgo14xDs(x, y, multiplyScalar2, false);
    },
    "any, SparseMatrix": function any_SparseMatrix(x, y) {
      return matAlgo11xS0s(y, x, multiplyScalar2, true);
    },
    "any, DenseMatrix": function any_DenseMatrix(x, y) {
      return matAlgo14xDs(y, x, multiplyScalar2, true);
    },
    "Array, any": function Array_any(x, y) {
      return matAlgo14xDs(matrix2(x), y, multiplyScalar2, false).valueOf();
    },
    "any, Array": function any_Array(x, y) {
      return matAlgo14xDs(matrix2(y), x, multiplyScalar2, true).valueOf();
    },
    "any, any": multiplyScalar2,
    "any, any, ...any": typed2.referToSelf((self) => (x, y, rest) => {
      var result = self(x, y);
      for (var i2 = 0; i2 < rest.length; i2++) {
        result = self(result, rest[i2]);
      }
      return result;
    })
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/nthRoot.js
var name41 = "nthRoot";
var dependencies41 = ["typed", "matrix", "equalScalar", "BigNumber", "concat"];
var createNthRoot = factory(name41, dependencies41, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    BigNumber: _BigNumber,
    concat: concat3
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo06xS0S0 = createMatAlgo06xS0S0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat3
  });
  function complexErr() {
    throw new Error("Complex number not supported in function nthRoot. Use nthRoots instead.");
  }
  return typed2(name41, {
    number: nthRootNumber,
    "number, number": nthRootNumber,
    BigNumber: (x) => _bigNthRoot(x, new _BigNumber(2)),
    "BigNumber, BigNumber": _bigNthRoot,
    Complex: complexErr,
    "Complex, number": complexErr,
    Array: typed2.referTo("DenseMatrix,number", (selfDn) => (x) => selfDn(matrix2(x), 2).valueOf()),
    DenseMatrix: typed2.referTo("DenseMatrix,number", (selfDn) => (x) => selfDn(x, 2)),
    SparseMatrix: typed2.referTo("SparseMatrix,number", (selfSn) => (x) => selfSn(x, 2)),
    "SparseMatrix, SparseMatrix": typed2.referToSelf((self) => (x, y) => {
      if (y.density() === 1) {
        return matAlgo06xS0S0(x, y, self);
      } else {
        throw new Error("Root must be non-zero");
      }
    }),
    "DenseMatrix, SparseMatrix": typed2.referToSelf((self) => (x, y) => {
      if (y.density() === 1) {
        return matAlgo01xDSid(x, y, self, false);
      } else {
        throw new Error("Root must be non-zero");
      }
    }),
    "Array, SparseMatrix": typed2.referTo("DenseMatrix,SparseMatrix", (selfDS) => (x, y) => selfDS(matrix2(x), y)),
    "number | BigNumber, SparseMatrix": typed2.referToSelf((self) => (x, y) => {
      if (y.density() === 1) {
        return matAlgo11xS0s(y, x, self, true);
      } else {
        throw new Error("Root must be non-zero");
      }
    })
  }, matrixAlgorithmSuite({
    scalar: "number | BigNumber",
    SD: matAlgo02xDS0,
    Ss: matAlgo11xS0s,
    sS: false
  }));
  function _bigNthRoot(a, root) {
    var precision = _BigNumber.precision;
    var Big = _BigNumber.clone({
      precision: precision + 2
    });
    var zero = new _BigNumber(0);
    var one = new Big(1);
    var inv2 = root.isNegative();
    if (inv2) {
      root = root.neg();
    }
    if (root.isZero()) {
      throw new Error("Root must be non-zero");
    }
    if (a.isNegative() && !root.abs().mod(2).equals(1)) {
      throw new Error("Root must be odd when a is negative.");
    }
    if (a.isZero()) {
      return inv2 ? new Big(Infinity) : 0;
    }
    if (!a.isFinite()) {
      return inv2 ? zero : a;
    }
    var x = a.abs().pow(one.div(root));
    x = a.isNeg() ? x.neg() : x;
    return new _BigNumber((inv2 ? one.div(x) : x).toPrecision(precision));
  }
});
var createNthRootNumber = factory(name41, ["typed"], (_ref2) => {
  var {
    typed: typed2
  } = _ref2;
  return typed2(name41, {
    number: nthRootNumber,
    "number, number": nthRootNumber
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/sign.js
var name42 = "sign";
var dependencies42 = ["typed", "BigNumber", "Fraction", "complex"];
var createSign = factory(name42, dependencies42, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber,
    complex: complex2,
    Fraction: _Fraction
  } = _ref;
  return typed2(name42, {
    number: signNumber,
    Complex: function Complex3(x) {
      return x.im === 0 ? complex2(signNumber(x.re)) : x.sign();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(x.cmp(0));
    },
    bigint: function bigint2(x) {
      return x > 0n ? 1n : x < 0n ? -1n : 0n;
    },
    Fraction: function Fraction3(x) {
      return new _Fraction(x.s);
    },
    // deep map collection, skip zeros since sign(0) = 0
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self, true)),
    Unit: typed2.referToSelf((self) => (x) => {
      if (!x._isDerived() && x.units[0].unit.offset !== 0) {
        throw new TypeError("sign is ambiguous for units with offset");
      }
      return typed2.find(self, x.valueType())(x.value);
    })
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/sqrt.js
var name43 = "sqrt";
var dependencies43 = ["config", "typed", "Complex"];
var createSqrt = factory(name43, dependencies43, (_ref) => {
  var {
    config: config2,
    typed: typed2,
    Complex: Complex3
  } = _ref;
  return typed2("sqrt", {
    number: _sqrtNumber,
    Complex: function Complex4(x) {
      return x.sqrt();
    },
    BigNumber: function BigNumber2(x) {
      if (!x.isNegative() || config2.predictable) {
        return x.sqrt();
      } else {
        return _sqrtNumber(x.toNumber());
      }
    },
    Unit: function Unit2(x) {
      return x.pow(0.5);
    }
  });
  function _sqrtNumber(x) {
    if (isNaN(x)) {
      return NaN;
    } else if (x >= 0 || config2.predictable) {
      return Math.sqrt(x);
    } else {
      return new Complex3(x, 0).sqrt();
    }
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/square.js
var name44 = "square";
var dependencies44 = ["typed"];
var createSquare = factory(name44, dependencies44, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name44, {
    number: squareNumber,
    Complex: function Complex3(x) {
      return x.mul(x);
    },
    BigNumber: function BigNumber2(x) {
      return x.times(x);
    },
    bigint: function bigint2(x) {
      return x * x;
    },
    Fraction: function Fraction3(x) {
      return x.mul(x);
    },
    Unit: function Unit2(x) {
      return x.pow(2);
    }
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/subtract.js
var name45 = "subtract";
var dependencies45 = ["typed", "matrix", "equalScalar", "subtractScalar", "unaryMinus", "DenseMatrix", "concat"];
var createSubtract = factory(name45, dependencies45, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    subtractScalar: subtractScalar2,
    unaryMinus: unaryMinus2,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo05xSfSf = createMatAlgo05xSfSf({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat3
  });
  return typed2(name45, {
    "any, any": subtractScalar2
  }, matrixAlgorithmSuite({
    elop: subtractScalar2,
    SS: matAlgo05xSfSf,
    DS: matAlgo01xDSid,
    SD: matAlgo03xDSf,
    Ss: matAlgo12xSfs,
    sS: matAlgo10xSids
  }));
});

// node_modules/mathjs/lib/esm/function/arithmetic/xgcd.js
var name46 = "xgcd";
var dependencies46 = ["typed", "config", "matrix", "BigNumber"];
var createXgcd = factory(name46, dependencies46, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    matrix: matrix2,
    BigNumber: BigNumber2
  } = _ref;
  return typed2(name46, {
    "number, number": function number_number(a, b) {
      var res = xgcdNumber(a, b);
      return config2.matrix === "Array" ? res : matrix2(res);
    },
    "BigNumber, BigNumber": _xgcdBigNumber
    // TODO: implement support for Fraction
  });
  function _xgcdBigNumber(a, b) {
    var t;
    var q;
    var r;
    var zero = new BigNumber2(0);
    var one = new BigNumber2(1);
    var x = zero;
    var lastx = one;
    var y = one;
    var lasty = zero;
    if (!a.isInt() || !b.isInt()) {
      throw new Error("Parameters in function xgcd must be integer numbers");
    }
    while (!b.isZero()) {
      q = a.div(b).floor();
      r = a.mod(b);
      t = x;
      x = lastx.minus(q.times(x));
      lastx = t;
      t = y;
      y = lasty.minus(q.times(y));
      lasty = t;
      a = b;
      b = r;
    }
    var res;
    if (a.lt(zero)) {
      res = [a.neg(), lastx.neg(), lasty.neg()];
    } else {
      res = [a, !a.isZero() ? lastx : 0, lasty];
    }
    return config2.matrix === "Array" ? res : matrix2(res);
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/invmod.js
var name47 = "invmod";
var dependencies47 = ["typed", "config", "BigNumber", "xgcd", "equal", "smaller", "mod", "add", "isInteger"];
var createInvmod = factory(name47, dependencies47, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    BigNumber: BigNumber2,
    xgcd: xgcd2,
    equal: equal2,
    smaller: smaller2,
    mod: mod2,
    add: add2,
    isInteger: isInteger3
  } = _ref;
  return typed2(name47, {
    "number, number": invmod2,
    "BigNumber, BigNumber": invmod2
  });
  function invmod2(a, b) {
    if (!isInteger3(a) || !isInteger3(b)) throw new Error("Parameters in function invmod must be integer numbers");
    a = mod2(a, b);
    if (equal2(b, 0)) throw new Error("Divisor must be non zero");
    var res = xgcd2(a, b);
    res = res.valueOf();
    var [gcd3, inv2] = res;
    if (!equal2(gcd3, BigNumber2(1))) return NaN;
    inv2 = mod2(inv2, b);
    if (smaller2(inv2, BigNumber2(0))) inv2 = add2(inv2, b);
    return inv2;
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo09xS0Sf.js
var name48 = "matAlgo09xS0Sf";
var dependencies48 = ["typed", "equalScalar"];
var createMatAlgo09xS0Sf = factory(name48, dependencies48, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2
  } = _ref;
  return function matAlgo09xS0Sf(a, b, callback) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar2;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
      dt = adt;
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = avalues && bvalues ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var x = cvalues ? [] : void 0;
    var w = [];
    var i2, j, k, k0, k1;
    for (j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      if (x) {
        for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          i2 = bindex[k];
          w[i2] = mark;
          x[i2] = bvalues[k];
        }
      }
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        i2 = aindex[k];
        if (x) {
          var vb = w[i2] === mark ? x[i2] : zero;
          var vc = cf(avalues[k], vb);
          if (!eq(vc, zero)) {
            cindex.push(i2);
            cvalues.push(vc);
          }
        } else {
          cindex.push(i2);
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
  };
});

// node_modules/mathjs/lib/esm/function/arithmetic/dotMultiply.js
var name49 = "dotMultiply";
var dependencies49 = ["typed", "matrix", "equalScalar", "multiplyScalar", "concat"];
var createDotMultiply = factory(name49, dependencies49, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    multiplyScalar: multiplyScalar2,
    concat: concat3
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo09xS0Sf = createMatAlgo09xS0Sf({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat3
  });
  return typed2(name49, matrixAlgorithmSuite({
    elop: multiplyScalar2,
    SS: matAlgo09xS0Sf,
    DS: matAlgo02xDS0,
    Ss: matAlgo11xS0s
  }));
});

// node_modules/mathjs/lib/esm/utils/bignumber/bitwise.js
function bitAndBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function bitAnd");
  }
  var BigNumber2 = x.constructor;
  if (x.isNaN() || y.isNaN()) {
    return new BigNumber2(NaN);
  }
  if (x.isZero() || y.eq(-1) || x.eq(y)) {
    return x;
  }
  if (y.isZero() || x.eq(-1)) {
    return y;
  }
  if (!x.isFinite() || !y.isFinite()) {
    if (!x.isFinite() && !y.isFinite()) {
      if (x.isNegative() === y.isNegative()) {
        return x;
      }
      return new BigNumber2(0);
    }
    if (!x.isFinite()) {
      if (y.isNegative()) {
        return x;
      }
      if (x.isNegative()) {
        return new BigNumber2(0);
      }
      return y;
    }
    if (!y.isFinite()) {
      if (x.isNegative()) {
        return y;
      }
      if (y.isNegative()) {
        return new BigNumber2(0);
      }
      return x;
    }
  }
  return bitwise(x, y, function(a, b) {
    return a & b;
  });
}
function bitNotBigNumber(x) {
  if (x.isFinite() && !x.isInteger()) {
    throw new Error("Integer expected in function bitNot");
  }
  var BigNumber2 = x.constructor;
  var prevPrec = BigNumber2.precision;
  BigNumber2.config({
    precision: 1e9
  });
  var result = x.plus(new BigNumber2(1));
  result.s = -result.s || null;
  BigNumber2.config({
    precision: prevPrec
  });
  return result;
}
function bitOrBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function bitOr");
  }
  var BigNumber2 = x.constructor;
  if (x.isNaN() || y.isNaN()) {
    return new BigNumber2(NaN);
  }
  var negOne = new BigNumber2(-1);
  if (x.isZero() || y.eq(negOne) || x.eq(y)) {
    return y;
  }
  if (y.isZero() || x.eq(negOne)) {
    return x;
  }
  if (!x.isFinite() || !y.isFinite()) {
    if (!x.isFinite() && !x.isNegative() && y.isNegative() || x.isNegative() && !y.isNegative() && !y.isFinite()) {
      return negOne;
    }
    if (x.isNegative() && y.isNegative()) {
      return x.isFinite() ? x : y;
    }
    return x.isFinite() ? y : x;
  }
  return bitwise(x, y, function(a, b) {
    return a | b;
  });
}
function bitwise(x, y, func) {
  var BigNumber2 = x.constructor;
  var xBits, yBits;
  var xSign = +(x.s < 0);
  var ySign = +(y.s < 0);
  if (xSign) {
    xBits = decCoefficientToBinaryString(bitNotBigNumber(x));
    for (var i2 = 0; i2 < xBits.length; ++i2) {
      xBits[i2] ^= 1;
    }
  } else {
    xBits = decCoefficientToBinaryString(x);
  }
  if (ySign) {
    yBits = decCoefficientToBinaryString(bitNotBigNumber(y));
    for (var _i = 0; _i < yBits.length; ++_i) {
      yBits[_i] ^= 1;
    }
  } else {
    yBits = decCoefficientToBinaryString(y);
  }
  var minBits, maxBits, minSign;
  if (xBits.length <= yBits.length) {
    minBits = xBits;
    maxBits = yBits;
    minSign = xSign;
  } else {
    minBits = yBits;
    maxBits = xBits;
    minSign = ySign;
  }
  var shortLen = minBits.length;
  var longLen = maxBits.length;
  var expFuncVal = func(xSign, ySign) ^ 1;
  var outVal = new BigNumber2(expFuncVal ^ 1);
  var twoPower = new BigNumber2(1);
  var two = new BigNumber2(2);
  var prevPrec = BigNumber2.precision;
  BigNumber2.config({
    precision: 1e9
  });
  while (shortLen > 0) {
    if (func(minBits[--shortLen], maxBits[--longLen]) === expFuncVal) {
      outVal = outVal.plus(twoPower);
    }
    twoPower = twoPower.times(two);
  }
  while (longLen > 0) {
    if (func(minSign, maxBits[--longLen]) === expFuncVal) {
      outVal = outVal.plus(twoPower);
    }
    twoPower = twoPower.times(two);
  }
  BigNumber2.config({
    precision: prevPrec
  });
  if (expFuncVal === 0) {
    outVal.s = -outVal.s;
  }
  return outVal;
}
function decCoefficientToBinaryString(x) {
  var a = x.d;
  var r = a[0] + "";
  for (var i2 = 1; i2 < a.length; ++i2) {
    var s = a[i2] + "";
    for (var z = 7 - s.length; z--; ) {
      s = "0" + s;
    }
    r += s;
  }
  var j = r.length;
  while (r.charAt(j) === "0") {
    j--;
  }
  var xe = x.e;
  var str = r.slice(0, j + 1 || 1);
  var strL = str.length;
  if (xe > 0) {
    if (++xe > strL) {
      xe -= strL;
      while (xe--) {
        str += "0";
      }
    } else if (xe < strL) {
      str = str.slice(0, xe) + "." + str.slice(xe);
    }
  }
  var arr = [0];
  for (var _i2 = 0; _i2 < str.length; ) {
    var arrL = arr.length;
    while (arrL--) {
      arr[arrL] *= 10;
    }
    arr[0] += parseInt(str.charAt(_i2++));
    for (var _j = 0; _j < arr.length; ++_j) {
      if (arr[_j] > 1) {
        if (arr[_j + 1] === null || arr[_j + 1] === void 0) {
          arr[_j + 1] = 0;
        }
        arr[_j + 1] += arr[_j] >> 1;
        arr[_j] &= 1;
      }
    }
  }
  return arr.reverse();
}
function bitXor(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function bitXor");
  }
  var BigNumber2 = x.constructor;
  if (x.isNaN() || y.isNaN()) {
    return new BigNumber2(NaN);
  }
  if (x.isZero()) {
    return y;
  }
  if (y.isZero()) {
    return x;
  }
  if (x.eq(y)) {
    return new BigNumber2(0);
  }
  var negOne = new BigNumber2(-1);
  if (x.eq(negOne)) {
    return bitNotBigNumber(y);
  }
  if (y.eq(negOne)) {
    return bitNotBigNumber(x);
  }
  if (!x.isFinite() || !y.isFinite()) {
    if (!x.isFinite() && !y.isFinite()) {
      return negOne;
    }
    return new BigNumber2(x.isNegative() === y.isNegative() ? Infinity : -Infinity);
  }
  return bitwise(x, y, function(a, b) {
    return a ^ b;
  });
}
function leftShiftBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function leftShift");
  }
  var BigNumber2 = x.constructor;
  if (x.isNaN() || y.isNaN() || y.isNegative() && !y.isZero()) {
    return new BigNumber2(NaN);
  }
  if (x.isZero() || y.isZero()) {
    return x;
  }
  if (!x.isFinite() && !y.isFinite()) {
    return new BigNumber2(NaN);
  }
  if (y.lt(55)) {
    return x.times(Math.pow(2, y.toNumber()) + "");
  }
  return x.times(new BigNumber2(2).pow(y));
}
function rightArithShiftBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function rightArithShift");
  }
  var BigNumber2 = x.constructor;
  if (x.isNaN() || y.isNaN() || y.isNegative() && !y.isZero()) {
    return new BigNumber2(NaN);
  }
  if (x.isZero() || y.isZero()) {
    return x;
  }
  if (!y.isFinite()) {
    if (x.isNegative()) {
      return new BigNumber2(-1);
    }
    if (!x.isFinite()) {
      return new BigNumber2(NaN);
    }
    return new BigNumber2(0);
  }
  if (y.lt(55)) {
    return x.div(Math.pow(2, y.toNumber()) + "").floor();
  }
  return x.div(new BigNumber2(2).pow(y)).floor();
}

// node_modules/mathjs/lib/esm/function/bitwise/bitAnd.js
var name50 = "bitAnd";
var dependencies50 = ["typed", "matrix", "equalScalar", "concat"];
var createBitAnd = factory(name50, dependencies50, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    concat: concat3
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo06xS0S0 = createMatAlgo06xS0S0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat3
  });
  return typed2(name50, {
    "number, number": bitAndNumber,
    "BigNumber, BigNumber": bitAndBigNumber,
    "bigint, bigint": (x, y) => x & y
  }, matrixAlgorithmSuite({
    SS: matAlgo06xS0S0,
    DS: matAlgo02xDS0,
    Ss: matAlgo11xS0s
  }));
});

// node_modules/mathjs/lib/esm/function/bitwise/bitNot.js
var name51 = "bitNot";
var dependencies51 = ["typed"];
var createBitNot = factory(name51, dependencies51, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name51, {
    number: bitNotNumber,
    BigNumber: bitNotBigNumber,
    bigint: (x) => ~x,
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self))
  });
});

// node_modules/mathjs/lib/esm/function/bitwise/bitOr.js
var name52 = "bitOr";
var dependencies52 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
var createBitOr = factory(name52, dependencies52, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo04xSidSid = createMatAlgo04xSidSid({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat3
  });
  return typed2(name52, {
    "number, number": bitOrNumber,
    "BigNumber, BigNumber": bitOrBigNumber,
    "bigint, bigint": (x, y) => x | y
  }, matrixAlgorithmSuite({
    SS: matAlgo04xSidSid,
    DS: matAlgo01xDSid,
    Ss: matAlgo10xSids
  }));
});

// node_modules/mathjs/lib/esm/function/bitwise/bitXor.js
var name53 = "bitXor";
var dependencies53 = ["typed", "matrix", "DenseMatrix", "concat", "SparseMatrix"];
var createBitXor = factory(name53, dependencies53, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2,
    concat: concat3,
    SparseMatrix: SparseMatrix2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    SparseMatrix: SparseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat3
  });
  return typed2(name53, {
    "number, number": bitXorNumber,
    "BigNumber, BigNumber": bitXor,
    "bigint, bigint": (x, y) => x ^ y
  }, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});

// node_modules/mathjs/lib/esm/function/complex/arg.js
var name54 = "arg";
var dependencies54 = ["typed"];
var createArg = factory(name54, dependencies54, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name54, {
    number: function number2(x) {
      return Math.atan2(0, x);
    },
    BigNumber: function BigNumber2(x) {
      return x.constructor.atan2(0, x);
    },
    Complex: function Complex3(x) {
      return x.arg();
    },
    // TODO: implement BigNumber support for function arg
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self))
  });
});

// node_modules/mathjs/lib/esm/function/complex/conj.js
var name55 = "conj";
var dependencies55 = ["typed"];
var createConj = factory(name55, dependencies55, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name55, {
    "number | BigNumber | Fraction": (x) => x,
    Complex: (x) => x.conjugate(),
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self))
  });
});

// node_modules/mathjs/lib/esm/function/complex/im.js
var name56 = "im";
var dependencies56 = ["typed"];
var createIm = factory(name56, dependencies56, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name56, {
    number: () => 0,
    "BigNumber | Fraction": (x) => x.mul(0),
    Complex: (x) => x.im,
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self))
  });
});

// node_modules/mathjs/lib/esm/function/complex/re.js
var name57 = "re";
var dependencies57 = ["typed"];
var createRe = factory(name57, dependencies57, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name57, {
    "number | BigNumber | Fraction": (x) => x,
    Complex: (x) => x.re,
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self))
  });
});

// node_modules/mathjs/lib/esm/function/logical/not.js
var name58 = "not";
var dependencies58 = ["typed"];
var createNot = factory(name58, dependencies58, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name58, {
    "null | undefined": () => true,
    number: notNumber,
    Complex: function Complex3(x) {
      return x.re === 0 && x.im === 0;
    },
    BigNumber: function BigNumber2(x) {
      return x.isZero() || x.isNaN();
    },
    bigint: (x) => !x,
    Unit: typed2.referToSelf((self) => (x) => typed2.find(self, x.valueType())(x.value)),
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self))
  });
});

// node_modules/mathjs/lib/esm/function/logical/or.js
var name59 = "or";
var dependencies59 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
var createOr = factory(name59, dependencies59, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo05xSfSf = createMatAlgo05xSfSf({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat3
  });
  return typed2(name59, {
    "number, number": orNumber,
    "Complex, Complex": function Complex_Complex(x, y) {
      return x.re !== 0 || x.im !== 0 || y.re !== 0 || y.im !== 0;
    },
    "BigNumber, BigNumber": function BigNumber_BigNumber(x, y) {
      return !x.isZero() && !x.isNaN() || !y.isZero() && !y.isNaN();
    },
    "bigint, bigint": orNumber,
    "Unit, Unit": typed2.referToSelf((self) => (x, y) => self(x.value || 0, y.value || 0))
  }, matrixAlgorithmSuite({
    SS: matAlgo05xSfSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});

// node_modules/mathjs/lib/esm/function/logical/xor.js
var name60 = "xor";
var dependencies60 = ["typed", "matrix", "DenseMatrix", "concat", "SparseMatrix"];
var createXor = factory(name60, dependencies60, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2,
    concat: concat3,
    SparseMatrix: SparseMatrix2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    SparseMatrix: SparseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat3
  });
  return typed2(name60, {
    "number, number": xorNumber,
    "Complex, Complex": function Complex_Complex(x, y) {
      return (x.re !== 0 || x.im !== 0) !== (y.re !== 0 || y.im !== 0);
    },
    "bigint, bigint": xorNumber,
    "BigNumber, BigNumber": function BigNumber_BigNumber(x, y) {
      return (!x.isZero() && !x.isNaN()) !== (!y.isZero() && !y.isNaN());
    },
    "Unit, Unit": typed2.referToSelf((self) => (x, y) => self(x.value || 0, y.value || 0))
  }, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});

// node_modules/mathjs/lib/esm/function/matrix/concat.js
var name61 = "concat";
var dependencies61 = ["typed", "matrix", "isInteger"];
var createConcat = factory(name61, dependencies61, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    isInteger: isInteger3
  } = _ref;
  return typed2(name61, {
    // TODO: change signature to '...Array | Matrix, dim?' when supported
    "...Array | Matrix | number | BigNumber": function Array__Matrix__number__BigNumber(args) {
      var i2;
      var len = args.length;
      var dim = -1;
      var prevDim;
      var asMatrix = false;
      var matrices = [];
      for (i2 = 0; i2 < len; i2++) {
        var arg2 = args[i2];
        if (isMatrix(arg2)) {
          asMatrix = true;
        }
        if (isNumber(arg2) || isBigNumber(arg2)) {
          if (i2 !== len - 1) {
            throw new Error("Dimension must be specified as last argument");
          }
          prevDim = dim;
          dim = arg2.valueOf();
          if (!isInteger3(dim)) {
            throw new TypeError("Integer number expected for dimension");
          }
          if (dim < 0 || i2 > 0 && dim > prevDim) {
            throw new IndexError(dim, prevDim + 1);
          }
        } else {
          var m = clone(arg2).valueOf();
          var size2 = arraySize(m);
          matrices[i2] = m;
          prevDim = dim;
          dim = size2.length - 1;
          if (i2 > 0 && dim !== prevDim) {
            throw new DimensionError(prevDim + 1, dim + 1);
          }
        }
      }
      if (matrices.length === 0) {
        throw new SyntaxError("At least one matrix expected");
      }
      var res = matrices.shift();
      while (matrices.length) {
        res = concat(res, matrices.shift(), dim);
      }
      return asMatrix ? matrix2(res) : res;
    },
    "...string": function string2(args) {
      return args.join("");
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/column.js
var name62 = "column";
var dependencies62 = ["typed", "Index", "matrix", "range"];
var createColumn = factory(name62, dependencies62, (_ref) => {
  var {
    typed: typed2,
    Index: Index2,
    matrix: matrix2,
    range: range2
  } = _ref;
  return typed2(name62, {
    "Matrix, number": _column,
    "Array, number": function Array_number(value, column2) {
      return _column(matrix2(clone(value)), column2).valueOf();
    }
  });
  function _column(value, column2) {
    if (value.size().length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(column2, value.size()[1]);
    var rowRange = range2(0, value.size()[0]);
    var index2 = new Index2(rowRange, column2);
    var result = value.subset(index2);
    return isMatrix(result) ? result : matrix2([[result]]);
  }
});

// node_modules/mathjs/lib/esm/function/matrix/count.js
var name63 = "count";
var dependencies63 = ["typed", "size", "prod"];
var createCount = factory(name63, dependencies63, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    prod: prod2
  } = _ref;
  return typed2(name63, {
    string: function string2(x) {
      return x.length;
    },
    "Matrix | Array": function Matrix__Array(x) {
      return prod2(size2(x));
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/cross.js
var name64 = "cross";
var dependencies64 = ["typed", "matrix", "subtract", "multiply"];
var createCross = factory(name64, dependencies64, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    subtract: subtract2,
    multiply: multiply2
  } = _ref;
  return typed2(name64, {
    "Matrix, Matrix": function Matrix_Matrix(x, y) {
      return matrix2(_cross(x.toArray(), y.toArray()));
    },
    "Matrix, Array": function Matrix_Array(x, y) {
      return matrix2(_cross(x.toArray(), y));
    },
    "Array, Matrix": function Array_Matrix(x, y) {
      return matrix2(_cross(x, y.toArray()));
    },
    "Array, Array": _cross
  });
  function _cross(x, y) {
    var highestDimension = Math.max(arraySize(x).length, arraySize(y).length);
    x = squeeze(x);
    y = squeeze(y);
    var xSize = arraySize(x);
    var ySize = arraySize(y);
    if (xSize.length !== 1 || ySize.length !== 1 || xSize[0] !== 3 || ySize[0] !== 3) {
      throw new RangeError("Vectors with length 3 expected (Size A = [" + xSize.join(", ") + "], B = [" + ySize.join(", ") + "])");
    }
    var product = [subtract2(multiply2(x[1], y[2]), multiply2(x[2], y[1])), subtract2(multiply2(x[2], y[0]), multiply2(x[0], y[2])), subtract2(multiply2(x[0], y[1]), multiply2(x[1], y[0]))];
    if (highestDimension > 1) {
      return [product];
    } else {
      return product;
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/diag.js
var name65 = "diag";
var dependencies65 = ["typed", "matrix", "DenseMatrix", "SparseMatrix"];
var createDiag = factory(name65, dependencies65, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix: SparseMatrix2
  } = _ref;
  return typed2(name65, {
    // FIXME: simplify this huge amount of signatures as soon as typed-function supports optional arguments
    Array: function Array2(x) {
      return _diag(x, 0, arraySize(x), null);
    },
    "Array, number": function Array_number(x, k) {
      return _diag(x, k, arraySize(x), null);
    },
    "Array, BigNumber": function Array_BigNumber(x, k) {
      return _diag(x, k.toNumber(), arraySize(x), null);
    },
    "Array, string": function Array_string(x, format4) {
      return _diag(x, 0, arraySize(x), format4);
    },
    "Array, number, string": function Array_number_string(x, k, format4) {
      return _diag(x, k, arraySize(x), format4);
    },
    "Array, BigNumber, string": function Array_BigNumber_string(x, k, format4) {
      return _diag(x, k.toNumber(), arraySize(x), format4);
    },
    Matrix: function Matrix2(x) {
      return _diag(x, 0, x.size(), x.storage());
    },
    "Matrix, number": function Matrix_number(x, k) {
      return _diag(x, k, x.size(), x.storage());
    },
    "Matrix, BigNumber": function Matrix_BigNumber(x, k) {
      return _diag(x, k.toNumber(), x.size(), x.storage());
    },
    "Matrix, string": function Matrix_string(x, format4) {
      return _diag(x, 0, x.size(), format4);
    },
    "Matrix, number, string": function Matrix_number_string(x, k, format4) {
      return _diag(x, k, x.size(), format4);
    },
    "Matrix, BigNumber, string": function Matrix_BigNumber_string(x, k, format4) {
      return _diag(x, k.toNumber(), x.size(), format4);
    }
  });
  function _diag(x, k, size2, format4) {
    if (!isInteger(k)) {
      throw new TypeError("Second parameter in function diag must be an integer");
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    switch (size2.length) {
      case 1:
        return _createDiagonalMatrix(x, k, format4, size2[0], kSub, kSuper);
      case 2:
        return _getDiagonal(x, k, format4, size2, kSub, kSuper);
    }
    throw new RangeError("Matrix for function diag must be 2 dimensional");
  }
  function _createDiagonalMatrix(x, k, format4, l, kSub, kSuper) {
    var ms = [l + kSub, l + kSuper];
    if (format4 && format4 !== "sparse" && format4 !== "dense") {
      throw new TypeError("Unknown matrix type ".concat(format4, '"'));
    }
    var m = format4 === "sparse" ? SparseMatrix2.diagonal(ms, x, k) : DenseMatrix2.diagonal(ms, x, k);
    return format4 !== null ? m : m.valueOf();
  }
  function _getDiagonal(x, k, format4, s, kSub, kSuper) {
    if (isMatrix(x)) {
      var dm = x.diagonal(k);
      if (format4 !== null) {
        if (format4 !== dm.storage()) {
          return matrix2(dm, format4);
        }
        return dm;
      }
      return dm.valueOf();
    }
    var n = Math.min(s[0] - kSub, s[1] - kSuper);
    var vector = [];
    for (var i2 = 0; i2 < n; i2++) {
      vector[i2] = x[i2 + kSub][i2 + kSuper];
    }
    return format4 !== null ? matrix2(vector) : vector;
  }
});

// node_modules/mathjs/lib/esm/function/matrix/flatten.js
var name66 = "flatten";
var dependencies66 = ["typed"];
var createFlatten = factory(name66, dependencies66, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name66, {
    Array: function Array2(x) {
      return flatten(x);
    },
    Matrix: function Matrix2(x) {
      return x.create(flatten(x.valueOf(), true), x.datatype());
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/getMatrixDataType.js
var name67 = "getMatrixDataType";
var dependencies67 = ["typed"];
var createGetMatrixDataType = factory(name67, dependencies67, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name67, {
    Array: function Array2(x) {
      return getArrayDataType(x, typeOf);
    },
    Matrix: function Matrix2(x) {
      return x.getDataType();
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/identity.js
var name68 = "identity";
var dependencies68 = ["typed", "config", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix"];
var createIdentity = factory(name68, dependencies68, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    matrix: matrix2,
    BigNumber: BigNumber2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix: SparseMatrix2
  } = _ref;
  return typed2(name68, {
    "": function _() {
      return config2.matrix === "Matrix" ? matrix2([]) : [];
    },
    string: function string2(format4) {
      return matrix2(format4);
    },
    "number | BigNumber": function number__BigNumber(rows) {
      return _identity(rows, rows, config2.matrix === "Matrix" ? "dense" : void 0);
    },
    "number | BigNumber, string": function number__BigNumber_string(rows, format4) {
      return _identity(rows, rows, format4);
    },
    "number | BigNumber, number | BigNumber": function number__BigNumber_number__BigNumber(rows, cols) {
      return _identity(rows, cols, config2.matrix === "Matrix" ? "dense" : void 0);
    },
    "number | BigNumber, number | BigNumber, string": function number__BigNumber_number__BigNumber_string(rows, cols, format4) {
      return _identity(rows, cols, format4);
    },
    Array: function Array2(size2) {
      return _identityVector(size2);
    },
    "Array, string": function Array_string(size2, format4) {
      return _identityVector(size2, format4);
    },
    Matrix: function Matrix2(size2) {
      return _identityVector(size2.valueOf(), size2.storage());
    },
    "Matrix, string": function Matrix_string(size2, format4) {
      return _identityVector(size2.valueOf(), format4);
    }
  });
  function _identityVector(size2, format4) {
    switch (size2.length) {
      case 0:
        return format4 ? matrix2(format4) : [];
      case 1:
        return _identity(size2[0], size2[0], format4);
      case 2:
        return _identity(size2[0], size2[1], format4);
      default:
        throw new Error("Vector containing two values expected");
    }
  }
  function _identity(rows, cols, format4) {
    var Big = isBigNumber(rows) || isBigNumber(cols) ? BigNumber2 : null;
    if (isBigNumber(rows)) rows = rows.toNumber();
    if (isBigNumber(cols)) cols = cols.toNumber();
    if (!isInteger(rows) || rows < 1) {
      throw new Error("Parameters in function identity must be positive integers");
    }
    if (!isInteger(cols) || cols < 1) {
      throw new Error("Parameters in function identity must be positive integers");
    }
    var one = Big ? new BigNumber2(1) : 1;
    var defaultValue = Big ? new Big(0) : 0;
    var size2 = [rows, cols];
    if (format4) {
      if (format4 === "sparse") {
        return SparseMatrix2.diagonal(size2, one, 0, defaultValue);
      }
      if (format4 === "dense") {
        return DenseMatrix2.diagonal(size2, one, 0, defaultValue);
      }
      throw new TypeError('Unknown matrix type "'.concat(format4, '"'));
    }
    var res = resize([], size2, defaultValue);
    var minimum = rows < cols ? rows : cols;
    for (var d = 0; d < minimum; d++) {
      res[d][d] = one;
    }
    return res;
  }
});

// node_modules/mathjs/lib/esm/function/matrix/kron.js
var name69 = "kron";
var dependencies69 = ["typed", "matrix", "multiplyScalar"];
var createKron = factory(name69, dependencies69, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    multiplyScalar: multiplyScalar2
  } = _ref;
  return typed2(name69, {
    "Matrix, Matrix": function Matrix_Matrix(x, y) {
      return matrix2(_kron(x.toArray(), y.toArray()));
    },
    "Matrix, Array": function Matrix_Array(x, y) {
      return matrix2(_kron(x.toArray(), y));
    },
    "Array, Matrix": function Array_Matrix(x, y) {
      return matrix2(_kron(x, y.toArray()));
    },
    "Array, Array": _kron
  });
  function _kron(a, b) {
    if (arraySize(a).length === 1) {
      a = [a];
    }
    if (arraySize(b).length === 1) {
      b = [b];
    }
    if (arraySize(a).length > 2 || arraySize(b).length > 2) {
      throw new RangeError("Vectors with dimensions greater then 2 are not supported expected (Size x = " + JSON.stringify(a.length) + ", y = " + JSON.stringify(b.length) + ")");
    }
    var t = [];
    var r = [];
    return a.map(function(a2) {
      return b.map(function(b2) {
        r = [];
        t.push(r);
        return a2.map(function(y) {
          return b2.map(function(x) {
            return r.push(multiplyScalar2(y, x));
          });
        });
      });
    }) && t;
  }
});

// node_modules/mathjs/lib/esm/function/matrix/diff.js
var name70 = "diff";
var dependencies70 = ["typed", "matrix", "subtract", "number"];
var createDiff = factory(name70, dependencies70, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    subtract: subtract2,
    number: number2
  } = _ref;
  return typed2(name70, {
    "Array | Matrix": function Array__Matrix(arr) {
      if (isMatrix(arr)) {
        return matrix2(_diff(arr.toArray()));
      } else {
        return _diff(arr);
      }
    },
    "Array | Matrix, number": function Array__Matrix_number(arr, dim) {
      if (!isInteger(dim)) throw new RangeError("Dimension must be a whole number");
      if (isMatrix(arr)) {
        return matrix2(_recursive(arr.toArray(), dim));
      } else {
        return _recursive(arr, dim);
      }
    },
    "Array, BigNumber": typed2.referTo("Array,number", (selfAn) => (arr, dim) => selfAn(arr, number2(dim))),
    "Matrix, BigNumber": typed2.referTo("Matrix,number", (selfMn) => (arr, dim) => selfMn(arr, number2(dim)))
  });
  function _recursive(arr, dim) {
    if (isMatrix(arr)) {
      arr = arr.toArray();
    }
    if (!Array.isArray(arr)) {
      throw RangeError("Array/Matrix does not have that many dimensions");
    }
    if (dim > 0) {
      var result = [];
      arr.forEach((element) => {
        result.push(_recursive(element, dim - 1));
      });
      return result;
    } else if (dim === 0) {
      return _diff(arr);
    } else {
      throw RangeError("Cannot have negative dimension");
    }
  }
  function _diff(arr) {
    var result = [];
    var size2 = arr.length;
    for (var i2 = 1; i2 < size2; i2++) {
      result.push(_ElementDiff(arr[i2 - 1], arr[i2]));
    }
    return result;
  }
  function _ElementDiff(obj1, obj2) {
    if (isMatrix(obj1)) obj1 = obj1.toArray();
    if (isMatrix(obj2)) obj2 = obj2.toArray();
    var obj1IsArray = Array.isArray(obj1);
    var obj2IsArray = Array.isArray(obj2);
    if (obj1IsArray && obj2IsArray) {
      return _ArrayDiff(obj1, obj2);
    }
    if (!obj1IsArray && !obj2IsArray) {
      return subtract2(obj2, obj1);
    }
    throw TypeError("Cannot calculate difference between 1 array and 1 non-array");
  }
  function _ArrayDiff(arr1, arr2) {
    if (arr1.length !== arr2.length) {
      throw RangeError("Not all sub-arrays have the same length");
    }
    var result = [];
    var size2 = arr1.length;
    for (var i2 = 0; i2 < size2; i2++) {
      result.push(_ElementDiff(arr1[i2], arr2[i2]));
    }
    return result;
  }
});

// node_modules/mathjs/lib/esm/function/matrix/ones.js
var name71 = "ones";
var dependencies71 = ["typed", "config", "matrix", "BigNumber"];
var createOnes = factory(name71, dependencies71, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    matrix: matrix2,
    BigNumber: BigNumber2
  } = _ref;
  return typed2("ones", {
    "": function _() {
      return config2.matrix === "Array" ? _ones([]) : _ones([], "default");
    },
    // math.ones(m, n, p, ..., format)
    // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
    "...number | BigNumber | string": function number__BigNumber__string(size2) {
      var last = size2[size2.length - 1];
      if (typeof last === "string") {
        var format4 = size2.pop();
        return _ones(size2, format4);
      } else if (config2.matrix === "Array") {
        return _ones(size2);
      } else {
        return _ones(size2, "default");
      }
    },
    Array: _ones,
    Matrix: function Matrix2(size2) {
      var format4 = size2.storage();
      return _ones(size2.valueOf(), format4);
    },
    "Array | Matrix, string": function Array__Matrix_string(size2, format4) {
      return _ones(size2.valueOf(), format4);
    }
  });
  function _ones(size2, format4) {
    var hasBigNumbers = _normalize(size2);
    var defaultValue = hasBigNumbers ? new BigNumber2(1) : 1;
    _validate(size2);
    if (format4) {
      var m = matrix2(format4);
      if (size2.length > 0) {
        return m.resize(size2, defaultValue);
      }
      return m;
    } else {
      var arr = [];
      if (size2.length > 0) {
        return resize(arr, size2, defaultValue);
      }
      return arr;
    }
  }
  function _normalize(size2) {
    var hasBigNumbers = false;
    size2.forEach(function(value, index2, arr) {
      if (isBigNumber(value)) {
        hasBigNumbers = true;
        arr[index2] = value.toNumber();
      }
    });
    return hasBigNumbers;
  }
  function _validate(size2) {
    size2.forEach(function(value) {
      if (typeof value !== "number" || !isInteger(value) || value < 0) {
        throw new Error("Parameters in function ones must be positive integers");
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/reshape.js
var name72 = "reshape";
var dependencies72 = ["typed", "isInteger", "matrix"];
var createReshape = factory(name72, dependencies72, (_ref) => {
  var {
    typed: typed2,
    isInteger: isInteger3
  } = _ref;
  return typed2(name72, {
    "Matrix, Array": function Matrix_Array(x, sizes) {
      return x.reshape(sizes, true);
    },
    "Array, Array": function Array_Array(x, sizes) {
      sizes.forEach(function(size2) {
        if (!isInteger3(size2)) {
          throw new TypeError("Invalid size for dimension: " + size2);
        }
      });
      return reshape(x, sizes);
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/resize.js
var name73 = "resize";
var dependencies73 = ["config", "matrix"];
var createResize = factory(name73, dependencies73, (_ref) => {
  var {
    config: config2,
    matrix: matrix2
  } = _ref;
  return function resize3(x, size2, defaultValue) {
    if (arguments.length !== 2 && arguments.length !== 3) {
      throw new ArgumentsError("resize", arguments.length, 2, 3);
    }
    if (isMatrix(size2)) {
      size2 = size2.valueOf();
    }
    if (isBigNumber(size2[0])) {
      size2 = size2.map(function(value) {
        return !isBigNumber(value) ? value : value.toNumber();
      });
    }
    if (isMatrix(x)) {
      return x.resize(size2, defaultValue, true);
    }
    if (typeof x === "string") {
      return _resizeString(x, size2, defaultValue);
    }
    var asMatrix = Array.isArray(x) ? false : config2.matrix !== "Array";
    if (size2.length === 0) {
      while (Array.isArray(x)) {
        x = x[0];
      }
      return clone(x);
    } else {
      if (!Array.isArray(x)) {
        x = [x];
      }
      x = clone(x);
      var res = resize(x, size2, defaultValue);
      return asMatrix ? matrix2(res) : res;
    }
  };
  function _resizeString(str, size2, defaultChar) {
    if (defaultChar !== void 0) {
      if (typeof defaultChar !== "string" || defaultChar.length !== 1) {
        throw new TypeError("Single character expected as defaultValue");
      }
    } else {
      defaultChar = " ";
    }
    if (size2.length !== 1) {
      throw new DimensionError(size2.length, 1);
    }
    var len = size2[0];
    if (typeof len !== "number" || !isInteger(len)) {
      throw new TypeError("Invalid size, must contain positive integers (size: " + format2(size2) + ")");
    }
    if (str.length > len) {
      return str.substring(0, len);
    } else if (str.length < len) {
      var res = str;
      for (var i2 = 0, ii = len - str.length; i2 < ii; i2++) {
        res += defaultChar;
      }
      return res;
    } else {
      return str;
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/rotate.js
var name74 = "rotate";
var dependencies74 = ["typed", "multiply", "rotationMatrix"];
var createRotate = factory(name74, dependencies74, (_ref) => {
  var {
    typed: typed2,
    multiply: multiply2,
    rotationMatrix: rotationMatrix2
  } = _ref;
  return typed2(name74, {
    "Array , number | BigNumber | Complex | Unit": function Array__number__BigNumber__Complex__Unit(w, theta) {
      _validateSize(w, 2);
      var matrixRes = multiply2(rotationMatrix2(theta), w);
      return matrixRes.toArray();
    },
    "Matrix , number | BigNumber | Complex | Unit": function Matrix__number__BigNumber__Complex__Unit(w, theta) {
      _validateSize(w, 2);
      return multiply2(rotationMatrix2(theta), w);
    },
    "Array, number | BigNumber | Complex | Unit, Array | Matrix": function Array_number__BigNumber__Complex__Unit_Array__Matrix(w, theta, v) {
      _validateSize(w, 3);
      var matrixRes = multiply2(rotationMatrix2(theta, v), w);
      return matrixRes;
    },
    "Matrix, number | BigNumber | Complex | Unit, Array | Matrix": function Matrix_number__BigNumber__Complex__Unit_Array__Matrix(w, theta, v) {
      _validateSize(w, 3);
      return multiply2(rotationMatrix2(theta, v), w);
    }
  });
  function _validateSize(v, expectedSize) {
    var actualSize = Array.isArray(v) ? arraySize(v) : v.size();
    if (actualSize.length > 2) {
      throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
    }
    if (actualSize.length === 2 && actualSize[1] !== 1) {
      throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
    }
    if (actualSize[0] !== expectedSize) {
      throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/rotationMatrix.js
var name75 = "rotationMatrix";
var dependencies75 = ["typed", "config", "multiplyScalar", "addScalar", "unaryMinus", "norm", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix", "cos", "sin"];
var createRotationMatrix = factory(name75, dependencies75, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    multiplyScalar: multiplyScalar2,
    addScalar: addScalar2,
    unaryMinus: unaryMinus2,
    norm: norm2,
    BigNumber: BigNumber2,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix: SparseMatrix2,
    cos: cos2,
    sin: sin2
  } = _ref;
  return typed2(name75, {
    "": function _() {
      return config2.matrix === "Matrix" ? matrix2([]) : [];
    },
    string: function string2(format4) {
      return matrix2(format4);
    },
    "number | BigNumber | Complex | Unit": function number__BigNumber__Complex__Unit(theta) {
      return _rotationMatrix2x2(theta, config2.matrix === "Matrix" ? "dense" : void 0);
    },
    "number | BigNumber | Complex | Unit, string": function number__BigNumber__Complex__Unit_string(theta, format4) {
      return _rotationMatrix2x2(theta, format4);
    },
    "number | BigNumber | Complex | Unit, Array": function number__BigNumber__Complex__Unit_Array(theta, v) {
      var matrixV = matrix2(v);
      _validateVector(matrixV);
      return _rotationMatrix3x3(theta, matrixV, void 0);
    },
    "number | BigNumber | Complex | Unit, Matrix": function number__BigNumber__Complex__Unit_Matrix(theta, v) {
      _validateVector(v);
      var storageType = v.storage() || (config2.matrix === "Matrix" ? "dense" : void 0);
      return _rotationMatrix3x3(theta, v, storageType);
    },
    "number | BigNumber | Complex | Unit, Array, string": function number__BigNumber__Complex__Unit_Array_string(theta, v, format4) {
      var matrixV = matrix2(v);
      _validateVector(matrixV);
      return _rotationMatrix3x3(theta, matrixV, format4);
    },
    "number | BigNumber | Complex | Unit, Matrix, string": function number__BigNumber__Complex__Unit_Matrix_string(theta, v, format4) {
      _validateVector(v);
      return _rotationMatrix3x3(theta, v, format4);
    }
  });
  function _rotationMatrix2x2(theta, format4) {
    var Big = isBigNumber(theta);
    var minusOne = Big ? new BigNumber2(-1) : -1;
    var cosTheta = cos2(theta);
    var sinTheta = sin2(theta);
    var data = [[cosTheta, multiplyScalar2(minusOne, sinTheta)], [sinTheta, cosTheta]];
    return _convertToFormat(data, format4);
  }
  function _validateVector(v) {
    var size2 = v.size();
    if (size2.length < 1 || size2[0] !== 3) {
      throw new RangeError("Vector must be of dimensions 1x3");
    }
  }
  function _mul(array) {
    return array.reduce((p, curr) => multiplyScalar2(p, curr));
  }
  function _convertToFormat(data, format4) {
    if (format4) {
      if (format4 === "sparse") {
        return new SparseMatrix2(data);
      }
      if (format4 === "dense") {
        return new DenseMatrix2(data);
      }
      throw new TypeError('Unknown matrix type "'.concat(format4, '"'));
    }
    return data;
  }
  function _rotationMatrix3x3(theta, v, format4) {
    var normV = norm2(v);
    if (normV === 0) {
      throw new RangeError("Rotation around zero vector");
    }
    var Big = isBigNumber(theta) ? BigNumber2 : null;
    var one = Big ? new Big(1) : 1;
    var minusOne = Big ? new Big(-1) : -1;
    var vx = Big ? new Big(v.get([0]) / normV) : v.get([0]) / normV;
    var vy = Big ? new Big(v.get([1]) / normV) : v.get([1]) / normV;
    var vz = Big ? new Big(v.get([2]) / normV) : v.get([2]) / normV;
    var c = cos2(theta);
    var oneMinusC = addScalar2(one, unaryMinus2(c));
    var s = sin2(theta);
    var r11 = addScalar2(c, _mul([vx, vx, oneMinusC]));
    var r12 = addScalar2(_mul([vx, vy, oneMinusC]), _mul([minusOne, vz, s]));
    var r13 = addScalar2(_mul([vx, vz, oneMinusC]), _mul([vy, s]));
    var r21 = addScalar2(_mul([vx, vy, oneMinusC]), _mul([vz, s]));
    var r22 = addScalar2(c, _mul([vy, vy, oneMinusC]));
    var r23 = addScalar2(_mul([vy, vz, oneMinusC]), _mul([minusOne, vx, s]));
    var r31 = addScalar2(_mul([vx, vz, oneMinusC]), _mul([minusOne, vy, s]));
    var r32 = addScalar2(_mul([vy, vz, oneMinusC]), _mul([vx, s]));
    var r33 = addScalar2(c, _mul([vz, vz, oneMinusC]));
    var data = [[r11, r12, r13], [r21, r22, r23], [r31, r32, r33]];
    return _convertToFormat(data, format4);
  }
});

// node_modules/mathjs/lib/esm/function/matrix/row.js
var name76 = "row";
var dependencies76 = ["typed", "Index", "matrix", "range"];
var createRow = factory(name76, dependencies76, (_ref) => {
  var {
    typed: typed2,
    Index: Index2,
    matrix: matrix2,
    range: range2
  } = _ref;
  return typed2(name76, {
    "Matrix, number": _row,
    "Array, number": function Array_number(value, row2) {
      return _row(matrix2(clone(value)), row2).valueOf();
    }
  });
  function _row(value, row2) {
    if (value.size().length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(row2, value.size()[0]);
    var columnRange = range2(0, value.size()[1]);
    var index2 = new Index2(row2, columnRange);
    var result = value.subset(index2);
    return isMatrix(result) ? result : matrix2([[result]]);
  }
});

// node_modules/mathjs/lib/esm/function/matrix/squeeze.js
var name77 = "squeeze";
var dependencies77 = ["typed"];
var createSqueeze = factory(name77, dependencies77, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name77, {
    Array: function Array2(x) {
      return squeeze(clone(x));
    },
    Matrix: function Matrix2(x) {
      var res = squeeze(x.toArray());
      return Array.isArray(res) ? x.create(res, x.datatype()) : res;
    },
    any: function any(x) {
      return clone(x);
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/subset.js
var name78 = "subset";
var dependencies78 = ["typed", "matrix", "zeros", "add"];
var createSubset = factory(name78, dependencies78, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    zeros: zeros2,
    add: add2
  } = _ref;
  return typed2(name78, {
    // get subset
    "Matrix, Index": function Matrix_Index(value, index2) {
      if (isEmptyIndex(index2)) {
        return matrix2();
      }
      validateIndexSourceSize(value, index2);
      return value.subset(index2);
    },
    "Array, Index": typed2.referTo("Matrix, Index", function(subsetRef) {
      return function(value, index2) {
        var subsetResult = subsetRef(matrix2(value), index2);
        return index2.isScalar() ? subsetResult : subsetResult.valueOf();
      };
    }),
    "Object, Index": _getObjectProperty,
    "string, Index": _getSubstring,
    // set subset
    "Matrix, Index, any, any": function Matrix_Index_any_any(value, index2, replacement, defaultValue) {
      if (isEmptyIndex(index2)) {
        return value;
      }
      validateIndexSourceSize(value, index2);
      return value.clone().subset(index2, _broadcastReplacement(replacement, index2), defaultValue);
    },
    "Array, Index, any, any": typed2.referTo("Matrix, Index, any, any", function(subsetRef) {
      return function(value, index2, replacement, defaultValue) {
        var subsetResult = subsetRef(matrix2(value), index2, replacement, defaultValue);
        return subsetResult.isMatrix ? subsetResult.valueOf() : subsetResult;
      };
    }),
    "Array, Index, any": typed2.referTo("Matrix, Index, any, any", function(subsetRef) {
      return function(value, index2, replacement) {
        return subsetRef(matrix2(value), index2, replacement, void 0).valueOf();
      };
    }),
    "Matrix, Index, any": typed2.referTo("Matrix, Index, any, any", function(subsetRef) {
      return function(value, index2, replacement) {
        return subsetRef(value, index2, replacement, void 0);
      };
    }),
    "string, Index, string": _setSubstring,
    "string, Index, string, string": _setSubstring,
    "Object, Index, any": _setObjectProperty
  });
  function _broadcastReplacement(replacement, index2) {
    if (typeof replacement === "string") {
      throw new Error("can't boradcast a string");
    }
    if (index2._isScalar) {
      return replacement;
    }
    var indexSize = index2.size();
    if (indexSize.every((d) => d > 0)) {
      try {
        return add2(replacement, zeros2(indexSize));
      } catch (error) {
        return replacement;
      }
    } else {
      return replacement;
    }
  }
});
function _getSubstring(str, index2) {
  if (!isIndex(index2)) {
    throw new TypeError("Index expected");
  }
  if (isEmptyIndex(index2)) {
    return "";
  }
  validateIndexSourceSize(Array.from(str), index2);
  if (index2.size().length !== 1) {
    throw new DimensionError(index2.size().length, 1);
  }
  var strLen = str.length;
  validateIndex(index2.min()[0], strLen);
  validateIndex(index2.max()[0], strLen);
  var range2 = index2.dimension(0);
  var substr = "";
  range2.forEach(function(v) {
    substr += str.charAt(v);
  });
  return substr;
}
function _setSubstring(str, index2, replacement, defaultValue) {
  if (!index2 || index2.isIndex !== true) {
    throw new TypeError("Index expected");
  }
  if (isEmptyIndex(index2)) {
    return str;
  }
  validateIndexSourceSize(Array.from(str), index2);
  if (index2.size().length !== 1) {
    throw new DimensionError(index2.size().length, 1);
  }
  if (defaultValue !== void 0) {
    if (typeof defaultValue !== "string" || defaultValue.length !== 1) {
      throw new TypeError("Single character expected as defaultValue");
    }
  } else {
    defaultValue = " ";
  }
  var range2 = index2.dimension(0);
  var len = range2.size()[0];
  if (len !== replacement.length) {
    throw new DimensionError(range2.size()[0], replacement.length);
  }
  var strLen = str.length;
  validateIndex(index2.min()[0]);
  validateIndex(index2.max()[0]);
  var chars = [];
  for (var i2 = 0; i2 < strLen; i2++) {
    chars[i2] = str.charAt(i2);
  }
  range2.forEach(function(v, i3) {
    chars[v] = replacement.charAt(i3[0]);
  });
  if (chars.length > strLen) {
    for (var _i = strLen - 1, _len = chars.length; _i < _len; _i++) {
      if (!chars[_i]) {
        chars[_i] = defaultValue;
      }
    }
  }
  return chars.join("");
}
function _getObjectProperty(object, index2) {
  if (isEmptyIndex(index2)) {
    return void 0;
  }
  if (index2.size().length !== 1) {
    throw new DimensionError(index2.size(), 1);
  }
  var key = index2.dimension(0);
  if (typeof key !== "string") {
    throw new TypeError("String expected as index to retrieve an object property");
  }
  return getSafeProperty(object, key);
}
function _setObjectProperty(object, index2, replacement) {
  if (isEmptyIndex(index2)) {
    return object;
  }
  if (index2.size().length !== 1) {
    throw new DimensionError(index2.size(), 1);
  }
  var key = index2.dimension(0);
  if (typeof key !== "string") {
    throw new TypeError("String expected as index to retrieve an object property");
  }
  var updated = clone(object);
  setSafeProperty(updated, key, replacement);
  return updated;
}

// node_modules/mathjs/lib/esm/function/matrix/transpose.js
var name79 = "transpose";
var dependencies79 = ["typed", "matrix"];
var createTranspose = factory(name79, dependencies79, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2
  } = _ref;
  return typed2(name79, {
    Array: (x) => transposeMatrix(matrix2(x)).valueOf(),
    Matrix: transposeMatrix,
    any: clone
    // scalars
  });
  function transposeMatrix(x) {
    var size2 = x.size();
    var c;
    switch (size2.length) {
      case 1:
        c = x.clone();
        break;
      case 2:
        {
          var rows = size2[0];
          var columns = size2[1];
          if (columns === 0) {
            throw new RangeError("Cannot transpose a 2D matrix with no columns (size: " + format2(size2) + ")");
          }
          switch (x.storage()) {
            case "dense":
              c = _denseTranspose(x, rows, columns);
              break;
            case "sparse":
              c = _sparseTranspose(x, rows, columns);
              break;
          }
        }
        break;
      default:
        throw new RangeError("Matrix must be a vector or two dimensional (size: " + format2(size2) + ")");
    }
    return c;
  }
  function _denseTranspose(m, rows, columns) {
    var data = m._data;
    var transposed = [];
    var transposedRow;
    for (var j = 0; j < columns; j++) {
      transposedRow = transposed[j] = [];
      for (var i2 = 0; i2 < rows; i2++) {
        transposedRow[i2] = clone(data[i2][j]);
      }
    }
    return m.createDenseMatrix({
      data: transposed,
      size: [columns, rows],
      datatype: m._datatype
    });
  }
  function _sparseTranspose(m, rows, columns) {
    var values = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    var cvalues = values ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var w = [];
    for (var x = 0; x < rows; x++) {
      w[x] = 0;
    }
    var p, l, j;
    for (p = 0, l = index2.length; p < l; p++) {
      w[index2[p]]++;
    }
    var sum2 = 0;
    for (var i2 = 0; i2 < rows; i2++) {
      cptr.push(sum2);
      sum2 += w[i2];
      w[i2] = cptr[i2];
    }
    cptr.push(sum2);
    for (j = 0; j < columns; j++) {
      for (var k0 = ptr[j], k1 = ptr[j + 1], k = k0; k < k1; k++) {
        var q = w[index2[k]]++;
        cindex[q] = j;
        if (values) {
          cvalues[q] = clone(values[k]);
        }
      }
    }
    return m.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [columns, rows],
      datatype: m._datatype
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/ctranspose.js
var name80 = "ctranspose";
var dependencies80 = ["typed", "transpose", "conj"];
var createCtranspose = factory(name80, dependencies80, (_ref) => {
  var {
    typed: typed2,
    transpose: transpose2,
    conj: conj2
  } = _ref;
  return typed2(name80, {
    any: function any(x) {
      return conj2(transpose2(x));
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/zeros.js
var name81 = "zeros";
var dependencies81 = ["typed", "config", "matrix", "BigNumber"];
var createZeros = factory(name81, dependencies81, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    matrix: matrix2,
    BigNumber: BigNumber2
  } = _ref;
  return typed2(name81, {
    "": function _() {
      return config2.matrix === "Array" ? _zeros([]) : _zeros([], "default");
    },
    // math.zeros(m, n, p, ..., format)
    // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
    "...number | BigNumber | string": function number__BigNumber__string(size2) {
      var last = size2[size2.length - 1];
      if (typeof last === "string") {
        var format4 = size2.pop();
        return _zeros(size2, format4);
      } else if (config2.matrix === "Array") {
        return _zeros(size2);
      } else {
        return _zeros(size2, "default");
      }
    },
    Array: _zeros,
    Matrix: function Matrix2(size2) {
      var format4 = size2.storage();
      return _zeros(size2.valueOf(), format4);
    },
    "Array | Matrix, string": function Array__Matrix_string(size2, format4) {
      return _zeros(size2.valueOf(), format4);
    }
  });
  function _zeros(size2, format4) {
    var hasBigNumbers = _normalize(size2);
    var defaultValue = hasBigNumbers ? new BigNumber2(0) : 0;
    _validate(size2);
    if (format4) {
      var m = matrix2(format4);
      if (size2.length > 0) {
        return m.resize(size2, defaultValue);
      }
      return m;
    } else {
      var arr = [];
      if (size2.length > 0) {
        return resize(arr, size2, defaultValue);
      }
      return arr;
    }
  }
  function _normalize(size2) {
    var hasBigNumbers = false;
    size2.forEach(function(value, index2, arr) {
      if (isBigNumber(value)) {
        hasBigNumbers = true;
        arr[index2] = value.toNumber();
      }
    });
    return hasBigNumbers;
  }
  function _validate(size2) {
    size2.forEach(function(value) {
      if (typeof value !== "number" || !isInteger(value) || value < 0) {
        throw new Error("Parameters in function zeros must be positive integers");
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/fft.js
var name82 = "fft";
var dependencies82 = ["typed", "matrix", "addScalar", "multiplyScalar", "divideScalar", "exp", "tau", "i", "dotDivide", "conj", "pow", "ceil", "log2"];
var createFft = factory(name82, dependencies82, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    addScalar: addScalar2,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    exp: exp2,
    tau: tau2,
    i: I,
    dotDivide: dotDivide2,
    conj: conj2,
    pow: pow2,
    ceil: ceil2,
    log2: log22
  } = _ref;
  return typed2(name82, {
    Array: _ndFft,
    Matrix: function Matrix2(matrix3) {
      return matrix3.create(_ndFft(matrix3.valueOf()), matrix3.datatype());
    }
  });
  function _ndFft(arr) {
    var size2 = arraySize(arr);
    if (size2.length === 1) return _fft(arr, size2[0]);
    return _1dFft(arr.map((slice) => _ndFft(slice, size2.slice(1))), 0);
  }
  function _1dFft(arr, dim) {
    var size2 = arraySize(arr);
    if (dim !== 0) return new Array(size2[0]).fill(0).map((_, i2) => _1dFft(arr[i2], dim - 1));
    if (size2.length === 1) return _fft(arr);
    function _transpose(arr2) {
      var size3 = arraySize(arr2);
      return new Array(size3[1]).fill(0).map((_, j) => new Array(size3[0]).fill(0).map((_2, i2) => arr2[i2][j]));
    }
    return _transpose(_1dFft(_transpose(arr), 1));
  }
  function _czt(arr) {
    var n = arr.length;
    var w = exp2(divideScalar2(multiplyScalar2(-1, multiplyScalar2(I, tau2)), n));
    var chirp = [];
    for (var i2 = 1 - n; i2 < n; i2++) {
      chirp.push(pow2(w, divideScalar2(pow2(i2, 2), 2)));
    }
    var N2 = pow2(2, ceil2(log22(n + n - 1)));
    var xp = [...new Array(n).fill(0).map((_, i3) => multiplyScalar2(arr[i3], chirp[n - 1 + i3])), ...new Array(N2 - n).fill(0)];
    var ichirp = [...new Array(n + n - 1).fill(0).map((_, i3) => divideScalar2(1, chirp[i3])), ...new Array(N2 - (n + n - 1)).fill(0)];
    var fftXp = _fft(xp);
    var fftIchirp = _fft(ichirp);
    var fftProduct = new Array(N2).fill(0).map((_, i3) => multiplyScalar2(fftXp[i3], fftIchirp[i3]));
    var ifftProduct = dotDivide2(conj2(_ndFft(conj2(fftProduct))), N2);
    var ret = [];
    for (var _i = n - 1; _i < n + n - 1; _i++) {
      ret.push(multiplyScalar2(ifftProduct[_i], chirp[_i]));
    }
    return ret;
  }
  function _fft(arr) {
    var len = arr.length;
    if (len === 1) return [arr[0]];
    if (len % 2 === 0) {
      var ret = [..._fft(arr.filter((_, i2) => i2 % 2 === 0), len / 2), ..._fft(arr.filter((_, i2) => i2 % 2 === 1), len / 2)];
      for (var k = 0; k < len / 2; k++) {
        var p = ret[k];
        var q = multiplyScalar2(ret[k + len / 2], exp2(multiplyScalar2(multiplyScalar2(tau2, I), divideScalar2(-k, len))));
        ret[k] = addScalar2(p, q);
        ret[k + len / 2] = addScalar2(p, multiplyScalar2(-1, q));
      }
      return ret;
    } else {
      return _czt(arr);
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/ifft.js
var name83 = "ifft";
var dependencies83 = ["typed", "fft", "dotDivide", "conj"];
var createIfft = factory(name83, dependencies83, (_ref) => {
  var {
    typed: typed2,
    fft: fft2,
    dotDivide: dotDivide2,
    conj: conj2
  } = _ref;
  return typed2(name83, {
    "Array | Matrix": function Array__Matrix(arr) {
      var size2 = isMatrix(arr) ? arr.size() : arraySize(arr);
      return dotDivide2(conj2(fft2(conj2(arr))), size2.reduce((acc, curr) => acc * curr, 1));
    }
  });
});

// node_modules/mathjs/lib/esm/function/numeric/solveODE.js
function ownKeys(e2, r) {
  var t = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e2, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e2) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e2, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e2, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e2;
}
var name84 = "solveODE";
var dependencies84 = ["typed", "add", "subtract", "multiply", "divide", "max", "map", "abs", "isPositive", "isNegative", "larger", "smaller", "matrix", "bignumber", "unaryMinus"];
var createSolveODE = factory(name84, dependencies84, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    subtract: subtract2,
    multiply: multiply2,
    divide: divide2,
    max: max2,
    map: map2,
    abs: abs2,
    isPositive: isPositive2,
    isNegative: isNegative2,
    larger: larger2,
    smaller: smaller2,
    matrix: matrix2,
    bignumber: bignumber2,
    unaryMinus: unaryMinus2
  } = _ref;
  function _rk(butcherTableau) {
    return function(f, tspan, y0, options) {
      var wrongTSpan = !(tspan.length === 2 && (tspan.every(isNumOrBig) || tspan.every(isUnit)));
      if (wrongTSpan) {
        throw new Error('"tspan" must be an Array of two numeric values or two units [tStart, tEnd]');
      }
      var t0 = tspan[0];
      var tf = tspan[1];
      var isForwards = larger2(tf, t0);
      var firstStep = options.firstStep;
      if (firstStep !== void 0 && !isPositive2(firstStep)) {
        throw new Error('"firstStep" must be positive');
      }
      var maxStep = options.maxStep;
      if (maxStep !== void 0 && !isPositive2(maxStep)) {
        throw new Error('"maxStep" must be positive');
      }
      var minStep = options.minStep;
      if (minStep && isNegative2(minStep)) {
        throw new Error('"minStep" must be positive or zero');
      }
      var timeVars = [t0, tf, firstStep, minStep, maxStep].filter((x) => x !== void 0);
      if (!(timeVars.every(isNumOrBig) || timeVars.every(isUnit))) {
        throw new Error('Inconsistent type of "t" dependant variables');
      }
      var steps = 1;
      var tol = options.tol ? options.tol : 1e-4;
      var minDelta = options.minDelta ? options.minDelta : 0.2;
      var maxDelta = options.maxDelta ? options.maxDelta : 5;
      var maxIter = options.maxIter ? options.maxIter : 1e4;
      var hasBigNumbers = [t0, tf, ...y0, maxStep, minStep].some(isBigNumber);
      var [a, c, b, bp] = hasBigNumbers ? [bignumber2(butcherTableau.a), bignumber2(butcherTableau.c), bignumber2(butcherTableau.b), bignumber2(butcherTableau.bp)] : [butcherTableau.a, butcherTableau.c, butcherTableau.b, butcherTableau.bp];
      var h = firstStep ? isForwards ? firstStep : unaryMinus2(firstStep) : divide2(subtract2(tf, t0), steps);
      var t = [t0];
      var y = [y0];
      var deltaB = subtract2(b, bp);
      var n = 0;
      var iter = 0;
      var ongoing = _createOngoing(isForwards);
      var trimStep = _createTrimStep(isForwards);
      while (ongoing(t[n], tf)) {
        var k = [];
        h = trimStep(t[n], tf, h);
        k.push(f(t[n], y[n]));
        for (var i2 = 1; i2 < c.length; ++i2) {
          k.push(f(add2(t[n], multiply2(c[i2], h)), add2(y[n], multiply2(h, a[i2], k))));
        }
        var TE = max2(abs2(map2(multiply2(deltaB, k), (X) => isUnit(X) ? X.value : X)));
        if (TE < tol && tol / TE > 1 / 4) {
          t.push(add2(t[n], h));
          y.push(add2(y[n], multiply2(h, b, k)));
          n++;
        }
        var delta = 0.84 * (tol / TE) ** (1 / 5);
        if (smaller2(delta, minDelta)) {
          delta = minDelta;
        } else if (larger2(delta, maxDelta)) {
          delta = maxDelta;
        }
        delta = hasBigNumbers ? bignumber2(delta) : delta;
        h = multiply2(h, delta);
        if (maxStep && larger2(abs2(h), maxStep)) {
          h = isForwards ? maxStep : unaryMinus2(maxStep);
        } else if (minStep && smaller2(abs2(h), minStep)) {
          h = isForwards ? minStep : unaryMinus2(minStep);
        }
        iter++;
        if (iter > maxIter) {
          throw new Error("Maximum number of iterations reached, try changing options");
        }
      }
      return {
        t,
        y
      };
    };
  }
  function _rk23(f, tspan, y0, options) {
    var a = [[], [1 / 2], [0, 3 / 4], [2 / 9, 1 / 3, 4 / 9]];
    var c = [null, 1 / 2, 3 / 4, 1];
    var b = [2 / 9, 1 / 3, 4 / 9, 0];
    var bp = [7 / 24, 1 / 4, 1 / 3, 1 / 8];
    var butcherTableau = {
      a,
      c,
      b,
      bp
    };
    return _rk(butcherTableau)(f, tspan, y0, options);
  }
  function _rk45(f, tspan, y0, options) {
    var a = [[], [1 / 5], [3 / 40, 9 / 40], [44 / 45, -56 / 15, 32 / 9], [19372 / 6561, -25360 / 2187, 64448 / 6561, -212 / 729], [9017 / 3168, -355 / 33, 46732 / 5247, 49 / 176, -5103 / 18656], [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84]];
    var c = [null, 1 / 5, 3 / 10, 4 / 5, 8 / 9, 1, 1];
    var b = [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84, 0];
    var bp = [5179 / 57600, 0, 7571 / 16695, 393 / 640, -92097 / 339200, 187 / 2100, 1 / 40];
    var butcherTableau = {
      a,
      c,
      b,
      bp
    };
    return _rk(butcherTableau)(f, tspan, y0, options);
  }
  function _solveODE(f, tspan, y0, opt) {
    var method = opt.method ? opt.method : "RK45";
    var methods = {
      RK23: _rk23,
      RK45: _rk45
    };
    if (method.toUpperCase() in methods) {
      var methodOptions = _objectSpread({}, opt);
      delete methodOptions.method;
      return methods[method.toUpperCase()](f, tspan, y0, methodOptions);
    } else {
      var methodsWithQuotes = Object.keys(methods).map((x) => '"'.concat(x, '"'));
      var availableMethodsString = "".concat(methodsWithQuotes.slice(0, -1).join(", "), " and ").concat(methodsWithQuotes.slice(-1));
      throw new Error('Unavailable method "'.concat(method, '". Available methods are ').concat(availableMethodsString));
    }
  }
  function _createOngoing(isForwards) {
    return isForwards ? smaller2 : larger2;
  }
  function _createTrimStep(isForwards) {
    var outOfBounds = isForwards ? larger2 : smaller2;
    return function(t, tf, h) {
      var next = add2(t, h);
      return outOfBounds(next, tf) ? subtract2(tf, t) : h;
    };
  }
  function isNumOrBig(x) {
    return isBigNumber(x) || isNumber(x);
  }
  function _matrixSolveODE(f, T, y0, options) {
    var sol = _solveODE(f, T.toArray(), y0.toArray(), options);
    return {
      t: matrix2(sol.t),
      y: matrix2(sol.y)
    };
  }
  return typed2("solveODE", {
    "function, Array, Array, Object": _solveODE,
    "function, Matrix, Matrix, Object": _matrixSolveODE,
    "function, Array, Array": (f, T, y0) => _solveODE(f, T, y0, {}),
    "function, Matrix, Matrix": (f, T, y0) => _matrixSolveODE(f, T, y0, {}),
    "function, Array, number | BigNumber | Unit": (f, T, y0) => {
      var sol = _solveODE(f, T, [y0], {});
      return {
        t: sol.t,
        y: sol.y.map((Y) => Y[0])
      };
    },
    "function, Matrix, number | BigNumber | Unit": (f, T, y0) => {
      var sol = _solveODE(f, T.toArray(), [y0], {});
      return {
        t: matrix2(sol.t),
        y: matrix2(sol.y.map((Y) => Y[0]))
      };
    },
    "function, Array, number | BigNumber | Unit, Object": (f, T, y0, options) => {
      var sol = _solveODE(f, T, [y0], options);
      return {
        t: sol.t,
        y: sol.y.map((Y) => Y[0])
      };
    },
    "function, Matrix, number | BigNumber | Unit, Object": (f, T, y0, options) => {
      var sol = _solveODE(f, T.toArray(), [y0], options);
      return {
        t: matrix2(sol.t),
        y: matrix2(sol.y.map((Y) => Y[0]))
      };
    }
  });
});

// node_modules/mathjs/lib/esm/function/string/bin.js
var name85 = "bin";
var dependencies85 = ["typed", "format"];
var createBin = factory(name85, dependencies85, (_ref) => {
  var {
    typed: typed2,
    format: format4
  } = _ref;
  return typed2(name85, {
    "number | BigNumber": function number__BigNumber(n) {
      return format4(n, {
        notation: "bin"
      });
    },
    "number | BigNumber, number | BigNumber": function number__BigNumber_number__BigNumber(n, wordSize) {
      return format4(n, {
        notation: "bin",
        wordSize
      });
    }
  });
});

// node_modules/mathjs/lib/esm/function/string/oct.js
var name86 = "oct";
var dependencies86 = ["typed", "format"];
var createOct = factory(name86, dependencies86, (_ref) => {
  var {
    typed: typed2,
    format: format4
  } = _ref;
  return typed2(name86, {
    "number | BigNumber": function number__BigNumber(n) {
      return format4(n, {
        notation: "oct"
      });
    },
    "number | BigNumber, number | BigNumber": function number__BigNumber_number__BigNumber(n, wordSize) {
      return format4(n, {
        notation: "oct",
        wordSize
      });
    }
  });
});

// node_modules/mathjs/lib/esm/function/string/hex.js
var name87 = "hex";
var dependencies87 = ["typed", "format"];
var createHex = factory(name87, dependencies87, (_ref) => {
  var {
    typed: typed2,
    format: format4
  } = _ref;
  return typed2(name87, {
    "number | BigNumber": function number__BigNumber(n) {
      return format4(n, {
        notation: "hex"
      });
    },
    "number | BigNumber, number | BigNumber": function number__BigNumber_number__BigNumber(n, wordSize) {
      return format4(n, {
        notation: "hex",
        wordSize
      });
    }
  });
});

// node_modules/mathjs/lib/esm/function/unit/to.js
var name88 = "to";
var dependencies88 = ["typed", "matrix", "concat"];
var createTo = factory(name88, dependencies88, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    concat: concat3
  } = _ref;
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat3
  });
  return typed2(name88, {
    "Unit, Unit | string": (x, unit2) => x.to(unit2)
  }, matrixAlgorithmSuite({
    Ds: true
  }));
});

// node_modules/mathjs/lib/esm/function/arithmetic/divideScalar.js
var name89 = "divideScalar";
var dependencies89 = ["typed", "numeric"];
var createDivideScalar = factory(name89, dependencies89, (_ref) => {
  var {
    typed: typed2,
    numeric: numeric2
  } = _ref;
  return typed2(name89, {
    "number, number": function number_number(x, y) {
      return x / y;
    },
    "Complex, Complex": function Complex_Complex(x, y) {
      return x.div(y);
    },
    "BigNumber, BigNumber": function BigNumber_BigNumber(x, y) {
      return x.div(y);
    },
    "bigint, bigint": function bigint_bigint(x, y) {
      return x / y;
    },
    "Fraction, Fraction": function Fraction_Fraction(x, y) {
      return x.div(y);
    },
    "Unit, number | Complex | Fraction | BigNumber | Unit": (x, y) => x.divide(y),
    "number | Fraction | Complex | BigNumber, Unit": (x, y) => y.divideInto(x)
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/pow.js
var name90 = "pow";
var dependencies90 = ["typed", "config", "identity", "multiply", "matrix", "inv", "fraction", "number", "Complex"];
var createPow = factory(name90, dependencies90, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    identity: identity2,
    multiply: multiply2,
    matrix: matrix2,
    inv: inv2,
    number: number2,
    fraction: fraction2,
    Complex: Complex3
  } = _ref;
  return typed2(name90, {
    "number, number": _pow,
    "Complex, Complex": function Complex_Complex(x, y) {
      return x.pow(y);
    },
    "BigNumber, BigNumber": function BigNumber_BigNumber(x, y) {
      if (y.isInteger() || x >= 0 || config2.predictable) {
        return x.pow(y);
      } else {
        return new Complex3(x.toNumber(), 0).pow(y.toNumber(), 0);
      }
    },
    "bigint, bigint": (x, y) => x ** y,
    "Fraction, Fraction": function Fraction_Fraction(x, y) {
      var result = x.pow(y);
      if (result != null) {
        return result;
      }
      if (config2.predictable) {
        throw new Error("Result of pow is non-rational and cannot be expressed as a fraction");
      } else {
        return _pow(x.valueOf(), y.valueOf());
      }
    },
    "Array, number": _powArray,
    "Array, BigNumber": function Array_BigNumber(x, y) {
      return _powArray(x, y.toNumber());
    },
    "Matrix, number": _powMatrix,
    "Matrix, BigNumber": function Matrix_BigNumber(x, y) {
      return _powMatrix(x, y.toNumber());
    },
    "Unit, number | BigNumber": function Unit_number__BigNumber(x, y) {
      return x.pow(y);
    }
  });
  function _pow(x, y) {
    if (config2.predictable && !isInteger(y) && x < 0) {
      try {
        var yFrac = fraction2(y);
        var yNum = number2(yFrac);
        if (y === yNum || Math.abs((y - yNum) / y) < 1e-14) {
          if (yFrac.d % 2n === 1n) {
            return (yFrac.n % 2n === 0n ? 1 : -1) * Math.pow(-x, y);
          }
        }
      } catch (ex) {
      }
    }
    if (config2.predictable && (x < -1 && y === Infinity || x > -1 && x < 0 && y === -Infinity)) {
      return NaN;
    }
    if (isInteger(y) || x >= 0 || config2.predictable) {
      return powNumber(x, y);
    } else {
      if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
        return 0;
      }
      return new Complex3(x, 0).pow(y, 0);
    }
  }
  function _powArray(x, y) {
    if (!isInteger(y)) {
      throw new TypeError("For A^b, b must be an integer (value is " + y + ")");
    }
    var s = arraySize(x);
    if (s.length !== 2) {
      throw new Error("For A^b, A must be 2 dimensional (A has " + s.length + " dimensions)");
    }
    if (s[0] !== s[1]) {
      throw new Error("For A^b, A must be square (size is " + s[0] + "x" + s[1] + ")");
    }
    if (y < 0) {
      try {
        return _powArray(inv2(x), -y);
      } catch (error) {
        if (error.message === "Cannot calculate inverse, determinant is zero") {
          throw new TypeError("For A^b, when A is not invertible, b must be a positive integer (value is " + y + ")");
        }
        throw error;
      }
    }
    var res = identity2(s[0]).valueOf();
    var px = x;
    while (y >= 1) {
      if ((y & 1) === 1) {
        res = multiply2(px, res);
      }
      y >>= 1;
      px = multiply2(px, px);
    }
    return res;
  }
  function _powMatrix(x, y) {
    return matrix2(_powArray(x.valueOf(), y));
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/round.js
var NO_INT = "Number of decimals in function round must be an integer";
var name91 = "round";
var dependencies91 = ["typed", "config", "matrix", "equalScalar", "zeros", "BigNumber", "DenseMatrix"];
var createRound = factory(name91, dependencies91, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    BigNumber: _BigNumber,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  function toExponent(epsilon) {
    return Math.abs(splitNumber(epsilon).exponent);
  }
  return typed2(name91, {
    number: function number2(x) {
      var xEpsilon = roundNumber(x, toExponent(config2.relTol));
      var xSelected = nearlyEqual(x, xEpsilon, config2.relTol, config2.absTol) ? xEpsilon : x;
      return roundNumber(xSelected);
    },
    "number, number": function number_number(x, n) {
      var epsilonExponent = toExponent(config2.relTol);
      if (n >= epsilonExponent) {
        return roundNumber(x, n);
      }
      var xEpsilon = roundNumber(x, epsilonExponent);
      var xSelected = nearlyEqual(x, xEpsilon, config2.relTol, config2.absTol) ? xEpsilon : x;
      return roundNumber(xSelected, n);
    },
    "number, BigNumber": function number_BigNumber(x, n) {
      if (!n.isInteger()) {
        throw new TypeError(NO_INT);
      }
      return new _BigNumber(x).toDecimalPlaces(n.toNumber());
    },
    Complex: function Complex3(x) {
      return x.round();
    },
    "Complex, number": function Complex_number(x, n) {
      if (n % 1) {
        throw new TypeError(NO_INT);
      }
      return x.round(n);
    },
    "Complex, BigNumber": function Complex_BigNumber(x, n) {
      if (!n.isInteger()) {
        throw new TypeError(NO_INT);
      }
      var _n = n.toNumber();
      return x.round(_n);
    },
    BigNumber: function BigNumber2(x) {
      var xEpsilon = new _BigNumber(x).toDecimalPlaces(toExponent(config2.relTol));
      var xSelected = nearlyEqual2(x, xEpsilon, config2.relTol, config2.absTol) ? xEpsilon : x;
      return xSelected.toDecimalPlaces(0);
    },
    "BigNumber, BigNumber": function BigNumber_BigNumber(x, n) {
      if (!n.isInteger()) {
        throw new TypeError(NO_INT);
      }
      var epsilonExponent = toExponent(config2.relTol);
      if (n >= epsilonExponent) {
        return x.toDecimalPlaces(n.toNumber());
      }
      var xEpsilon = x.toDecimalPlaces(epsilonExponent);
      var xSelected = nearlyEqual2(x, xEpsilon, config2.relTol, config2.absTol) ? xEpsilon : x;
      return xSelected.toDecimalPlaces(n.toNumber());
    },
    // bigints can't be rounded
    bigint: (b) => b,
    "bigint, number": (b, _dummy) => b,
    "bigint, BigNumber": (b, _dummy) => b,
    Fraction: function Fraction3(x) {
      return x.round();
    },
    "Fraction, number": function Fraction_number(x, n) {
      if (n % 1) {
        throw new TypeError(NO_INT);
      }
      return x.round(n);
    },
    "Fraction, BigNumber": function Fraction_BigNumber(x, n) {
      if (!n.isInteger()) {
        throw new TypeError(NO_INT);
      }
      return x.round(n.toNumber());
    },
    "Unit, number, Unit": typed2.referToSelf((self) => function(x, n, unit2) {
      var valueless = x.toNumeric(unit2);
      return unit2.multiply(self(valueless, n));
    }),
    "Unit, BigNumber, Unit": typed2.referToSelf((self) => (x, n, unit2) => self(x, n.toNumber(), unit2)),
    "Array | Matrix, number | BigNumber, Unit": typed2.referToSelf((self) => (x, n, unit2) => {
      return deepMap(x, (value) => self(value, n, unit2), true);
    }),
    "Array | Matrix | Unit, Unit": typed2.referToSelf((self) => (x, unit2) => self(x, 0, unit2)),
    "Array | Matrix": typed2.referToSelf((self) => (x) => {
      return deepMap(x, self, true);
    }),
    "SparseMatrix, number | BigNumber": typed2.referToSelf((self) => (x, n) => {
      return matAlgo11xS0s(x, n, self, false);
    }),
    "DenseMatrix, number | BigNumber": typed2.referToSelf((self) => (x, n) => {
      return matAlgo14xDs(x, n, self, false);
    }),
    "Array, number | BigNumber": typed2.referToSelf((self) => (x, n) => {
      return matAlgo14xDs(matrix2(x), n, self, false).valueOf();
    }),
    "number | Complex | BigNumber | Fraction, SparseMatrix": typed2.referToSelf((self) => (x, n) => {
      if (equalScalar2(x, 0)) {
        return zeros2(n.size(), n.storage());
      }
      return matAlgo12xSfs(n, x, self, true);
    }),
    "number | Complex | BigNumber | Fraction, DenseMatrix": typed2.referToSelf((self) => (x, n) => {
      if (equalScalar2(x, 0)) {
        return zeros2(n.size(), n.storage());
      }
      return matAlgo14xDs(n, x, self, true);
    }),
    "number | Complex | BigNumber | Fraction, Array": typed2.referToSelf((self) => (x, n) => {
      return matAlgo14xDs(matrix2(n), x, self, true).valueOf();
    })
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/log.js
var name92 = "log";
var dependencies92 = ["config", "typed", "typeOf", "divideScalar", "Complex"];
var nlg16 = Math.log(16);
var createLog = factory(name92, dependencies92, (_ref) => {
  var {
    typed: typed2,
    typeOf: typeOf3,
    config: config2,
    divideScalar: divideScalar2,
    Complex: Complex3
  } = _ref;
  function complexLog(c) {
    return c.log();
  }
  function complexLogNumber(x) {
    return complexLog(new Complex3(x, 0));
  }
  return typed2(name92, {
    number: function number2(x) {
      if (x >= 0 || config2.predictable) {
        return logNumber(x);
      } else {
        return complexLogNumber(x);
      }
    },
    bigint: promoteLogarithm(nlg16, logNumber, config2, complexLogNumber),
    Complex: complexLog,
    BigNumber: function BigNumber2(x) {
      if (!x.isNegative() || config2.predictable) {
        return x.ln();
      } else {
        return complexLogNumber(x.toNumber());
      }
    },
    "any, any": typed2.referToSelf((self) => (x, base) => {
      if (typeOf3(x) === "Fraction" && typeOf3(base) === "Fraction") {
        var result = x.log(base);
        if (result !== null) {
          return result;
        }
      }
      return divideScalar2(self(x), self(base));
    })
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/log1p.js
var name93 = "log1p";
var dependencies93 = ["typed", "config", "divideScalar", "log", "Complex"];
var createLog1p = factory(name93, dependencies93, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    divideScalar: divideScalar2,
    log: log3,
    Complex: Complex3
  } = _ref;
  return typed2(name93, {
    number: function number2(x) {
      if (x >= -1 || config2.predictable) {
        return log1p(x);
      } else {
        return _log1pComplex(new Complex3(x, 0));
      }
    },
    Complex: _log1pComplex,
    BigNumber: function BigNumber2(x) {
      var y = x.plus(1);
      if (!y.isNegative() || config2.predictable) {
        return y.ln();
      } else {
        return _log1pComplex(new Complex3(x.toNumber(), 0));
      }
    },
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self)),
    "any, any": typed2.referToSelf((self) => (x, base) => {
      return divideScalar2(self(x), log3(base));
    })
  });
  function _log1pComplex(x) {
    var xRe1p = x.re + 1;
    return new Complex3(Math.log(Math.sqrt(xRe1p * xRe1p + x.im * x.im)), Math.atan2(x.im, xRe1p));
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/nthRoots.js
var name94 = "nthRoots";
var dependencies94 = ["config", "typed", "divideScalar", "Complex"];
var createNthRoots = factory(name94, dependencies94, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    divideScalar: divideScalar2,
    Complex: Complex3
  } = _ref;
  var _calculateExactResult = [function realPos(val) {
    return new Complex3(val, 0);
  }, function imagPos(val) {
    return new Complex3(0, val);
  }, function realNeg(val) {
    return new Complex3(-val, 0);
  }, function imagNeg(val) {
    return new Complex3(0, -val);
  }];
  function _nthComplexRoots(a, root) {
    if (root < 0) throw new Error("Root must be greater than zero");
    if (root === 0) throw new Error("Root must be non-zero");
    if (root % 1 !== 0) throw new Error("Root must be an integer");
    if (a === 0 || a.abs() === 0) return [new Complex3(0, 0)];
    var aIsNumeric = typeof a === "number";
    var offset;
    if (aIsNumeric || a.re === 0 || a.im === 0) {
      if (aIsNumeric) {
        offset = 2 * +(a < 0);
      } else if (a.im === 0) {
        offset = 2 * +(a.re < 0);
      } else {
        offset = 2 * +(a.im < 0) + 1;
      }
    }
    var arg2 = a.arg();
    var abs2 = a.abs();
    var roots = [];
    var r = Math.pow(abs2, 1 / root);
    for (var k = 0; k < root; k++) {
      var halfPiFactor = (offset + 4 * k) / root;
      if (halfPiFactor === Math.round(halfPiFactor)) {
        roots.push(_calculateExactResult[halfPiFactor % 4](r));
        continue;
      }
      roots.push(new Complex3({
        r,
        phi: (arg2 + 2 * Math.PI * k) / root
      }));
    }
    return roots;
  }
  return typed2(name94, {
    Complex: function Complex4(x) {
      return _nthComplexRoots(x, 2);
    },
    "Complex, number": _nthComplexRoots
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/dotPow.js
var name95 = "dotPow";
var dependencies95 = ["typed", "equalScalar", "matrix", "pow", "DenseMatrix", "concat", "SparseMatrix"];
var createDotPow = factory(name95, dependencies95, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2,
    matrix: matrix2,
    pow: pow2,
    DenseMatrix: DenseMatrix2,
    concat: concat3,
    SparseMatrix: SparseMatrix2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    SparseMatrix: SparseMatrix2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat3
  });
  var powScalarSignatures = {};
  for (var signature in pow2.signatures) {
    if (Object.prototype.hasOwnProperty.call(pow2.signatures, signature)) {
      if (!signature.includes("Matrix") && !signature.includes("Array")) {
        powScalarSignatures[signature] = pow2.signatures[signature];
      }
    }
  }
  var powScalar = typed2(powScalarSignatures);
  return typed2(name95, matrixAlgorithmSuite({
    elop: powScalar,
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo11xS0s,
    sS: matAlgo12xSfs
  }));
});

// node_modules/mathjs/lib/esm/function/arithmetic/dotDivide.js
var name96 = "dotDivide";
var dependencies96 = ["typed", "matrix", "equalScalar", "divideScalar", "DenseMatrix", "concat", "SparseMatrix"];
var createDotDivide = factory(name96, dependencies96, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    divideScalar: divideScalar2,
    DenseMatrix: DenseMatrix2,
    concat: concat3,
    SparseMatrix: SparseMatrix2
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    SparseMatrix: SparseMatrix2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat3
  });
  return typed2(name96, matrixAlgorithmSuite({
    elop: divideScalar2,
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    SD: matAlgo02xDS0,
    Ss: matAlgo11xS0s,
    sS: matAlgo12xSfs
  }));
});

// node_modules/mathjs/lib/esm/function/algebra/solver/utils/solveValidation.js
function createSolveValidation(_ref) {
  var {
    DenseMatrix: DenseMatrix2
  } = _ref;
  return function solveValidation(m, b, copy) {
    var mSize = m.size();
    if (mSize.length !== 2) {
      throw new RangeError("Matrix must be two dimensional (size: " + format2(mSize) + ")");
    }
    var rows = mSize[0];
    var columns = mSize[1];
    if (rows !== columns) {
      throw new RangeError("Matrix must be square (size: " + format2(mSize) + ")");
    }
    var data = [];
    if (isMatrix(b)) {
      var bSize = b.size();
      var bdata = b._data;
      if (bSize.length === 1) {
        if (bSize[0] !== rows) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        for (var i2 = 0; i2 < rows; i2++) {
          data[i2] = [bdata[i2]];
        }
        return new DenseMatrix2({
          data,
          size: [rows, 1],
          datatype: b._datatype
        });
      }
      if (bSize.length === 2) {
        if (bSize[0] !== rows || bSize[1] !== 1) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        if (isDenseMatrix(b)) {
          if (copy) {
            data = [];
            for (var _i = 0; _i < rows; _i++) {
              data[_i] = [bdata[_i][0]];
            }
            return new DenseMatrix2({
              data,
              size: [rows, 1],
              datatype: b._datatype
            });
          }
          return b;
        }
        if (isSparseMatrix(b)) {
          for (var _i2 = 0; _i2 < rows; _i2++) {
            data[_i2] = [0];
          }
          var values = b._values;
          var index2 = b._index;
          var ptr = b._ptr;
          for (var k1 = ptr[1], k = ptr[0]; k < k1; k++) {
            var _i3 = index2[k];
            data[_i3][0] = values[k];
          }
          return new DenseMatrix2({
            data,
            size: [rows, 1],
            datatype: b._datatype
          });
        }
      }
      throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
    }
    if (isArray(b)) {
      var bsize = arraySize(b);
      if (bsize.length === 1) {
        if (bsize[0] !== rows) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        for (var _i4 = 0; _i4 < rows; _i4++) {
          data[_i4] = [b[_i4]];
        }
        return new DenseMatrix2({
          data,
          size: [rows, 1]
        });
      }
      if (bsize.length === 2) {
        if (bsize[0] !== rows || bsize[1] !== 1) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        for (var _i5 = 0; _i5 < rows; _i5++) {
          data[_i5] = [b[_i5][0]];
        }
        return new DenseMatrix2({
          data,
          size: [rows, 1]
        });
      }
      throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
    }
  };
}

// node_modules/mathjs/lib/esm/function/algebra/solver/lsolve.js
var name97 = "lsolve";
var dependencies97 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"];
var createLsolve = factory(name97, dependencies97, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    subtractScalar: subtractScalar2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix: DenseMatrix2
  });
  return typed2(name97, {
    "SparseMatrix, Array | Matrix": function SparseMatrix_Array__Matrix(m, b) {
      return _sparseForwardSubstitution(m, b);
    },
    "DenseMatrix, Array | Matrix": function DenseMatrix_Array__Matrix(m, b) {
      return _denseForwardSubstitution(m, b);
    },
    "Array, Array | Matrix": function Array_Array__Matrix(a, b) {
      var m = matrix2(a);
      var r = _denseForwardSubstitution(m, b);
      return r.valueOf();
    }
  });
  function _denseForwardSubstitution(m, b) {
    b = solveValidation(m, b, true);
    var bdata = b._data;
    var rows = m._size[0];
    var columns = m._size[1];
    var x = [];
    var mdata = m._data;
    for (var j = 0; j < columns; j++) {
      var bj = bdata[j][0] || 0;
      var xj = void 0;
      if (!equalScalar2(bj, 0)) {
        var vjj = mdata[j][j];
        if (equalScalar2(vjj, 0)) {
          throw new Error("Linear system cannot be solved since matrix is singular");
        }
        xj = divideScalar2(bj, vjj);
        for (var i2 = j + 1; i2 < rows; i2++) {
          bdata[i2] = [subtractScalar2(bdata[i2][0] || 0, multiplyScalar2(xj, mdata[i2][j]))];
        }
      } else {
        xj = 0;
      }
      x[j] = [xj];
    }
    return new DenseMatrix2({
      data: x,
      size: [rows, 1]
    });
  }
  function _sparseForwardSubstitution(m, b) {
    b = solveValidation(m, b, true);
    var bdata = b._data;
    var rows = m._size[0];
    var columns = m._size[1];
    var values = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    var x = [];
    for (var j = 0; j < columns; j++) {
      var bj = bdata[j][0] || 0;
      if (!equalScalar2(bj, 0)) {
        var vjj = 0;
        var jValues = [];
        var jIndices = [];
        var firstIndex = ptr[j];
        var lastIndex = ptr[j + 1];
        for (var k = firstIndex; k < lastIndex; k++) {
          var i2 = index2[k];
          if (i2 === j) {
            vjj = values[k];
          } else if (i2 > j) {
            jValues.push(values[k]);
            jIndices.push(i2);
          }
        }
        if (equalScalar2(vjj, 0)) {
          throw new Error("Linear system cannot be solved since matrix is singular");
        }
        var xj = divideScalar2(bj, vjj);
        for (var _k = 0, l = jIndices.length; _k < l; _k++) {
          var _i = jIndices[_k];
          bdata[_i] = [subtractScalar2(bdata[_i][0] || 0, multiplyScalar2(xj, jValues[_k]))];
        }
        x[j] = [xj];
      } else {
        x[j] = [0];
      }
    }
    return new DenseMatrix2({
      data: x,
      size: [rows, 1]
    });
  }
});

// node_modules/mathjs/lib/esm/function/algebra/solver/usolve.js
var name98 = "usolve";
var dependencies98 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"];
var createUsolve = factory(name98, dependencies98, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    subtractScalar: subtractScalar2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix: DenseMatrix2
  });
  return typed2(name98, {
    "SparseMatrix, Array | Matrix": function SparseMatrix_Array__Matrix(m, b) {
      return _sparseBackwardSubstitution(m, b);
    },
    "DenseMatrix, Array | Matrix": function DenseMatrix_Array__Matrix(m, b) {
      return _denseBackwardSubstitution(m, b);
    },
    "Array, Array | Matrix": function Array_Array__Matrix(a, b) {
      var m = matrix2(a);
      var r = _denseBackwardSubstitution(m, b);
      return r.valueOf();
    }
  });
  function _denseBackwardSubstitution(m, b) {
    b = solveValidation(m, b, true);
    var bdata = b._data;
    var rows = m._size[0];
    var columns = m._size[1];
    var x = [];
    var mdata = m._data;
    for (var j = columns - 1; j >= 0; j--) {
      var bj = bdata[j][0] || 0;
      var xj = void 0;
      if (!equalScalar2(bj, 0)) {
        var vjj = mdata[j][j];
        if (equalScalar2(vjj, 0)) {
          throw new Error("Linear system cannot be solved since matrix is singular");
        }
        xj = divideScalar2(bj, vjj);
        for (var i2 = j - 1; i2 >= 0; i2--) {
          bdata[i2] = [subtractScalar2(bdata[i2][0] || 0, multiplyScalar2(xj, mdata[i2][j]))];
        }
      } else {
        xj = 0;
      }
      x[j] = [xj];
    }
    return new DenseMatrix2({
      data: x,
      size: [rows, 1]
    });
  }
  function _sparseBackwardSubstitution(m, b) {
    b = solveValidation(m, b, true);
    var bdata = b._data;
    var rows = m._size[0];
    var columns = m._size[1];
    var values = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    var x = [];
    for (var j = columns - 1; j >= 0; j--) {
      var bj = bdata[j][0] || 0;
      if (!equalScalar2(bj, 0)) {
        var vjj = 0;
        var jValues = [];
        var jIndices = [];
        var firstIndex = ptr[j];
        var lastIndex = ptr[j + 1];
        for (var k = lastIndex - 1; k >= firstIndex; k--) {
          var i2 = index2[k];
          if (i2 === j) {
            vjj = values[k];
          } else if (i2 < j) {
            jValues.push(values[k]);
            jIndices.push(i2);
          }
        }
        if (equalScalar2(vjj, 0)) {
          throw new Error("Linear system cannot be solved since matrix is singular");
        }
        var xj = divideScalar2(bj, vjj);
        for (var _k = 0, _lastIndex = jIndices.length; _k < _lastIndex; _k++) {
          var _i = jIndices[_k];
          bdata[_i] = [subtractScalar2(bdata[_i][0], multiplyScalar2(xj, jValues[_k]))];
        }
        x[j] = [xj];
      } else {
        x[j] = [0];
      }
    }
    return new DenseMatrix2({
      data: x,
      size: [rows, 1]
    });
  }
});

// node_modules/mathjs/lib/esm/function/algebra/solver/lsolveAll.js
var name99 = "lsolveAll";
var dependencies99 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"];
var createLsolveAll = factory(name99, dependencies99, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    subtractScalar: subtractScalar2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix: DenseMatrix2
  });
  return typed2(name99, {
    "SparseMatrix, Array | Matrix": function SparseMatrix_Array__Matrix(m, b) {
      return _sparseForwardSubstitution(m, b);
    },
    "DenseMatrix, Array | Matrix": function DenseMatrix_Array__Matrix(m, b) {
      return _denseForwardSubstitution(m, b);
    },
    "Array, Array | Matrix": function Array_Array__Matrix(a, b) {
      var m = matrix2(a);
      var R = _denseForwardSubstitution(m, b);
      return R.map((r) => r.valueOf());
    }
  });
  function _denseForwardSubstitution(m, b_) {
    var B = [solveValidation(m, b_, true)._data.map((e2) => e2[0])];
    var M = m._data;
    var rows = m._size[0];
    var columns = m._size[1];
    for (var i2 = 0; i2 < columns; i2++) {
      var L = B.length;
      for (var k = 0; k < L; k++) {
        var b = B[k];
        if (!equalScalar2(M[i2][i2], 0)) {
          b[i2] = divideScalar2(b[i2], M[i2][i2]);
          for (var j = i2 + 1; j < columns; j++) {
            b[j] = subtractScalar2(b[j], multiplyScalar2(b[i2], M[j][i2]));
          }
        } else if (!equalScalar2(b[i2], 0)) {
          if (k === 0) {
            return [];
          } else {
            B.splice(k, 1);
            k -= 1;
            L -= 1;
          }
        } else if (k === 0) {
          var bNew = [...b];
          bNew[i2] = 1;
          for (var _j = i2 + 1; _j < columns; _j++) {
            bNew[_j] = subtractScalar2(bNew[_j], M[_j][i2]);
          }
          B.push(bNew);
        }
      }
    }
    return B.map((x) => new DenseMatrix2({
      data: x.map((e2) => [e2]),
      size: [rows, 1]
    }));
  }
  function _sparseForwardSubstitution(m, b_) {
    var B = [solveValidation(m, b_, true)._data.map((e2) => e2[0])];
    var rows = m._size[0];
    var columns = m._size[1];
    var values = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    for (var i2 = 0; i2 < columns; i2++) {
      var L = B.length;
      for (var k = 0; k < L; k++) {
        var b = B[k];
        var iValues = [];
        var iIndices = [];
        var firstIndex = ptr[i2];
        var lastIndex = ptr[i2 + 1];
        var Mii = 0;
        for (var j = firstIndex; j < lastIndex; j++) {
          var J = index2[j];
          if (J === i2) {
            Mii = values[j];
          } else if (J > i2) {
            iValues.push(values[j]);
            iIndices.push(J);
          }
        }
        if (!equalScalar2(Mii, 0)) {
          b[i2] = divideScalar2(b[i2], Mii);
          for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {
            var _J = iIndices[_j2];
            b[_J] = subtractScalar2(b[_J], multiplyScalar2(b[i2], iValues[_j2]));
          }
        } else if (!equalScalar2(b[i2], 0)) {
          if (k === 0) {
            return [];
          } else {
            B.splice(k, 1);
            k -= 1;
            L -= 1;
          }
        } else if (k === 0) {
          var bNew = [...b];
          bNew[i2] = 1;
          for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {
            var _J2 = iIndices[_j3];
            bNew[_J2] = subtractScalar2(bNew[_J2], iValues[_j3]);
          }
          B.push(bNew);
        }
      }
    }
    return B.map((x) => new DenseMatrix2({
      data: x.map((e2) => [e2]),
      size: [rows, 1]
    }));
  }
});

// node_modules/mathjs/lib/esm/function/algebra/solver/usolveAll.js
var name100 = "usolveAll";
var dependencies100 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"];
var createUsolveAll = factory(name100, dependencies100, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    subtractScalar: subtractScalar2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix: DenseMatrix2
  });
  return typed2(name100, {
    "SparseMatrix, Array | Matrix": function SparseMatrix_Array__Matrix(m, b) {
      return _sparseBackwardSubstitution(m, b);
    },
    "DenseMatrix, Array | Matrix": function DenseMatrix_Array__Matrix(m, b) {
      return _denseBackwardSubstitution(m, b);
    },
    "Array, Array | Matrix": function Array_Array__Matrix(a, b) {
      var m = matrix2(a);
      var R = _denseBackwardSubstitution(m, b);
      return R.map((r) => r.valueOf());
    }
  });
  function _denseBackwardSubstitution(m, b_) {
    var B = [solveValidation(m, b_, true)._data.map((e2) => e2[0])];
    var M = m._data;
    var rows = m._size[0];
    var columns = m._size[1];
    for (var i2 = columns - 1; i2 >= 0; i2--) {
      var L = B.length;
      for (var k = 0; k < L; k++) {
        var b = B[k];
        if (!equalScalar2(M[i2][i2], 0)) {
          b[i2] = divideScalar2(b[i2], M[i2][i2]);
          for (var j = i2 - 1; j >= 0; j--) {
            b[j] = subtractScalar2(b[j], multiplyScalar2(b[i2], M[j][i2]));
          }
        } else if (!equalScalar2(b[i2], 0)) {
          if (k === 0) {
            return [];
          } else {
            B.splice(k, 1);
            k -= 1;
            L -= 1;
          }
        } else if (k === 0) {
          var bNew = [...b];
          bNew[i2] = 1;
          for (var _j = i2 - 1; _j >= 0; _j--) {
            bNew[_j] = subtractScalar2(bNew[_j], M[_j][i2]);
          }
          B.push(bNew);
        }
      }
    }
    return B.map((x) => new DenseMatrix2({
      data: x.map((e2) => [e2]),
      size: [rows, 1]
    }));
  }
  function _sparseBackwardSubstitution(m, b_) {
    var B = [solveValidation(m, b_, true)._data.map((e2) => e2[0])];
    var rows = m._size[0];
    var columns = m._size[1];
    var values = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    for (var i2 = columns - 1; i2 >= 0; i2--) {
      var L = B.length;
      for (var k = 0; k < L; k++) {
        var b = B[k];
        var iValues = [];
        var iIndices = [];
        var firstIndex = ptr[i2];
        var lastIndex = ptr[i2 + 1];
        var Mii = 0;
        for (var j = lastIndex - 1; j >= firstIndex; j--) {
          var J = index2[j];
          if (J === i2) {
            Mii = values[j];
          } else if (J < i2) {
            iValues.push(values[j]);
            iIndices.push(J);
          }
        }
        if (!equalScalar2(Mii, 0)) {
          b[i2] = divideScalar2(b[i2], Mii);
          for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {
            var _J = iIndices[_j2];
            b[_J] = subtractScalar2(b[_J], multiplyScalar2(b[i2], iValues[_j2]));
          }
        } else if (!equalScalar2(b[i2], 0)) {
          if (k === 0) {
            return [];
          } else {
            B.splice(k, 1);
            k -= 1;
            L -= 1;
          }
        } else if (k === 0) {
          var bNew = [...b];
          bNew[i2] = 1;
          for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {
            var _J2 = iIndices[_j3];
            bNew[_J2] = subtractScalar2(bNew[_J2], iValues[_j3]);
          }
          B.push(bNew);
        }
      }
    }
    return B.map((x) => new DenseMatrix2({
      data: x.map((e2) => [e2]),
      size: [rows, 1]
    }));
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo08xS0Sid.js
var name101 = "matAlgo08xS0Sid";
var dependencies101 = ["typed", "equalScalar"];
var createMatAlgo08xS0Sid = factory(name101, dependencies101, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2
  } = _ref;
  return function matAlgo08xS0Sid(a, b, callback) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    if (!avalues || !bvalues) {
      throw new Error("Cannot perform operation on Pattern Sparse Matrices");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar2;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
      dt = adt;
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var x = [];
    var w = [];
    var k, k0, k1, i2;
    for (var j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        i2 = aindex[k];
        w[i2] = mark;
        x[i2] = avalues[k];
        cindex.push(i2);
      }
      for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        i2 = bindex[k];
        if (w[i2] === mark) {
          x[i2] = cf(x[i2], bvalues[k]);
        }
      }
      k = cptr[j];
      while (k < cindex.length) {
        i2 = cindex[k];
        var v = x[i2];
        if (!eq(v, zero)) {
          cvalues.push(v);
          k++;
        } else {
          cindex.splice(k, 1);
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
  };
});

// node_modules/mathjs/lib/esm/function/bitwise/useMatrixForArrayScalar.js
var createUseMatrixForArrayScalar = factory("useMatrixForArrayScalar", ["typed", "matrix"], (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2
  } = _ref;
  return {
    "Array, number": typed2.referTo("DenseMatrix, number", (selfDn) => (x, y) => selfDn(matrix2(x), y).valueOf()),
    "Array, BigNumber": typed2.referTo("DenseMatrix, BigNumber", (selfDB) => (x, y) => selfDB(matrix2(x), y).valueOf()),
    "number, Array": typed2.referTo("number, DenseMatrix", (selfnD) => (x, y) => selfnD(x, matrix2(y)).valueOf()),
    "BigNumber, Array": typed2.referTo("BigNumber, DenseMatrix", (selfBD) => (x, y) => selfBD(x, matrix2(y)).valueOf())
  };
});

// node_modules/mathjs/lib/esm/function/bitwise/leftShift.js
var name102 = "leftShift";
var dependencies102 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
var createLeftShift = factory(name102, dependencies102, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo08xS0Sid = createMatAlgo08xS0Sid({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat3
  });
  var useMatrixForArrayScalar = createUseMatrixForArrayScalar({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name102, {
    "number, number": leftShiftNumber,
    "BigNumber, BigNumber": leftShiftBigNumber,
    "bigint, bigint": (x, y) => x << y,
    "SparseMatrix, number | BigNumber": typed2.referToSelf((self) => (x, y) => {
      if (equalScalar2(y, 0)) {
        return x.clone();
      }
      return matAlgo11xS0s(x, y, self, false);
    }),
    "DenseMatrix, number | BigNumber": typed2.referToSelf((self) => (x, y) => {
      if (equalScalar2(y, 0)) {
        return x.clone();
      }
      return matAlgo14xDs(x, y, self, false);
    }),
    "number | BigNumber, SparseMatrix": typed2.referToSelf((self) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo10xSids(y, x, self, true);
    }),
    "number | BigNumber, DenseMatrix": typed2.referToSelf((self) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo14xDs(y, x, self, true);
    })
  }, useMatrixForArrayScalar, matrixAlgorithmSuite({
    SS: matAlgo08xS0Sid,
    DS: matAlgo01xDSid,
    SD: matAlgo02xDS0
  }));
});

// node_modules/mathjs/lib/esm/function/bitwise/rightArithShift.js
var name103 = "rightArithShift";
var dependencies103 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
var createRightArithShift = factory(name103, dependencies103, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo08xS0Sid = createMatAlgo08xS0Sid({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat3
  });
  var useMatrixForArrayScalar = createUseMatrixForArrayScalar({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name103, {
    "number, number": rightArithShiftNumber,
    "BigNumber, BigNumber": rightArithShiftBigNumber,
    "bigint, bigint": (x, y) => x >> y,
    "SparseMatrix, number | BigNumber": typed2.referToSelf((self) => (x, y) => {
      if (equalScalar2(y, 0)) {
        return x.clone();
      }
      return matAlgo11xS0s(x, y, self, false);
    }),
    "DenseMatrix, number | BigNumber": typed2.referToSelf((self) => (x, y) => {
      if (equalScalar2(y, 0)) {
        return x.clone();
      }
      return matAlgo14xDs(x, y, self, false);
    }),
    "number | BigNumber, SparseMatrix": typed2.referToSelf((self) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo10xSids(y, x, self, true);
    }),
    "number | BigNumber, DenseMatrix": typed2.referToSelf((self) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo14xDs(y, x, self, true);
    })
  }, useMatrixForArrayScalar, matrixAlgorithmSuite({
    SS: matAlgo08xS0Sid,
    DS: matAlgo01xDSid,
    SD: matAlgo02xDS0
  }));
});

// node_modules/mathjs/lib/esm/function/bitwise/rightLogShift.js
var name104 = "rightLogShift";
var dependencies104 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
var createRightLogShift = factory(name104, dependencies104, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo08xS0Sid = createMatAlgo08xS0Sid({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat3
  });
  var useMatrixForArrayScalar = createUseMatrixForArrayScalar({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name104, {
    "number, number": rightLogShiftNumber,
    // 'BigNumber, BigNumber': ..., // TODO: implement BigNumber support for rightLogShift
    "SparseMatrix, number | BigNumber": typed2.referToSelf((self) => (x, y) => {
      if (equalScalar2(y, 0)) {
        return x.clone();
      }
      return matAlgo11xS0s(x, y, self, false);
    }),
    "DenseMatrix, number | BigNumber": typed2.referToSelf((self) => (x, y) => {
      if (equalScalar2(y, 0)) {
        return x.clone();
      }
      return matAlgo14xDs(x, y, self, false);
    }),
    "number | BigNumber, SparseMatrix": typed2.referToSelf((self) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo10xSids(y, x, self, true);
    }),
    "number | BigNumber, DenseMatrix": typed2.referToSelf((self) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo14xDs(y, x, self, true);
    })
  }, useMatrixForArrayScalar, matrixAlgorithmSuite({
    SS: matAlgo08xS0Sid,
    DS: matAlgo01xDSid,
    SD: matAlgo02xDS0
  }));
});

// node_modules/mathjs/lib/esm/function/logical/and.js
var name105 = "and";
var dependencies105 = ["typed", "matrix", "equalScalar", "zeros", "not", "concat"];
var createAnd = factory(name105, dependencies105, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    not: not2,
    concat: concat3
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo06xS0S0 = createMatAlgo06xS0S0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat3
  });
  return typed2(name105, {
    "number, number": andNumber,
    "Complex, Complex": function Complex_Complex(x, y) {
      return (x.re !== 0 || x.im !== 0) && (y.re !== 0 || y.im !== 0);
    },
    "BigNumber, BigNumber": function BigNumber_BigNumber(x, y) {
      return !x.isZero() && !y.isZero() && !x.isNaN() && !y.isNaN();
    },
    "bigint, bigint": andNumber,
    "Unit, Unit": typed2.referToSelf((self) => (x, y) => self(x.value || 0, y.value || 0)),
    "SparseMatrix, any": typed2.referToSelf((self) => (x, y) => {
      if (not2(y)) {
        return zeros2(x.size(), x.storage());
      }
      return matAlgo11xS0s(x, y, self, false);
    }),
    "DenseMatrix, any": typed2.referToSelf((self) => (x, y) => {
      if (not2(y)) {
        return zeros2(x.size(), x.storage());
      }
      return matAlgo14xDs(x, y, self, false);
    }),
    "any, SparseMatrix": typed2.referToSelf((self) => (x, y) => {
      if (not2(x)) {
        return zeros2(x.size(), x.storage());
      }
      return matAlgo11xS0s(y, x, self, true);
    }),
    "any, DenseMatrix": typed2.referToSelf((self) => (x, y) => {
      if (not2(x)) {
        return zeros2(x.size(), x.storage());
      }
      return matAlgo14xDs(y, x, self, true);
    }),
    "Array, any": typed2.referToSelf((self) => (x, y) => {
      return self(matrix2(x), y).valueOf();
    }),
    "any, Array": typed2.referToSelf((self) => (x, y) => {
      return self(x, matrix2(y)).valueOf();
    })
  }, matrixAlgorithmSuite({
    SS: matAlgo06xS0S0,
    DS: matAlgo02xDS0
  }));
});

// node_modules/mathjs/lib/esm/function/matrix/sort.js
var name106 = "sort";
var dependencies106 = ["typed", "matrix", "compare", "compareNatural"];
var createSort = factory(name106, dependencies106, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    compare: compare2,
    compareNatural: compareNatural2
  } = _ref;
  var compareAsc = compare2;
  var compareDesc = (a, b) => -compare2(a, b);
  return typed2(name106, {
    Array: function Array2(x) {
      _arrayIsVector(x);
      return x.sort(compareAsc);
    },
    Matrix: function Matrix2(x) {
      _matrixIsVector(x);
      return matrix2(x.toArray().sort(compareAsc), x.storage());
    },
    "Array, function": function Array_function(x, _comparator2) {
      _arrayIsVector(x);
      return x.sort(_comparator2);
    },
    "Matrix, function": function Matrix_function(x, _comparator2) {
      _matrixIsVector(x);
      return matrix2(x.toArray().sort(_comparator2), x.storage());
    },
    "Array, string": function Array_string(x, order) {
      _arrayIsVector(x);
      return x.sort(_comparator(order));
    },
    "Matrix, string": function Matrix_string(x, order) {
      _matrixIsVector(x);
      return matrix2(x.toArray().sort(_comparator(order)), x.storage());
    }
  });
  function _comparator(order) {
    if (order === "asc") {
      return compareAsc;
    } else if (order === "desc") {
      return compareDesc;
    } else if (order === "natural") {
      return compareNatural2;
    } else {
      throw new Error('String "asc", "desc", or "natural" expected');
    }
  }
  function _arrayIsVector(array) {
    if (arraySize(array).length !== 1) {
      throw new Error("One dimensional array expected");
    }
  }
  function _matrixIsVector(matrix3) {
    if (matrix3.size().length !== 1) {
      throw new Error("One dimensional matrix expected");
    }
  }
});

// node_modules/mathjs/lib/esm/type/matrix/ImmutableDenseMatrix.js
var name107 = "ImmutableDenseMatrix";
var dependencies107 = ["smaller", "DenseMatrix"];
var createImmutableDenseMatrixClass = factory(name107, dependencies107, (_ref) => {
  var {
    smaller: smaller2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  function ImmutableDenseMatrix2(data, datatype) {
    if (!(this instanceof ImmutableDenseMatrix2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (datatype && !isString(datatype)) {
      throw new Error("Invalid datatype: " + datatype);
    }
    if (isMatrix(data) || isArray(data)) {
      var matrix2 = new DenseMatrix2(data, datatype);
      this._data = matrix2._data;
      this._size = matrix2._size;
      this._datatype = matrix2._datatype;
      this._min = null;
      this._max = null;
    } else if (data && isArray(data.data) && isArray(data.size)) {
      this._data = data.data;
      this._size = data.size;
      this._datatype = data.datatype;
      this._min = typeof data.min !== "undefined" ? data.min : null;
      this._max = typeof data.max !== "undefined" ? data.max : null;
    } else if (data) {
      throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
    } else {
      this._data = [];
      this._size = [0];
      this._datatype = datatype;
      this._min = null;
      this._max = null;
    }
  }
  ImmutableDenseMatrix2.prototype = new DenseMatrix2();
  ImmutableDenseMatrix2.prototype.type = "ImmutableDenseMatrix";
  ImmutableDenseMatrix2.prototype.isImmutableDenseMatrix = true;
  ImmutableDenseMatrix2.prototype.subset = function(index2) {
    switch (arguments.length) {
      case 1: {
        var m = DenseMatrix2.prototype.subset.call(this, index2);
        if (isMatrix(m)) {
          return new ImmutableDenseMatrix2({
            data: m._data,
            size: m._size,
            datatype: m._datatype
          });
        }
        return m;
      }
      // intentional fall through
      case 2:
      case 3:
        throw new Error("Cannot invoke set subset on an Immutable Matrix instance");
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  };
  ImmutableDenseMatrix2.prototype.set = function() {
    throw new Error("Cannot invoke set on an Immutable Matrix instance");
  };
  ImmutableDenseMatrix2.prototype.resize = function() {
    throw new Error("Cannot invoke resize on an Immutable Matrix instance");
  };
  ImmutableDenseMatrix2.prototype.reshape = function() {
    throw new Error("Cannot invoke reshape on an Immutable Matrix instance");
  };
  ImmutableDenseMatrix2.prototype.clone = function() {
    return new ImmutableDenseMatrix2({
      data: clone(this._data),
      size: clone(this._size),
      datatype: this._datatype
    });
  };
  ImmutableDenseMatrix2.prototype.toJSON = function() {
    return {
      mathjs: "ImmutableDenseMatrix",
      data: this._data,
      size: this._size,
      datatype: this._datatype
    };
  };
  ImmutableDenseMatrix2.fromJSON = function(json) {
    return new ImmutableDenseMatrix2(json);
  };
  ImmutableDenseMatrix2.prototype.swapRows = function() {
    throw new Error("Cannot invoke swapRows on an Immutable Matrix instance");
  };
  ImmutableDenseMatrix2.prototype.min = function() {
    if (this._min === null) {
      var m = null;
      this.forEach(function(v) {
        if (m === null || smaller2(v, m)) {
          m = v;
        }
      });
      this._min = m !== null ? m : void 0;
    }
    return this._min;
  };
  ImmutableDenseMatrix2.prototype.max = function() {
    if (this._max === null) {
      var m = null;
      this.forEach(function(v) {
        if (m === null || smaller2(m, v)) {
          m = v;
        }
      });
      this._max = m !== null ? m : void 0;
    }
    return this._max;
  };
  return ImmutableDenseMatrix2;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/matrix/MatrixIndex.js
var name108 = "Index";
var dependencies108 = ["ImmutableDenseMatrix", "getMatrixDataType"];
var createIndexClass = factory(name108, dependencies108, (_ref) => {
  var {
    ImmutableDenseMatrix: ImmutableDenseMatrix2,
    getMatrixDataType: getMatrixDataType2
  } = _ref;
  function Index2(ranges) {
    if (!(this instanceof Index2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this._dimensions = [];
    this._sourceSize = [];
    this._isScalar = true;
    for (var i2 = 0, ii = arguments.length; i2 < ii; i2++) {
      var arg2 = arguments[i2];
      var argIsArray = isArray(arg2);
      var argIsMatrix = isMatrix(arg2);
      var argType = typeof arg2;
      var sourceSize = null;
      if (isRange(arg2)) {
        this._dimensions.push(arg2);
        this._isScalar = false;
      } else if (argIsArray || argIsMatrix) {
        var m = void 0;
        if (getMatrixDataType2(arg2) === "boolean") {
          if (argIsArray) m = _createImmutableMatrix(_booleansArrayToNumbersForIndex(arg2).valueOf());
          if (argIsMatrix) m = _createImmutableMatrix(_booleansArrayToNumbersForIndex(arg2._data).valueOf());
          sourceSize = arg2.valueOf().length;
        } else {
          m = _createImmutableMatrix(arg2.valueOf());
        }
        this._dimensions.push(m);
        var size2 = m.size();
        if (size2.length !== 1 || size2[0] !== 1 || sourceSize !== null) {
          this._isScalar = false;
        }
      } else if (argType === "number") {
        this._dimensions.push(_createImmutableMatrix([arg2]));
      } else if (argType === "bigint") {
        this._dimensions.push(_createImmutableMatrix([Number(arg2)]));
      } else if (argType === "string") {
        this._dimensions.push(arg2);
      } else {
        throw new TypeError("Dimension must be an Array, Matrix, number, bigint, string, or Range");
      }
      this._sourceSize.push(sourceSize);
    }
  }
  Index2.prototype.type = "Index";
  Index2.prototype.isIndex = true;
  function _createImmutableMatrix(arg2) {
    for (var i2 = 0, l = arg2.length; i2 < l; i2++) {
      if (typeof arg2[i2] !== "number" || !isInteger(arg2[i2])) {
        throw new TypeError("Index parameters must be positive integer numbers");
      }
    }
    return new ImmutableDenseMatrix2(arg2);
  }
  Index2.prototype.clone = function() {
    var index2 = new Index2();
    index2._dimensions = clone(this._dimensions);
    index2._isScalar = this._isScalar;
    index2._sourceSize = this._sourceSize;
    return index2;
  };
  Index2.create = function(ranges) {
    var index2 = new Index2();
    Index2.apply(index2, ranges);
    return index2;
  };
  Index2.prototype.size = function() {
    var size2 = [];
    for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
      var d = this._dimensions[i2];
      size2[i2] = typeof d === "string" ? 1 : d.size()[0];
    }
    return size2;
  };
  Index2.prototype.max = function() {
    var values = [];
    for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
      var range2 = this._dimensions[i2];
      values[i2] = typeof range2 === "string" ? range2 : range2.max();
    }
    return values;
  };
  Index2.prototype.min = function() {
    var values = [];
    for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
      var range2 = this._dimensions[i2];
      values[i2] = typeof range2 === "string" ? range2 : range2.min();
    }
    return values;
  };
  Index2.prototype.forEach = function(callback) {
    for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
      callback(this._dimensions[i2], i2, this);
    }
  };
  Index2.prototype.dimension = function(dim) {
    if (typeof dim !== "number") {
      return null;
    }
    return this._dimensions[dim] || null;
  };
  Index2.prototype.isObjectProperty = function() {
    return this._dimensions.length === 1 && typeof this._dimensions[0] === "string";
  };
  Index2.prototype.getObjectProperty = function() {
    return this.isObjectProperty() ? this._dimensions[0] : null;
  };
  Index2.prototype.isScalar = function() {
    return this._isScalar;
  };
  Index2.prototype.toArray = function() {
    var array = [];
    for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
      var dimension = this._dimensions[i2];
      array.push(typeof dimension === "string" ? dimension : dimension.toArray());
    }
    return array;
  };
  Index2.prototype.valueOf = Index2.prototype.toArray;
  Index2.prototype.toString = function() {
    var strings = [];
    for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
      var dimension = this._dimensions[i2];
      if (typeof dimension === "string") {
        strings.push(JSON.stringify(dimension));
      } else {
        strings.push(dimension.toString());
      }
    }
    return "[" + strings.join(", ") + "]";
  };
  Index2.prototype.toJSON = function() {
    return {
      mathjs: "Index",
      dimensions: this._dimensions
    };
  };
  Index2.fromJSON = function(json) {
    return Index2.create(json.dimensions);
  };
  return Index2;
}, {
  isClass: true
});
function _booleansArrayToNumbersForIndex(booleanArrayIndex) {
  var indexOfNumbers = [];
  booleanArrayIndex.forEach((bool, idx) => {
    if (bool) {
      indexOfNumbers.push(idx);
    }
  });
  return indexOfNumbers;
}

// node_modules/mathjs/lib/esm/type/matrix/FibonacciHeap.js
var name109 = "FibonacciHeap";
var dependencies109 = ["smaller", "larger"];
var createFibonacciHeapClass = factory(name109, dependencies109, (_ref) => {
  var {
    smaller: smaller2,
    larger: larger2
  } = _ref;
  var oneOverLogPhi = 1 / Math.log((1 + Math.sqrt(5)) / 2);
  function FibonacciHeap2() {
    if (!(this instanceof FibonacciHeap2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this._minimum = null;
    this._size = 0;
  }
  FibonacciHeap2.prototype.type = "FibonacciHeap";
  FibonacciHeap2.prototype.isFibonacciHeap = true;
  FibonacciHeap2.prototype.insert = function(key, value) {
    var node = {
      key,
      value,
      degree: 0
    };
    if (this._minimum) {
      var minimum = this._minimum;
      node.left = minimum;
      node.right = minimum.right;
      minimum.right = node;
      node.right.left = node;
      if (smaller2(key, minimum.key)) {
        this._minimum = node;
      }
    } else {
      node.left = node;
      node.right = node;
      this._minimum = node;
    }
    this._size++;
    return node;
  };
  FibonacciHeap2.prototype.size = function() {
    return this._size;
  };
  FibonacciHeap2.prototype.clear = function() {
    this._minimum = null;
    this._size = 0;
  };
  FibonacciHeap2.prototype.isEmpty = function() {
    return this._size === 0;
  };
  FibonacciHeap2.prototype.extractMinimum = function() {
    var node = this._minimum;
    if (node === null) {
      return node;
    }
    var minimum = this._minimum;
    var numberOfChildren = node.degree;
    var x = node.child;
    while (numberOfChildren > 0) {
      var tempRight = x.right;
      x.left.right = x.right;
      x.right.left = x.left;
      x.left = minimum;
      x.right = minimum.right;
      minimum.right = x;
      x.right.left = x;
      x.parent = null;
      x = tempRight;
      numberOfChildren--;
    }
    node.left.right = node.right;
    node.right.left = node.left;
    if (node === node.right) {
      minimum = null;
    } else {
      minimum = node.right;
      minimum = _findMinimumNode(minimum, this._size);
    }
    this._size--;
    this._minimum = minimum;
    return node;
  };
  FibonacciHeap2.prototype.remove = function(node) {
    this._minimum = _decreaseKey(this._minimum, node, -1);
    this.extractMinimum();
  };
  function _decreaseKey(minimum, node, key) {
    node.key = key;
    var parent = node.parent;
    if (parent && smaller2(node.key, parent.key)) {
      _cut(minimum, node, parent);
      _cascadingCut(minimum, parent);
    }
    if (smaller2(node.key, minimum.key)) {
      minimum = node;
    }
    return minimum;
  }
  function _cut(minimum, node, parent) {
    node.left.right = node.right;
    node.right.left = node.left;
    parent.degree--;
    if (parent.child === node) {
      parent.child = node.right;
    }
    if (parent.degree === 0) {
      parent.child = null;
    }
    node.left = minimum;
    node.right = minimum.right;
    minimum.right = node;
    node.right.left = node;
    node.parent = null;
    node.mark = false;
  }
  function _cascadingCut(minimum, node) {
    var parent = node.parent;
    if (!parent) {
      return;
    }
    if (!node.mark) {
      node.mark = true;
    } else {
      _cut(minimum, node, parent);
      _cascadingCut(parent);
    }
  }
  var _linkNodes = function _linkNodes2(node, parent) {
    node.left.right = node.right;
    node.right.left = node.left;
    node.parent = parent;
    if (!parent.child) {
      parent.child = node;
      node.right = node;
      node.left = node;
    } else {
      node.left = parent.child;
      node.right = parent.child.right;
      parent.child.right = node;
      node.right.left = node;
    }
    parent.degree++;
    node.mark = false;
  };
  function _findMinimumNode(minimum, size2) {
    var arraySize2 = Math.floor(Math.log(size2) * oneOverLogPhi) + 1;
    var array = new Array(arraySize2);
    var numRoots = 0;
    var x = minimum;
    if (x) {
      numRoots++;
      x = x.right;
      while (x !== minimum) {
        numRoots++;
        x = x.right;
      }
    }
    var y;
    while (numRoots > 0) {
      var d = x.degree;
      var next = x.right;
      while (true) {
        y = array[d];
        if (!y) {
          break;
        }
        if (larger2(x.key, y.key)) {
          var temp = y;
          y = x;
          x = temp;
        }
        _linkNodes(y, x);
        array[d] = null;
        d++;
      }
      array[d] = x;
      x = next;
      numRoots--;
    }
    minimum = null;
    for (var i2 = 0; i2 < arraySize2; i2++) {
      y = array[i2];
      if (!y) {
        continue;
      }
      if (minimum) {
        y.left.right = y.right;
        y.right.left = y.left;
        y.left = minimum;
        y.right = minimum.right;
        minimum.right = y;
        y.right.left = y;
        if (smaller2(y.key, minimum.key)) {
          minimum = y;
        }
      } else {
        minimum = y;
      }
    }
    return minimum;
  }
  return FibonacciHeap2;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/matrix/Spa.js
var name110 = "Spa";
var dependencies110 = ["addScalar", "equalScalar", "FibonacciHeap"];
var createSpaClass = factory(name110, dependencies110, (_ref) => {
  var {
    addScalar: addScalar2,
    equalScalar: equalScalar2,
    FibonacciHeap: FibonacciHeap2
  } = _ref;
  function Spa2() {
    if (!(this instanceof Spa2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this._values = [];
    this._heap = new FibonacciHeap2();
  }
  Spa2.prototype.type = "Spa";
  Spa2.prototype.isSpa = true;
  Spa2.prototype.set = function(i2, v) {
    if (!this._values[i2]) {
      var node = this._heap.insert(i2, v);
      this._values[i2] = node;
    } else {
      this._values[i2].value = v;
    }
  };
  Spa2.prototype.get = function(i2) {
    var node = this._values[i2];
    if (node) {
      return node.value;
    }
    return 0;
  };
  Spa2.prototype.accumulate = function(i2, v) {
    var node = this._values[i2];
    if (!node) {
      node = this._heap.insert(i2, v);
      this._values[i2] = node;
    } else {
      node.value = addScalar2(node.value, v);
    }
  };
  Spa2.prototype.forEach = function(from, to2, callback) {
    var heap = this._heap;
    var values = this._values;
    var nodes = [];
    var node = heap.extractMinimum();
    if (node) {
      nodes.push(node);
    }
    while (node && node.key <= to2) {
      if (node.key >= from) {
        if (!equalScalar2(node.value, 0)) {
          callback(node.key, node.value, this);
        }
      }
      node = heap.extractMinimum();
      if (node) {
        nodes.push(node);
      }
    }
    for (var i2 = 0; i2 < nodes.length; i2++) {
      var n = nodes[i2];
      node = heap.insert(n.key, n.value);
      values[node.key] = node;
    }
  };
  Spa2.prototype.swap = function(i2, j) {
    var nodei = this._values[i2];
    var nodej = this._values[j];
    if (!nodei && nodej) {
      nodei = this._heap.insert(i2, nodej.value);
      this._heap.remove(nodej);
      this._values[i2] = nodei;
      this._values[j] = void 0;
    } else if (nodei && !nodej) {
      nodej = this._heap.insert(j, nodei.value);
      this._heap.remove(nodei);
      this._values[j] = nodej;
      this._values[i2] = void 0;
    } else if (nodei && nodej) {
      var v = nodei.value;
      nodei.value = nodej.value;
      nodej.value = v;
    }
  };
  return Spa2;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/unit/Unit.js
function ownKeys2(e2, r) {
  var t = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e2, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e2) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys2(Object(t), true).forEach(function(r2) {
      _defineProperty(e2, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t)) : ownKeys2(Object(t)).forEach(function(r2) {
      Object.defineProperty(e2, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e2;
}
var name111 = "Unit";
var dependencies111 = ["?on", "config", "addScalar", "subtractScalar", "multiplyScalar", "divideScalar", "pow", "abs", "fix", "round", "equal", "isNumeric", "format", "number", "Complex", "BigNumber", "Fraction"];
var createUnitClass = factory(name111, dependencies111, (_ref) => {
  var {
    on,
    config: config2,
    addScalar: addScalar2,
    subtractScalar: subtractScalar2,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    pow: pow2,
    abs: abs2,
    fix: fix2,
    round: round2,
    equal: equal2,
    isNumeric: isNumeric2,
    format: format4,
    number: _number,
    Complex: Complex3,
    BigNumber: _BigNumber,
    Fraction: _Fraction
  } = _ref;
  var toNumber = _number;
  function Unit2(value, valuelessUnit) {
    if (!(this instanceof Unit2)) {
      throw new Error("Constructor must be called with the new operator");
    }
    if (!(value === null || value === void 0 || isNumeric2(value) || isComplex(value))) {
      throw new TypeError("First parameter in Unit constructor must be number, BigNumber, Fraction, Complex, or undefined");
    }
    this.fixPrefix = false;
    this.skipAutomaticSimplification = true;
    if (valuelessUnit === void 0) {
      this.units = [];
      this.dimensions = BASE_DIMENSIONS.map((x) => 0);
    } else if (typeof valuelessUnit === "string") {
      var u = Unit2.parse(valuelessUnit);
      this.units = u.units;
      this.dimensions = u.dimensions;
    } else if (isUnit(valuelessUnit) && valuelessUnit.value === null) {
      this.fixPrefix = valuelessUnit.fixPrefix;
      this.skipAutomaticSimplification = valuelessUnit.skipAutomaticSimplification;
      this.dimensions = valuelessUnit.dimensions.slice(0);
      this.units = valuelessUnit.units.map((u2) => _extends({}, u2));
    } else {
      throw new TypeError("Second parameter in Unit constructor must be a string or valueless Unit");
    }
    this.value = this._normalize(value);
  }
  Object.defineProperty(Unit2, "name", {
    value: "Unit"
  });
  Unit2.prototype.constructor = Unit2;
  Unit2.prototype.type = "Unit";
  Unit2.prototype.isUnit = true;
  var text, index2, c;
  function skipWhitespace() {
    while (c === " " || c === "	") {
      next();
    }
  }
  function isDigitDot(c2) {
    return c2 >= "0" && c2 <= "9" || c2 === ".";
  }
  function isDigit(c2) {
    return c2 >= "0" && c2 <= "9";
  }
  function next() {
    index2++;
    c = text.charAt(index2);
  }
  function revert(oldIndex) {
    index2 = oldIndex;
    c = text.charAt(index2);
  }
  function parseNumber() {
    var number2 = "";
    var oldIndex = index2;
    if (c === "+") {
      next();
    } else if (c === "-") {
      number2 += c;
      next();
    }
    if (!isDigitDot(c)) {
      revert(oldIndex);
      return null;
    }
    if (c === ".") {
      number2 += c;
      next();
      if (!isDigit(c)) {
        revert(oldIndex);
        return null;
      }
    } else {
      while (isDigit(c)) {
        number2 += c;
        next();
      }
      if (c === ".") {
        number2 += c;
        next();
      }
    }
    while (isDigit(c)) {
      number2 += c;
      next();
    }
    if (c === "E" || c === "e") {
      var tentativeNumber = "";
      var tentativeIndex = index2;
      tentativeNumber += c;
      next();
      if (c === "+" || c === "-") {
        tentativeNumber += c;
        next();
      }
      if (!isDigit(c)) {
        revert(tentativeIndex);
        return number2;
      }
      number2 = number2 + tentativeNumber;
      while (isDigit(c)) {
        number2 += c;
        next();
      }
    }
    return number2;
  }
  function parseUnit() {
    var unitName = "";
    while (isDigit(c) || Unit2.isValidAlpha(c)) {
      unitName += c;
      next();
    }
    var firstC = unitName.charAt(0);
    if (Unit2.isValidAlpha(firstC)) {
      return unitName;
    } else {
      return null;
    }
  }
  function parseCharacter(toFind) {
    if (c === toFind) {
      next();
      return toFind;
    } else {
      return null;
    }
  }
  Unit2.parse = function(str, options) {
    options = options || {};
    text = str;
    index2 = -1;
    c = "";
    if (typeof text !== "string") {
      throw new TypeError("Invalid argument in Unit.parse, string expected");
    }
    var unit3 = new Unit2();
    unit3.units = [];
    var powerMultiplierCurrent = 1;
    var expectingUnit = false;
    next();
    skipWhitespace();
    var valueStr = parseNumber();
    var value = null;
    if (valueStr) {
      if (config2.number === "BigNumber") {
        value = new _BigNumber(valueStr);
      } else if (config2.number === "Fraction") {
        try {
          value = new _Fraction(valueStr);
        } catch (err) {
          value = parseFloat(valueStr);
        }
      } else {
        value = parseFloat(valueStr);
      }
      skipWhitespace();
      if (parseCharacter("*")) {
        powerMultiplierCurrent = 1;
        expectingUnit = true;
      } else if (parseCharacter("/")) {
        powerMultiplierCurrent = -1;
        expectingUnit = true;
      }
    }
    var powerMultiplierStack = [];
    var powerMultiplierStackProduct = 1;
    while (true) {
      skipWhitespace();
      while (c === "(") {
        powerMultiplierStack.push(powerMultiplierCurrent);
        powerMultiplierStackProduct *= powerMultiplierCurrent;
        powerMultiplierCurrent = 1;
        next();
        skipWhitespace();
      }
      var uStr = void 0;
      if (c) {
        var oldC = c;
        uStr = parseUnit();
        if (uStr === null) {
          throw new SyntaxError('Unexpected "' + oldC + '" in "' + text + '" at index ' + index2.toString());
        }
      } else {
        break;
      }
      var res = _findUnit(uStr);
      if (res === null) {
        throw new SyntaxError('Unit "' + uStr + '" not found.');
      }
      var power = powerMultiplierCurrent * powerMultiplierStackProduct;
      skipWhitespace();
      if (parseCharacter("^")) {
        skipWhitespace();
        var p = parseNumber();
        if (p === null) {
          throw new SyntaxError('In "' + str + '", "^" must be followed by a floating-point number');
        }
        power *= p;
      }
      unit3.units.push({
        unit: res.unit,
        prefix: res.prefix,
        power
      });
      for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
        unit3.dimensions[i2] += (res.unit.dimensions[i2] || 0) * power;
      }
      skipWhitespace();
      while (c === ")") {
        if (powerMultiplierStack.length === 0) {
          throw new SyntaxError('Unmatched ")" in "' + text + '" at index ' + index2.toString());
        }
        powerMultiplierStackProduct /= powerMultiplierStack.pop();
        next();
        skipWhitespace();
      }
      expectingUnit = false;
      if (parseCharacter("*")) {
        powerMultiplierCurrent = 1;
        expectingUnit = true;
      } else if (parseCharacter("/")) {
        powerMultiplierCurrent = -1;
        expectingUnit = true;
      } else {
        powerMultiplierCurrent = 1;
      }
      if (res.unit.base) {
        var baseDim = res.unit.base.key;
        UNIT_SYSTEMS.auto[baseDim] = {
          unit: res.unit,
          prefix: res.prefix
        };
      }
    }
    skipWhitespace();
    if (c) {
      throw new SyntaxError('Could not parse: "' + str + '"');
    }
    if (expectingUnit) {
      throw new SyntaxError('Trailing characters: "' + str + '"');
    }
    if (powerMultiplierStack.length !== 0) {
      throw new SyntaxError('Unmatched "(" in "' + text + '"');
    }
    if (unit3.units.length === 0 && !options.allowNoUnits) {
      throw new SyntaxError('"' + str + '" contains no units');
    }
    unit3.value = value !== void 0 ? unit3._normalize(value) : null;
    return unit3;
  };
  Unit2.prototype.clone = function() {
    var unit3 = new Unit2();
    unit3.fixPrefix = this.fixPrefix;
    unit3.skipAutomaticSimplification = this.skipAutomaticSimplification;
    unit3.value = clone(this.value);
    unit3.dimensions = this.dimensions.slice(0);
    unit3.units = [];
    for (var i2 = 0; i2 < this.units.length; i2++) {
      unit3.units[i2] = {};
      for (var p in this.units[i2]) {
        if (hasOwnProperty(this.units[i2], p)) {
          unit3.units[i2][p] = this.units[i2][p];
        }
      }
    }
    return unit3;
  };
  Unit2.prototype.valueType = function() {
    return typeOf(this.value);
  };
  Unit2.prototype._isDerived = function() {
    if (this.units.length === 0) {
      return false;
    }
    return this.units.length > 1 || Math.abs(this.units[0].power - 1) > 1e-15;
  };
  Unit2.prototype._normalize = function(value) {
    if (value === null || value === void 0 || this.units.length === 0) {
      return value;
    }
    var res = value;
    var convert = Unit2._getNumberConverter(typeOf(value));
    for (var i2 = 0; i2 < this.units.length; i2++) {
      var unitValue = convert(this.units[i2].unit.value);
      var unitPrefixValue = convert(this.units[i2].prefix.value);
      var unitPower = convert(this.units[i2].power);
      res = multiplyScalar2(res, pow2(multiplyScalar2(unitValue, unitPrefixValue), unitPower));
    }
    return res;
  };
  Unit2.prototype._denormalize = function(value, prefixValue) {
    if (value === null || value === void 0 || this.units.length === 0) {
      return value;
    }
    var res = value;
    var convert = Unit2._getNumberConverter(typeOf(value));
    for (var i2 = 0; i2 < this.units.length; i2++) {
      var unitValue = convert(this.units[i2].unit.value);
      var unitPrefixValue = convert(this.units[i2].prefix.value);
      var unitPower = convert(this.units[i2].power);
      res = divideScalar2(res, pow2(multiplyScalar2(unitValue, unitPrefixValue), unitPower));
    }
    return res;
  };
  var _findUnit = memoize((str) => {
    if (hasOwnProperty(UNITS, str)) {
      var unit3 = UNITS[str];
      var prefix = unit3.prefixes[""];
      return {
        unit: unit3,
        prefix
      };
    }
    for (var _name in UNITS) {
      if (hasOwnProperty(UNITS, _name)) {
        if (endsWith(str, _name)) {
          var _unit = UNITS[_name];
          var prefixLen = str.length - _name.length;
          var prefixName = str.substring(0, prefixLen);
          var _prefix = hasOwnProperty(_unit.prefixes, prefixName) ? _unit.prefixes[prefixName] : void 0;
          if (_prefix !== void 0) {
            return {
              unit: _unit,
              prefix: _prefix
            };
          }
        }
      }
    }
    return null;
  }, {
    hasher: (args) => args[0],
    limit: 100
  });
  Unit2.isValuelessUnit = function(name197) {
    return _findUnit(name197) !== null;
  };
  Unit2.prototype.hasBase = function(base) {
    if (typeof base === "string") {
      base = BASE_UNITS[base];
    }
    if (!base) {
      return false;
    }
    for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
      if (Math.abs((this.dimensions[i2] || 0) - (base.dimensions[i2] || 0)) > 1e-12) {
        return false;
      }
    }
    return true;
  };
  Unit2.prototype.equalBase = function(other) {
    for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
      if (Math.abs((this.dimensions[i2] || 0) - (other.dimensions[i2] || 0)) > 1e-12) {
        return false;
      }
    }
    return true;
  };
  Unit2.prototype.equals = function(other) {
    return this.equalBase(other) && equal2(this.value, other.value);
  };
  Unit2.prototype.multiply = function(_other) {
    var res = this.clone();
    var other = isUnit(_other) ? _other : new Unit2(_other);
    for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
      res.dimensions[i2] = (this.dimensions[i2] || 0) + (other.dimensions[i2] || 0);
    }
    for (var _i = 0; _i < other.units.length; _i++) {
      var inverted = _objectSpread2({}, other.units[_i]);
      res.units.push(inverted);
    }
    if (this.value !== null || other.value !== null) {
      var valThis = this.value === null ? this._normalize(1) : this.value;
      var valOther = other.value === null ? other._normalize(1) : other.value;
      res.value = multiplyScalar2(valThis, valOther);
    } else {
      res.value = null;
    }
    if (isUnit(_other)) {
      res.skipAutomaticSimplification = false;
    }
    return getNumericIfUnitless(res);
  };
  Unit2.prototype.divideInto = function(numerator) {
    return new Unit2(numerator).divide(this);
  };
  Unit2.prototype.divide = function(_other) {
    var res = this.clone();
    var other = isUnit(_other) ? _other : new Unit2(_other);
    for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
      res.dimensions[i2] = (this.dimensions[i2] || 0) - (other.dimensions[i2] || 0);
    }
    for (var _i2 = 0; _i2 < other.units.length; _i2++) {
      var inverted = _objectSpread2(_objectSpread2({}, other.units[_i2]), {}, {
        power: -other.units[_i2].power
      });
      res.units.push(inverted);
    }
    if (this.value !== null || other.value !== null) {
      var valThis = this.value === null ? this._normalize(1) : this.value;
      var valOther = other.value === null ? other._normalize(1) : other.value;
      res.value = divideScalar2(valThis, valOther);
    } else {
      res.value = null;
    }
    if (isUnit(_other)) {
      res.skipAutomaticSimplification = false;
    }
    return getNumericIfUnitless(res);
  };
  Unit2.prototype.pow = function(p) {
    var res = this.clone();
    for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
      res.dimensions[i2] = (this.dimensions[i2] || 0) * p;
    }
    for (var _i3 = 0; _i3 < res.units.length; _i3++) {
      res.units[_i3].power *= p;
    }
    if (res.value !== null) {
      res.value = pow2(res.value, p);
    } else {
      res.value = null;
    }
    res.skipAutomaticSimplification = false;
    return getNumericIfUnitless(res);
  };
  function getNumericIfUnitless(unit3) {
    if (unit3.equalBase(BASE_UNITS.NONE) && unit3.value !== null && !config2.predictable) {
      return unit3.value;
    } else {
      return unit3;
    }
  }
  Unit2.prototype.abs = function() {
    var ret = this.clone();
    if (ret.value !== null) {
      if (ret._isDerived() || ret.units.length === 0 || ret.units[0].unit.offset === 0) {
        ret.value = abs2(ret.value);
      } else {
        var convert = ret._numberConverter();
        var unitValue = convert(ret.units[0].unit.value);
        var nominalOffset = convert(ret.units[0].unit.offset);
        var unitOffset = multiplyScalar2(unitValue, nominalOffset);
        ret.value = subtractScalar2(abs2(addScalar2(ret.value, unitOffset)), unitOffset);
      }
    }
    for (var i2 in ret.units) {
      if (ret.units[i2].unit.name === "VA" || ret.units[i2].unit.name === "VAR") {
        ret.units[i2].unit = UNITS.W;
      }
    }
    return ret;
  };
  Unit2.prototype.to = function(valuelessUnit) {
    var value = this.value === null ? this._normalize(1) : this.value;
    var other;
    if (typeof valuelessUnit === "string") {
      other = Unit2.parse(valuelessUnit);
    } else if (isUnit(valuelessUnit)) {
      other = valuelessUnit.clone();
    } else {
      throw new Error("String or Unit expected as parameter");
    }
    if (!this.equalBase(other)) {
      throw new Error("Units do not match ('".concat(other.toString(), "' != '").concat(this.toString(), "')"));
    }
    if (other.value !== null) {
      throw new Error("Cannot convert to a unit with a value");
    }
    if (this.value === null || this._isDerived() || this.units.length === 0 || other.units.length === 0 || this.units[0].unit.offset === other.units[0].unit.offset) {
      other.value = clone(value);
    } else {
      var convert = Unit2._getNumberConverter(typeOf(value));
      var thisUnitValue = this.units[0].unit.value;
      var thisNominalOffset = this.units[0].unit.offset;
      var thisUnitOffset = multiplyScalar2(thisUnitValue, thisNominalOffset);
      var otherUnitValue = other.units[0].unit.value;
      var otherNominalOffset = other.units[0].unit.offset;
      var otherUnitOffset = multiplyScalar2(otherUnitValue, otherNominalOffset);
      other.value = addScalar2(value, convert(subtractScalar2(thisUnitOffset, otherUnitOffset)));
    }
    other.fixPrefix = true;
    other.skipAutomaticSimplification = true;
    return other;
  };
  Unit2.prototype.toNumber = function(valuelessUnit) {
    return toNumber(this.toNumeric(valuelessUnit));
  };
  Unit2.prototype.toNumeric = function(valuelessUnit) {
    var other;
    if (valuelessUnit) {
      other = this.to(valuelessUnit);
    } else {
      other = this.clone();
    }
    if (other._isDerived() || other.units.length === 0) {
      return other._denormalize(other.value);
    } else {
      return other._denormalize(other.value, other.units[0].prefix.value);
    }
  };
  Unit2.prototype.toString = function() {
    return this.format();
  };
  Unit2.prototype.toJSON = function() {
    return {
      mathjs: "Unit",
      value: this._denormalize(this.value),
      unit: this.units.length > 0 ? this.formatUnits() : null,
      fixPrefix: this.fixPrefix
    };
  };
  Unit2.fromJSON = function(json) {
    var _json$unit;
    var unit3 = new Unit2(json.value, (_json$unit = json.unit) !== null && _json$unit !== void 0 ? _json$unit : void 0);
    unit3.fixPrefix = json.fixPrefix || false;
    return unit3;
  };
  Unit2.prototype.valueOf = Unit2.prototype.toString;
  Unit2.prototype.simplify = function() {
    var ret = this.clone();
    var proposedUnitList = [];
    var matchingBase;
    for (var key2 in currentUnitSystem) {
      if (hasOwnProperty(currentUnitSystem, key2)) {
        if (ret.hasBase(BASE_UNITS[key2])) {
          matchingBase = key2;
          break;
        }
      }
    }
    if (matchingBase === "NONE") {
      ret.units = [];
    } else {
      var matchingUnit;
      if (matchingBase) {
        if (hasOwnProperty(currentUnitSystem, matchingBase)) {
          matchingUnit = currentUnitSystem[matchingBase];
        }
      }
      if (matchingUnit) {
        ret.units = [{
          unit: matchingUnit.unit,
          prefix: matchingUnit.prefix,
          power: 1
        }];
      } else {
        var missingBaseDim = false;
        for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
          var baseDim = BASE_DIMENSIONS[i2];
          if (Math.abs(ret.dimensions[i2] || 0) > 1e-12) {
            if (hasOwnProperty(currentUnitSystem, baseDim)) {
              proposedUnitList.push({
                unit: currentUnitSystem[baseDim].unit,
                prefix: currentUnitSystem[baseDim].prefix,
                power: ret.dimensions[i2] || 0
              });
            } else {
              missingBaseDim = true;
            }
          }
        }
        if (proposedUnitList.length < ret.units.length && !missingBaseDim) {
          ret.units = proposedUnitList;
        }
      }
    }
    return ret;
  };
  Unit2.prototype.toSI = function() {
    var ret = this.clone();
    var proposedUnitList = [];
    for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
      var baseDim = BASE_DIMENSIONS[i2];
      if (Math.abs(ret.dimensions[i2] || 0) > 1e-12) {
        if (hasOwnProperty(UNIT_SYSTEMS.si, baseDim)) {
          proposedUnitList.push({
            unit: UNIT_SYSTEMS.si[baseDim].unit,
            prefix: UNIT_SYSTEMS.si[baseDim].prefix,
            power: ret.dimensions[i2] || 0
          });
        } else {
          throw new Error("Cannot express custom unit " + baseDim + " in SI units");
        }
      }
    }
    ret.units = proposedUnitList;
    ret.fixPrefix = true;
    ret.skipAutomaticSimplification = true;
    if (this.value !== null) {
      ret.value = null;
      return this.to(ret);
    }
    return ret;
  };
  Unit2.prototype.formatUnits = function() {
    var strNum = "";
    var strDen = "";
    var nNum = 0;
    var nDen = 0;
    for (var i2 = 0; i2 < this.units.length; i2++) {
      if (this.units[i2].power > 0) {
        nNum++;
        strNum += " " + this.units[i2].prefix.name + this.units[i2].unit.name;
        if (Math.abs(this.units[i2].power - 1) > 1e-15) {
          strNum += "^" + this.units[i2].power;
        }
      } else if (this.units[i2].power < 0) {
        nDen++;
      }
    }
    if (nDen > 0) {
      for (var _i4 = 0; _i4 < this.units.length; _i4++) {
        if (this.units[_i4].power < 0) {
          if (nNum > 0) {
            strDen += " " + this.units[_i4].prefix.name + this.units[_i4].unit.name;
            if (Math.abs(this.units[_i4].power + 1) > 1e-15) {
              strDen += "^" + -this.units[_i4].power;
            }
          } else {
            strDen += " " + this.units[_i4].prefix.name + this.units[_i4].unit.name;
            strDen += "^" + this.units[_i4].power;
          }
        }
      }
    }
    strNum = strNum.substr(1);
    strDen = strDen.substr(1);
    if (nNum > 1 && nDen > 0) {
      strNum = "(" + strNum + ")";
    }
    if (nDen > 1 && nNum > 0) {
      strDen = "(" + strDen + ")";
    }
    var str = strNum;
    if (nNum > 0 && nDen > 0) {
      str += " / ";
    }
    str += strDen;
    return str;
  };
  Unit2.prototype.format = function(options) {
    var simp = this.skipAutomaticSimplification || this.value === null ? this.clone() : this.simplify();
    var isImaginary = false;
    if (typeof simp.value !== "undefined" && simp.value !== null && isComplex(simp.value)) {
      isImaginary = Math.abs(simp.value.re) < 1e-14;
    }
    for (var i2 in simp.units) {
      if (hasOwnProperty(simp.units, i2)) {
        if (simp.units[i2].unit) {
          if (simp.units[i2].unit.name === "VA" && isImaginary) {
            simp.units[i2].unit = UNITS.VAR;
          } else if (simp.units[i2].unit.name === "VAR" && !isImaginary) {
            simp.units[i2].unit = UNITS.VA;
          }
        }
      }
    }
    if (simp.units.length === 1 && !simp.fixPrefix) {
      if (Math.abs(simp.units[0].power - Math.round(simp.units[0].power)) < 1e-14) {
        simp.units[0].prefix = simp._bestPrefix();
      }
    }
    var value = simp._denormalize(simp.value);
    var str = simp.value !== null ? format4(value, options || {}) : "";
    var unitStr = simp.formatUnits();
    if (simp.value && isComplex(simp.value)) {
      str = "(" + str + ")";
    }
    if (unitStr.length > 0 && str.length > 0) {
      str += " ";
    }
    str += unitStr;
    return str;
  };
  Unit2.prototype._bestPrefix = function() {
    if (this.units.length !== 1) {
      throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
    }
    if (Math.abs(this.units[0].power - Math.round(this.units[0].power)) >= 1e-14) {
      throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
    }
    var absValue = this.value !== null ? abs2(this.value) : 0;
    var absUnitValue = abs2(this.units[0].unit.value);
    var bestPrefix = this.units[0].prefix;
    if (absValue === 0) {
      return bestPrefix;
    }
    var power = this.units[0].power;
    var bestDiff = Math.log(absValue / Math.pow(bestPrefix.value * absUnitValue, power)) / Math.LN10 - 1.2;
    if (bestDiff > -2.200001 && bestDiff < 1.800001) return bestPrefix;
    bestDiff = Math.abs(bestDiff);
    var prefixes = this.units[0].unit.prefixes;
    for (var p in prefixes) {
      if (hasOwnProperty(prefixes, p)) {
        var prefix = prefixes[p];
        if (prefix.scientific) {
          var diff2 = Math.abs(Math.log(absValue / Math.pow(prefix.value * absUnitValue, power)) / Math.LN10 - 1.2);
          if (diff2 < bestDiff || diff2 === bestDiff && prefix.name.length < bestPrefix.name.length) {
            bestPrefix = prefix;
            bestDiff = diff2;
          }
        }
      }
    }
    return bestPrefix;
  };
  Unit2.prototype.splitUnit = function(parts) {
    var x = this.clone();
    var ret = [];
    for (var i2 = 0; i2 < parts.length; i2++) {
      x = x.to(parts[i2]);
      if (i2 === parts.length - 1) break;
      var xNumeric = x.toNumeric();
      var xRounded = round2(xNumeric);
      var xFixed = void 0;
      var isNearlyEqual = equal2(xRounded, xNumeric);
      if (isNearlyEqual) {
        xFixed = xRounded;
      } else {
        xFixed = fix2(x.toNumeric());
      }
      var y = new Unit2(xFixed, parts[i2].toString());
      ret.push(y);
      x = subtractScalar2(x, y);
    }
    var testSum = 0;
    for (var _i5 = 0; _i5 < ret.length; _i5++) {
      testSum = addScalar2(testSum, ret[_i5].value);
    }
    if (equal2(testSum, this.value)) {
      x.value = 0;
    }
    ret.push(x);
    return ret;
  };
  var PREFIXES = {
    NONE: {
      "": {
        name: "",
        value: 1,
        scientific: true
      }
    },
    SHORT: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      da: {
        name: "da",
        value: 10,
        scientific: false
      },
      h: {
        name: "h",
        value: 100,
        scientific: false
      },
      k: {
        name: "k",
        value: 1e3,
        scientific: true
      },
      M: {
        name: "M",
        value: 1e6,
        scientific: true
      },
      G: {
        name: "G",
        value: 1e9,
        scientific: true
      },
      T: {
        name: "T",
        value: 1e12,
        scientific: true
      },
      P: {
        name: "P",
        value: 1e15,
        scientific: true
      },
      E: {
        name: "E",
        value: 1e18,
        scientific: true
      },
      Z: {
        name: "Z",
        value: 1e21,
        scientific: true
      },
      Y: {
        name: "Y",
        value: 1e24,
        scientific: true
      },
      R: {
        name: "R",
        value: 1e27,
        scientific: true
      },
      Q: {
        name: "Q",
        value: 1e30,
        scientific: true
      },
      d: {
        name: "d",
        value: 0.1,
        scientific: false
      },
      c: {
        name: "c",
        value: 0.01,
        scientific: false
      },
      m: {
        name: "m",
        value: 1e-3,
        scientific: true
      },
      u: {
        name: "u",
        value: 1e-6,
        scientific: true
      },
      n: {
        name: "n",
        value: 1e-9,
        scientific: true
      },
      p: {
        name: "p",
        value: 1e-12,
        scientific: true
      },
      f: {
        name: "f",
        value: 1e-15,
        scientific: true
      },
      a: {
        name: "a",
        value: 1e-18,
        scientific: true
      },
      z: {
        name: "z",
        value: 1e-21,
        scientific: true
      },
      y: {
        name: "y",
        value: 1e-24,
        scientific: true
      },
      r: {
        name: "r",
        value: 1e-27,
        scientific: true
      },
      q: {
        name: "q",
        value: 1e-30,
        scientific: true
      }
    },
    LONG: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      deca: {
        name: "deca",
        value: 10,
        scientific: false
      },
      hecto: {
        name: "hecto",
        value: 100,
        scientific: false
      },
      kilo: {
        name: "kilo",
        value: 1e3,
        scientific: true
      },
      mega: {
        name: "mega",
        value: 1e6,
        scientific: true
      },
      giga: {
        name: "giga",
        value: 1e9,
        scientific: true
      },
      tera: {
        name: "tera",
        value: 1e12,
        scientific: true
      },
      peta: {
        name: "peta",
        value: 1e15,
        scientific: true
      },
      exa: {
        name: "exa",
        value: 1e18,
        scientific: true
      },
      zetta: {
        name: "zetta",
        value: 1e21,
        scientific: true
      },
      yotta: {
        name: "yotta",
        value: 1e24,
        scientific: true
      },
      ronna: {
        name: "ronna",
        value: 1e27,
        scientific: true
      },
      quetta: {
        name: "quetta",
        value: 1e30,
        scientific: true
      },
      deci: {
        name: "deci",
        value: 0.1,
        scientific: false
      },
      centi: {
        name: "centi",
        value: 0.01,
        scientific: false
      },
      milli: {
        name: "milli",
        value: 1e-3,
        scientific: true
      },
      micro: {
        name: "micro",
        value: 1e-6,
        scientific: true
      },
      nano: {
        name: "nano",
        value: 1e-9,
        scientific: true
      },
      pico: {
        name: "pico",
        value: 1e-12,
        scientific: true
      },
      femto: {
        name: "femto",
        value: 1e-15,
        scientific: true
      },
      atto: {
        name: "atto",
        value: 1e-18,
        scientific: true
      },
      zepto: {
        name: "zepto",
        value: 1e-21,
        scientific: true
      },
      yocto: {
        name: "yocto",
        value: 1e-24,
        scientific: true
      },
      ronto: {
        name: "ronto",
        value: 1e-27,
        scientific: true
      },
      quecto: {
        name: "quecto",
        value: 1e-30,
        scientific: true
      }
    },
    SQUARED: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      da: {
        name: "da",
        value: 100,
        scientific: false
      },
      h: {
        name: "h",
        value: 1e4,
        scientific: false
      },
      k: {
        name: "k",
        value: 1e6,
        scientific: true
      },
      M: {
        name: "M",
        value: 1e12,
        scientific: true
      },
      G: {
        name: "G",
        value: 1e18,
        scientific: true
      },
      T: {
        name: "T",
        value: 1e24,
        scientific: true
      },
      P: {
        name: "P",
        value: 1e30,
        scientific: true
      },
      E: {
        name: "E",
        value: 1e36,
        scientific: true
      },
      Z: {
        name: "Z",
        value: 1e42,
        scientific: true
      },
      Y: {
        name: "Y",
        value: 1e48,
        scientific: true
      },
      R: {
        name: "R",
        value: 1e54,
        scientific: true
      },
      Q: {
        name: "Q",
        value: 1e60,
        scientific: true
      },
      d: {
        name: "d",
        value: 0.01,
        scientific: false
      },
      c: {
        name: "c",
        value: 1e-4,
        scientific: false
      },
      m: {
        name: "m",
        value: 1e-6,
        scientific: true
      },
      u: {
        name: "u",
        value: 1e-12,
        scientific: true
      },
      n: {
        name: "n",
        value: 1e-18,
        scientific: true
      },
      p: {
        name: "p",
        value: 1e-24,
        scientific: true
      },
      f: {
        name: "f",
        value: 1e-30,
        scientific: true
      },
      a: {
        name: "a",
        value: 1e-36,
        scientific: true
      },
      z: {
        name: "z",
        value: 1e-42,
        scientific: true
      },
      y: {
        name: "y",
        value: 1e-48,
        scientific: true
      },
      r: {
        name: "r",
        value: 1e-54,
        scientific: true
      },
      q: {
        name: "q",
        value: 1e-60,
        scientific: true
      }
    },
    CUBIC: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      da: {
        name: "da",
        value: 1e3,
        scientific: false
      },
      h: {
        name: "h",
        value: 1e6,
        scientific: false
      },
      k: {
        name: "k",
        value: 1e9,
        scientific: true
      },
      M: {
        name: "M",
        value: 1e18,
        scientific: true
      },
      G: {
        name: "G",
        value: 1e27,
        scientific: true
      },
      T: {
        name: "T",
        value: 1e36,
        scientific: true
      },
      P: {
        name: "P",
        value: 1e45,
        scientific: true
      },
      E: {
        name: "E",
        value: 1e54,
        scientific: true
      },
      Z: {
        name: "Z",
        value: 1e63,
        scientific: true
      },
      Y: {
        name: "Y",
        value: 1e72,
        scientific: true
      },
      R: {
        name: "R",
        value: 1e81,
        scientific: true
      },
      Q: {
        name: "Q",
        value: 1e90,
        scientific: true
      },
      d: {
        name: "d",
        value: 1e-3,
        scientific: false
      },
      c: {
        name: "c",
        value: 1e-6,
        scientific: false
      },
      m: {
        name: "m",
        value: 1e-9,
        scientific: true
      },
      u: {
        name: "u",
        value: 1e-18,
        scientific: true
      },
      n: {
        name: "n",
        value: 1e-27,
        scientific: true
      },
      p: {
        name: "p",
        value: 1e-36,
        scientific: true
      },
      f: {
        name: "f",
        value: 1e-45,
        scientific: true
      },
      a: {
        name: "a",
        value: 1e-54,
        scientific: true
      },
      z: {
        name: "z",
        value: 1e-63,
        scientific: true
      },
      y: {
        name: "y",
        value: 1e-72,
        scientific: true
      },
      r: {
        name: "r",
        value: 1e-81,
        scientific: true
      },
      q: {
        name: "q",
        value: 1e-90,
        scientific: true
      }
    },
    BINARY_SHORT_SI: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      k: {
        name: "k",
        value: 1e3,
        scientific: true
      },
      M: {
        name: "M",
        value: 1e6,
        scientific: true
      },
      G: {
        name: "G",
        value: 1e9,
        scientific: true
      },
      T: {
        name: "T",
        value: 1e12,
        scientific: true
      },
      P: {
        name: "P",
        value: 1e15,
        scientific: true
      },
      E: {
        name: "E",
        value: 1e18,
        scientific: true
      },
      Z: {
        name: "Z",
        value: 1e21,
        scientific: true
      },
      Y: {
        name: "Y",
        value: 1e24,
        scientific: true
      }
    },
    BINARY_SHORT_IEC: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      Ki: {
        name: "Ki",
        value: 1024,
        scientific: true
      },
      Mi: {
        name: "Mi",
        value: Math.pow(1024, 2),
        scientific: true
      },
      Gi: {
        name: "Gi",
        value: Math.pow(1024, 3),
        scientific: true
      },
      Ti: {
        name: "Ti",
        value: Math.pow(1024, 4),
        scientific: true
      },
      Pi: {
        name: "Pi",
        value: Math.pow(1024, 5),
        scientific: true
      },
      Ei: {
        name: "Ei",
        value: Math.pow(1024, 6),
        scientific: true
      },
      Zi: {
        name: "Zi",
        value: Math.pow(1024, 7),
        scientific: true
      },
      Yi: {
        name: "Yi",
        value: Math.pow(1024, 8),
        scientific: true
      }
    },
    BINARY_LONG_SI: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      kilo: {
        name: "kilo",
        value: 1e3,
        scientific: true
      },
      mega: {
        name: "mega",
        value: 1e6,
        scientific: true
      },
      giga: {
        name: "giga",
        value: 1e9,
        scientific: true
      },
      tera: {
        name: "tera",
        value: 1e12,
        scientific: true
      },
      peta: {
        name: "peta",
        value: 1e15,
        scientific: true
      },
      exa: {
        name: "exa",
        value: 1e18,
        scientific: true
      },
      zetta: {
        name: "zetta",
        value: 1e21,
        scientific: true
      },
      yotta: {
        name: "yotta",
        value: 1e24,
        scientific: true
      }
    },
    BINARY_LONG_IEC: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      kibi: {
        name: "kibi",
        value: 1024,
        scientific: true
      },
      mebi: {
        name: "mebi",
        value: Math.pow(1024, 2),
        scientific: true
      },
      gibi: {
        name: "gibi",
        value: Math.pow(1024, 3),
        scientific: true
      },
      tebi: {
        name: "tebi",
        value: Math.pow(1024, 4),
        scientific: true
      },
      pebi: {
        name: "pebi",
        value: Math.pow(1024, 5),
        scientific: true
      },
      exi: {
        name: "exi",
        value: Math.pow(1024, 6),
        scientific: true
      },
      zebi: {
        name: "zebi",
        value: Math.pow(1024, 7),
        scientific: true
      },
      yobi: {
        name: "yobi",
        value: Math.pow(1024, 8),
        scientific: true
      }
    },
    BTU: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      MM: {
        name: "MM",
        value: 1e6,
        scientific: true
      }
    }
  };
  PREFIXES.SHORTLONG = _extends({}, PREFIXES.SHORT, PREFIXES.LONG);
  PREFIXES.BINARY_SHORT = _extends({}, PREFIXES.BINARY_SHORT_SI, PREFIXES.BINARY_SHORT_IEC);
  PREFIXES.BINARY_LONG = _extends({}, PREFIXES.BINARY_LONG_SI, PREFIXES.BINARY_LONG_IEC);
  var BASE_DIMENSIONS = ["MASS", "LENGTH", "TIME", "CURRENT", "TEMPERATURE", "LUMINOUS_INTENSITY", "AMOUNT_OF_SUBSTANCE", "ANGLE", "BIT"];
  var BASE_UNITS = {
    NONE: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 0]
    },
    MASS: {
      dimensions: [1, 0, 0, 0, 0, 0, 0, 0, 0]
    },
    LENGTH: {
      dimensions: [0, 1, 0, 0, 0, 0, 0, 0, 0]
    },
    TIME: {
      dimensions: [0, 0, 1, 0, 0, 0, 0, 0, 0]
    },
    CURRENT: {
      dimensions: [0, 0, 0, 1, 0, 0, 0, 0, 0]
    },
    TEMPERATURE: {
      dimensions: [0, 0, 0, 0, 1, 0, 0, 0, 0]
    },
    LUMINOUS_INTENSITY: {
      dimensions: [0, 0, 0, 0, 0, 1, 0, 0, 0]
    },
    AMOUNT_OF_SUBSTANCE: {
      dimensions: [0, 0, 0, 0, 0, 0, 1, 0, 0]
    },
    FORCE: {
      dimensions: [1, 1, -2, 0, 0, 0, 0, 0, 0]
    },
    SURFACE: {
      dimensions: [0, 2, 0, 0, 0, 0, 0, 0, 0]
    },
    VOLUME: {
      dimensions: [0, 3, 0, 0, 0, 0, 0, 0, 0]
    },
    ENERGY: {
      dimensions: [1, 2, -2, 0, 0, 0, 0, 0, 0]
    },
    POWER: {
      dimensions: [1, 2, -3, 0, 0, 0, 0, 0, 0]
    },
    PRESSURE: {
      dimensions: [1, -1, -2, 0, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CHARGE: {
      dimensions: [0, 0, 1, 1, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CAPACITANCE: {
      dimensions: [-1, -2, 4, 2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_POTENTIAL: {
      dimensions: [1, 2, -3, -1, 0, 0, 0, 0, 0]
    },
    ELECTRIC_RESISTANCE: {
      dimensions: [1, 2, -3, -2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_INDUCTANCE: {
      dimensions: [1, 2, -2, -2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CONDUCTANCE: {
      dimensions: [-1, -2, 3, 2, 0, 0, 0, 0, 0]
    },
    MAGNETIC_FLUX: {
      dimensions: [1, 2, -2, -1, 0, 0, 0, 0, 0]
    },
    MAGNETIC_FLUX_DENSITY: {
      dimensions: [1, 0, -2, -1, 0, 0, 0, 0, 0]
    },
    FREQUENCY: {
      dimensions: [0, 0, -1, 0, 0, 0, 0, 0, 0]
    },
    ANGLE: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 1, 0]
    },
    BIT: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 1]
    }
  };
  for (var key in BASE_UNITS) {
    if (hasOwnProperty(BASE_UNITS, key)) {
      BASE_UNITS[key].key = key;
    }
  }
  var BASE_UNIT_NONE = {};
  var UNIT_NONE = {
    name: "",
    base: BASE_UNIT_NONE,
    value: 1,
    offset: 0,
    dimensions: BASE_DIMENSIONS.map((x) => 0)
  };
  var UNITS = {
    // length
    meter: {
      name: "meter",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    inch: {
      name: "inch",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.0254,
      offset: 0
    },
    foot: {
      name: "foot",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.3048,
      offset: 0
    },
    yard: {
      name: "yard",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.9144,
      offset: 0
    },
    mile: {
      name: "mile",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 1609.344,
      offset: 0
    },
    link: {
      name: "link",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.201168,
      offset: 0
    },
    rod: {
      name: "rod",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 5.0292,
      offset: 0
    },
    chain: {
      name: "chain",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 20.1168,
      offset: 0
    },
    angstrom: {
      name: "angstrom",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 1e-10,
      offset: 0
    },
    m: {
      name: "m",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    in: {
      name: "in",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.0254,
      offset: 0
    },
    ft: {
      name: "ft",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.3048,
      offset: 0
    },
    yd: {
      name: "yd",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.9144,
      offset: 0
    },
    mi: {
      name: "mi",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 1609.344,
      offset: 0
    },
    li: {
      name: "li",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.201168,
      offset: 0
    },
    rd: {
      name: "rd",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 5.02921,
      offset: 0
    },
    ch: {
      name: "ch",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 20.1168,
      offset: 0
    },
    mil: {
      name: "mil",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 254e-7,
      offset: 0
    },
    // 1/1000 inch
    // Surface
    m2: {
      name: "m2",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.SQUARED,
      value: 1,
      offset: 0
    },
    sqin: {
      name: "sqin",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 64516e-8,
      offset: 0
    },
    // 645.16 mm2
    sqft: {
      name: "sqft",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 0.09290304,
      offset: 0
    },
    // 0.09290304 m2
    sqyd: {
      name: "sqyd",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 0.83612736,
      offset: 0
    },
    // 0.83612736 m2
    sqmi: {
      name: "sqmi",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 2589988110336e-6,
      offset: 0
    },
    // 2.589988110336 km2
    sqrd: {
      name: "sqrd",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 25.29295,
      offset: 0
    },
    // 25.29295 m2
    sqch: {
      name: "sqch",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 404.6873,
      offset: 0
    },
    // 404.6873 m2
    sqmil: {
      name: "sqmil",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 64516e-14,
      offset: 0
    },
    // 6.4516 * 10^-10 m2
    acre: {
      name: "acre",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 4046.86,
      offset: 0
    },
    // 4046.86 m2
    hectare: {
      name: "hectare",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 1e4,
      offset: 0
    },
    // 10000 m2
    // Volume
    m3: {
      name: "m3",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.CUBIC,
      value: 1,
      offset: 0
    },
    L: {
      name: "L",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.SHORT,
      value: 1e-3,
      offset: 0
    },
    // litre
    l: {
      name: "l",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.SHORT,
      value: 1e-3,
      offset: 0
    },
    // litre
    litre: {
      name: "litre",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.LONG,
      value: 1e-3,
      offset: 0
    },
    cuin: {
      name: "cuin",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 16387064e-12,
      offset: 0
    },
    // 1.6387064e-5 m3
    cuft: {
      name: "cuft",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.028316846592,
      offset: 0
    },
    // 28.316 846 592 L
    cuyd: {
      name: "cuyd",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.764554857984,
      offset: 0
    },
    // 764.554 857 984 L
    teaspoon: {
      name: "teaspoon",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 5e-6,
      offset: 0
    },
    // 5 mL
    tablespoon: {
      name: "tablespoon",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 15e-6,
      offset: 0
    },
    // 15 mL
    // {name: 'cup', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.000240, offset: 0}, // 240 mL  // not possible, we have already another cup
    drop: {
      name: "drop",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 5e-8,
      offset: 0
    },
    // 0.05 mL = 5e-8 m3
    gtt: {
      name: "gtt",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 5e-8,
      offset: 0
    },
    // 0.05 mL = 5e-8 m3
    // Liquid volume
    minim: {
      name: "minim",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 61611519921875e-21,
      offset: 0
    },
    // 1/61440 gallons
    fluiddram: {
      name: "fluiddram",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 36966911953125e-19,
      offset: 0
    },
    // 1/1024 gallons
    fluidounce: {
      name: "fluidounce",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 295735295625e-16,
      offset: 0
    },
    // 1/128 gallons
    gill: {
      name: "gill",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 11829411825e-14,
      offset: 0
    },
    // 1/32 gallons
    cc: {
      name: "cc",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 1e-6,
      offset: 0
    },
    // 1e-6 L
    cup: {
      name: "cup",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 2365882365e-13,
      offset: 0
    },
    // 1/16 gallons
    pint: {
      name: "pint",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 473176473e-12,
      offset: 0
    },
    // 1/8 gallons
    quart: {
      name: "quart",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 946352946e-12,
      offset: 0
    },
    // 1/4 gallons
    gallon: {
      name: "gallon",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.003785411784,
      offset: 0
    },
    // 3.785411784 L
    beerbarrel: {
      name: "beerbarrel",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.117347765304,
      offset: 0
    },
    // 31 gallons
    oilbarrel: {
      name: "oilbarrel",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.158987294928,
      offset: 0
    },
    // 42 gallons
    hogshead: {
      name: "hogshead",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.238480942392,
      offset: 0
    },
    // 63 gallons
    // Mass
    g: {
      name: "g",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.SHORT,
      value: 1e-3,
      offset: 0
    },
    gram: {
      name: "gram",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.LONG,
      value: 1e-3,
      offset: 0
    },
    ton: {
      name: "ton",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.SHORT,
      value: 907.18474,
      offset: 0
    },
    t: {
      name: "t",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.SHORT,
      value: 1e3,
      offset: 0
    },
    tonne: {
      name: "tonne",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.LONG,
      value: 1e3,
      offset: 0
    },
    grain: {
      name: "grain",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 6479891e-11,
      offset: 0
    },
    dram: {
      name: "dram",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.0017718451953125,
      offset: 0
    },
    ounce: {
      name: "ounce",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.028349523125,
      offset: 0
    },
    poundmass: {
      name: "poundmass",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.45359237,
      offset: 0
    },
    hundredweight: {
      name: "hundredweight",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 45.359237,
      offset: 0
    },
    stick: {
      name: "stick",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.115,
      offset: 0
    },
    stone: {
      name: "stone",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 6.35029318,
      offset: 0
    },
    gr: {
      name: "gr",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 6479891e-11,
      offset: 0
    },
    dr: {
      name: "dr",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.0017718451953125,
      offset: 0
    },
    oz: {
      name: "oz",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.028349523125,
      offset: 0
    },
    lbm: {
      name: "lbm",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.45359237,
      offset: 0
    },
    cwt: {
      name: "cwt",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 45.359237,
      offset: 0
    },
    // Time
    s: {
      name: "s",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    min: {
      name: "min",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 60,
      offset: 0
    },
    h: {
      name: "h",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 3600,
      offset: 0
    },
    second: {
      name: "second",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    sec: {
      name: "sec",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    minute: {
      name: "minute",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 60,
      offset: 0
    },
    hour: {
      name: "hour",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 3600,
      offset: 0
    },
    day: {
      name: "day",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 86400,
      offset: 0
    },
    week: {
      name: "week",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 7 * 86400,
      offset: 0
    },
    month: {
      name: "month",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 2629800,
      // 1/12th of Julian year
      offset: 0
    },
    year: {
      name: "year",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 31557600,
      // Julian year
      offset: 0
    },
    decade: {
      name: "decade",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 315576e3,
      // Julian decade
      offset: 0
    },
    century: {
      name: "century",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 315576e4,
      // Julian century
      offset: 0
    },
    millennium: {
      name: "millennium",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 315576e5,
      // Julian millennium
      offset: 0
    },
    // Frequency
    hertz: {
      name: "Hertz",
      base: BASE_UNITS.FREQUENCY,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0,
      reciprocal: true
    },
    Hz: {
      name: "Hz",
      base: BASE_UNITS.FREQUENCY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0,
      reciprocal: true
    },
    // Angle
    rad: {
      name: "rad",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    radian: {
      name: "radian",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    // deg = rad / (2*pi) * 360 = rad / 0.017453292519943295769236907684888
    deg: {
      name: "deg",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.SHORT,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    degree: {
      name: "degree",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.LONG,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // grad = rad / (2*pi) * 400  = rad / 0.015707963267948966192313216916399
    grad: {
      name: "grad",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.SHORT,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    gradian: {
      name: "gradian",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.LONG,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // cycle = rad / (2*pi) = rad / 6.2831853071795864769252867665793
    cycle: {
      name: "cycle",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.NONE,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // arcsec = rad / (3600 * (360 / 2 * pi)) = rad / 0.0000048481368110953599358991410235795
    arcsec: {
      name: "arcsec",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.NONE,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // arcmin = rad / (60 * (360 / 2 * pi)) = rad / 0.00029088820866572159615394846141477
    arcmin: {
      name: "arcmin",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.NONE,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // Electric current
    A: {
      name: "A",
      base: BASE_UNITS.CURRENT,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    ampere: {
      name: "ampere",
      base: BASE_UNITS.CURRENT,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    // Temperature
    // K(C) = C + 273.15
    // K(F) = (F + 459.67) * (5 / 9)
    // K(R) = R * (5 / 9)
    K: {
      name: "K",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    degC: {
      name: "degC",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 273.15
    },
    degF: {
      name: "degF",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.SHORT,
      value: new _Fraction(5, 9),
      offset: 459.67
    },
    degR: {
      name: "degR",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.SHORT,
      value: new _Fraction(5, 9),
      offset: 0
    },
    kelvin: {
      name: "kelvin",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    celsius: {
      name: "celsius",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 273.15
    },
    fahrenheit: {
      name: "fahrenheit",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.LONG,
      value: new _Fraction(5, 9),
      offset: 459.67
    },
    rankine: {
      name: "rankine",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.LONG,
      value: new _Fraction(5, 9),
      offset: 0
    },
    // amount of substance
    mol: {
      name: "mol",
      base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    mole: {
      name: "mole",
      base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    // luminous intensity
    cd: {
      name: "cd",
      base: BASE_UNITS.LUMINOUS_INTENSITY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    candela: {
      name: "candela",
      base: BASE_UNITS.LUMINOUS_INTENSITY,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    // TODO: units STERADIAN
    // {name: 'sr', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},
    // {name: 'steradian', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},
    // Force
    N: {
      name: "N",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    newton: {
      name: "newton",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    dyn: {
      name: "dyn",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.SHORT,
      value: 1e-5,
      offset: 0
    },
    dyne: {
      name: "dyne",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.LONG,
      value: 1e-5,
      offset: 0
    },
    lbf: {
      name: "lbf",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.NONE,
      value: 4.4482216152605,
      offset: 0
    },
    poundforce: {
      name: "poundforce",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.NONE,
      value: 4.4482216152605,
      offset: 0
    },
    kip: {
      name: "kip",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.LONG,
      value: 4448.2216,
      offset: 0
    },
    kilogramforce: {
      name: "kilogramforce",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.NONE,
      value: 9.80665,
      offset: 0
    },
    // Energy
    J: {
      name: "J",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    joule: {
      name: "joule",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    erg: {
      name: "erg",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORTLONG,
      // Both kiloerg and kerg are acceptable
      value: 1e-7,
      offset: 0
    },
    Wh: {
      name: "Wh",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 3600,
      offset: 0
    },
    BTU: {
      name: "BTU",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.BTU,
      value: 1055.05585262,
      offset: 0
    },
    eV: {
      name: "eV",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 1602176565e-28,
      offset: 0
    },
    electronvolt: {
      name: "electronvolt",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.LONG,
      value: 1602176565e-28,
      offset: 0
    },
    // Power
    W: {
      name: "W",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    watt: {
      name: "watt",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    hp: {
      name: "hp",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.NONE,
      value: 745.6998715386,
      offset: 0
    },
    // Electrical power units
    VAR: {
      name: "VAR",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.SHORT,
      value: Complex3.I,
      offset: 0
    },
    VA: {
      name: "VA",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Pressure
    Pa: {
      name: "Pa",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    psi: {
      name: "psi",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 6894.75729276459,
      offset: 0
    },
    atm: {
      name: "atm",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 101325,
      offset: 0
    },
    bar: {
      name: "bar",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.SHORTLONG,
      value: 1e5,
      offset: 0
    },
    torr: {
      name: "torr",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 133.322,
      offset: 0
    },
    mmHg: {
      name: "mmHg",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 133.322,
      offset: 0
    },
    mmH2O: {
      name: "mmH2O",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 9.80665,
      offset: 0
    },
    cmH2O: {
      name: "cmH2O",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 98.0665,
      offset: 0
    },
    // Electric charge
    coulomb: {
      name: "coulomb",
      base: BASE_UNITS.ELECTRIC_CHARGE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    C: {
      name: "C",
      base: BASE_UNITS.ELECTRIC_CHARGE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Electric capacitance
    farad: {
      name: "farad",
      base: BASE_UNITS.ELECTRIC_CAPACITANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    F: {
      name: "F",
      base: BASE_UNITS.ELECTRIC_CAPACITANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Electric potential
    volt: {
      name: "volt",
      base: BASE_UNITS.ELECTRIC_POTENTIAL,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    V: {
      name: "V",
      base: BASE_UNITS.ELECTRIC_POTENTIAL,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Electric resistance
    ohm: {
      name: "ohm",
      base: BASE_UNITS.ELECTRIC_RESISTANCE,
      prefixes: PREFIXES.SHORTLONG,
      // Both Mohm and megaohm are acceptable
      value: 1,
      offset: 0
    },
    /*
     * Unicode breaks in browsers if charset is not specified
    : {
      name: '',
      base: BASE_UNITS.ELECTRIC_RESISTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    */
    // Electric inductance
    henry: {
      name: "henry",
      base: BASE_UNITS.ELECTRIC_INDUCTANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    H: {
      name: "H",
      base: BASE_UNITS.ELECTRIC_INDUCTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Electric conductance
    siemens: {
      name: "siemens",
      base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    S: {
      name: "S",
      base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Magnetic flux
    weber: {
      name: "weber",
      base: BASE_UNITS.MAGNETIC_FLUX,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    Wb: {
      name: "Wb",
      base: BASE_UNITS.MAGNETIC_FLUX,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Magnetic flux density
    tesla: {
      name: "tesla",
      base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    T: {
      name: "T",
      base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Binary
    b: {
      name: "b",
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_SHORT,
      value: 1,
      offset: 0
    },
    bits: {
      name: "bits",
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_LONG,
      value: 1,
      offset: 0
    },
    B: {
      name: "B",
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_SHORT,
      value: 8,
      offset: 0
    },
    bytes: {
      name: "bytes",
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_LONG,
      value: 8,
      offset: 0
    }
  };
  var ALIASES = {
    meters: "meter",
    inches: "inch",
    feet: "foot",
    yards: "yard",
    miles: "mile",
    links: "link",
    rods: "rod",
    chains: "chain",
    angstroms: "angstrom",
    lt: "l",
    litres: "litre",
    liter: "litre",
    liters: "litre",
    teaspoons: "teaspoon",
    tablespoons: "tablespoon",
    minims: "minim",
    fldr: "fluiddram",
    fluiddrams: "fluiddram",
    floz: "fluidounce",
    fluidounces: "fluidounce",
    gi: "gill",
    gills: "gill",
    cp: "cup",
    cups: "cup",
    pt: "pint",
    pints: "pint",
    qt: "quart",
    quarts: "quart",
    gal: "gallon",
    gallons: "gallon",
    bbl: "beerbarrel",
    beerbarrels: "beerbarrel",
    obl: "oilbarrel",
    oilbarrels: "oilbarrel",
    hogsheads: "hogshead",
    gtts: "gtt",
    grams: "gram",
    tons: "ton",
    tonnes: "tonne",
    grains: "grain",
    drams: "dram",
    ounces: "ounce",
    poundmasses: "poundmass",
    hundredweights: "hundredweight",
    sticks: "stick",
    lb: "lbm",
    lbs: "lbm",
    kips: "kip",
    kgf: "kilogramforce",
    acres: "acre",
    hectares: "hectare",
    sqfeet: "sqft",
    sqyard: "sqyd",
    sqmile: "sqmi",
    sqmiles: "sqmi",
    mmhg: "mmHg",
    mmh2o: "mmH2O",
    cmh2o: "cmH2O",
    seconds: "second",
    secs: "second",
    minutes: "minute",
    mins: "minute",
    hours: "hour",
    hr: "hour",
    hrs: "hour",
    days: "day",
    weeks: "week",
    months: "month",
    years: "year",
    decades: "decade",
    centuries: "century",
    millennia: "millennium",
    hertz: "hertz",
    radians: "radian",
    degrees: "degree",
    gradians: "gradian",
    cycles: "cycle",
    arcsecond: "arcsec",
    arcseconds: "arcsec",
    arcminute: "arcmin",
    arcminutes: "arcmin",
    BTUs: "BTU",
    watts: "watt",
    joules: "joule",
    amperes: "ampere",
    amps: "ampere",
    amp: "ampere",
    coulombs: "coulomb",
    volts: "volt",
    ohms: "ohm",
    farads: "farad",
    webers: "weber",
    teslas: "tesla",
    electronvolts: "electronvolt",
    moles: "mole",
    bit: "bits",
    byte: "bytes"
  };
  function calculateAngleValues(config3) {
    if (config3.number === "BigNumber") {
      var pi2 = createBigNumberPi(_BigNumber);
      UNITS.rad.value = new _BigNumber(1);
      UNITS.deg.value = pi2.div(180);
      UNITS.grad.value = pi2.div(200);
      UNITS.cycle.value = pi2.times(2);
      UNITS.arcsec.value = pi2.div(648e3);
      UNITS.arcmin.value = pi2.div(10800);
    } else {
      UNITS.rad.value = 1;
      UNITS.deg.value = Math.PI / 180;
      UNITS.grad.value = Math.PI / 200;
      UNITS.cycle.value = Math.PI * 2;
      UNITS.arcsec.value = Math.PI / 648e3;
      UNITS.arcmin.value = Math.PI / 10800;
    }
    UNITS.radian.value = UNITS.rad.value;
    UNITS.degree.value = UNITS.deg.value;
    UNITS.gradian.value = UNITS.grad.value;
  }
  calculateAngleValues(config2);
  if (on) {
    on("config", function(curr, prev) {
      if (curr.number !== prev.number) {
        calculateAngleValues(curr);
      }
    });
  }
  var UNIT_SYSTEMS = {
    si: {
      // Base units
      NONE: {
        unit: UNIT_NONE,
        prefix: PREFIXES.NONE[""]
      },
      LENGTH: {
        unit: UNITS.m,
        prefix: PREFIXES.SHORT[""]
      },
      MASS: {
        unit: UNITS.g,
        prefix: PREFIXES.SHORT.k
      },
      TIME: {
        unit: UNITS.s,
        prefix: PREFIXES.SHORT[""]
      },
      CURRENT: {
        unit: UNITS.A,
        prefix: PREFIXES.SHORT[""]
      },
      TEMPERATURE: {
        unit: UNITS.K,
        prefix: PREFIXES.SHORT[""]
      },
      LUMINOUS_INTENSITY: {
        unit: UNITS.cd,
        prefix: PREFIXES.SHORT[""]
      },
      AMOUNT_OF_SUBSTANCE: {
        unit: UNITS.mol,
        prefix: PREFIXES.SHORT[""]
      },
      ANGLE: {
        unit: UNITS.rad,
        prefix: PREFIXES.SHORT[""]
      },
      BIT: {
        unit: UNITS.bits,
        prefix: PREFIXES.SHORT[""]
      },
      // Derived units
      FORCE: {
        unit: UNITS.N,
        prefix: PREFIXES.SHORT[""]
      },
      ENERGY: {
        unit: UNITS.J,
        prefix: PREFIXES.SHORT[""]
      },
      POWER: {
        unit: UNITS.W,
        prefix: PREFIXES.SHORT[""]
      },
      PRESSURE: {
        unit: UNITS.Pa,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_CHARGE: {
        unit: UNITS.C,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_CAPACITANCE: {
        unit: UNITS.F,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_POTENTIAL: {
        unit: UNITS.V,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_RESISTANCE: {
        unit: UNITS.ohm,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_INDUCTANCE: {
        unit: UNITS.H,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_CONDUCTANCE: {
        unit: UNITS.S,
        prefix: PREFIXES.SHORT[""]
      },
      MAGNETIC_FLUX: {
        unit: UNITS.Wb,
        prefix: PREFIXES.SHORT[""]
      },
      MAGNETIC_FLUX_DENSITY: {
        unit: UNITS.T,
        prefix: PREFIXES.SHORT[""]
      },
      FREQUENCY: {
        unit: UNITS.Hz,
        prefix: PREFIXES.SHORT[""]
      }
    }
  };
  UNIT_SYSTEMS.cgs = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
  UNIT_SYSTEMS.cgs.LENGTH = {
    unit: UNITS.m,
    prefix: PREFIXES.SHORT.c
  };
  UNIT_SYSTEMS.cgs.MASS = {
    unit: UNITS.g,
    prefix: PREFIXES.SHORT[""]
  };
  UNIT_SYSTEMS.cgs.FORCE = {
    unit: UNITS.dyn,
    prefix: PREFIXES.SHORT[""]
  };
  UNIT_SYSTEMS.cgs.ENERGY = {
    unit: UNITS.erg,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
  UNIT_SYSTEMS.us.LENGTH = {
    unit: UNITS.ft,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.MASS = {
    unit: UNITS.lbm,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.TEMPERATURE = {
    unit: UNITS.degF,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.FORCE = {
    unit: UNITS.lbf,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.ENERGY = {
    unit: UNITS.BTU,
    prefix: PREFIXES.BTU[""]
  };
  UNIT_SYSTEMS.us.POWER = {
    unit: UNITS.hp,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.PRESSURE = {
    unit: UNITS.psi,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.auto = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
  var currentUnitSystem = UNIT_SYSTEMS.auto;
  Unit2.setUnitSystem = function(name197) {
    if (hasOwnProperty(UNIT_SYSTEMS, name197)) {
      currentUnitSystem = UNIT_SYSTEMS[name197];
    } else {
      throw new Error("Unit system " + name197 + " does not exist. Choices are: " + Object.keys(UNIT_SYSTEMS).join(", "));
    }
  };
  Unit2.getUnitSystem = function() {
    for (var _key in UNIT_SYSTEMS) {
      if (hasOwnProperty(UNIT_SYSTEMS, _key)) {
        if (UNIT_SYSTEMS[_key] === currentUnitSystem) {
          return _key;
        }
      }
    }
  };
  Unit2.typeConverters = {
    BigNumber: function BigNumber2(x) {
      if (x !== null && x !== void 0 && x.isFraction) return new _BigNumber(String(x.n)).div(String(x.d)).times(String(x.s));
      return new _BigNumber(x + "");
    },
    Fraction: function Fraction3(x) {
      return new _Fraction(x);
    },
    Complex: function Complex4(x) {
      return x;
    },
    number: function number2(x) {
      if (x !== null && x !== void 0 && x.isFraction) return _number(x);
      return x;
    }
  };
  Unit2.prototype._numberConverter = function() {
    var convert = Unit2.typeConverters[this.valueType()];
    if (convert) {
      return convert;
    }
    throw new TypeError('Unsupported Unit value type "' + this.valueType() + '"');
  };
  Unit2._getNumberConverter = function(type) {
    if (!Unit2.typeConverters[type]) {
      throw new TypeError('Unsupported type "' + type + '"');
    }
    return Unit2.typeConverters[type];
  };
  for (var _key2 in UNITS) {
    if (hasOwnProperty(UNITS, _key2)) {
      var unit2 = UNITS[_key2];
      unit2.dimensions = unit2.base.dimensions;
    }
  }
  for (var _name2 in ALIASES) {
    if (hasOwnProperty(ALIASES, _name2)) {
      var _unit2 = UNITS[ALIASES[_name2]];
      var alias = {};
      for (var _key3 in _unit2) {
        if (hasOwnProperty(_unit2, _key3)) {
          alias[_key3] = _unit2[_key3];
        }
      }
      alias.name = _name2;
      UNITS[_name2] = alias;
    }
  }
  Unit2.isValidAlpha = function isValidAlpha(c2) {
    return /^[a-zA-Z]$/.test(c2);
  };
  function assertUnitNameIsValid(name197) {
    for (var i2 = 0; i2 < name197.length; i2++) {
      c = name197.charAt(i2);
      if (i2 === 0 && !Unit2.isValidAlpha(c)) {
        throw new Error('Invalid unit name (must begin with alpha character): "' + name197 + '"');
      }
      if (i2 > 0 && !(Unit2.isValidAlpha(c) || isDigit(c))) {
        throw new Error('Invalid unit name (only alphanumeric characters are allowed): "' + name197 + '"');
      }
    }
  }
  Unit2.createUnit = function(obj, options) {
    if (typeof obj !== "object") {
      throw new TypeError("createUnit expects first parameter to be of type 'Object'");
    }
    if (options && options.override) {
      for (var _key4 in obj) {
        if (hasOwnProperty(obj, _key4)) {
          Unit2.deleteUnit(_key4);
        }
        if (obj[_key4].aliases) {
          for (var i2 = 0; i2 < obj[_key4].aliases.length; i2++) {
            Unit2.deleteUnit(obj[_key4].aliases[i2]);
          }
        }
      }
    }
    var lastUnit;
    for (var _key5 in obj) {
      if (hasOwnProperty(obj, _key5)) {
        lastUnit = Unit2.createUnitSingle(_key5, obj[_key5]);
      }
    }
    return lastUnit;
  };
  Unit2.createUnitSingle = function(name197, obj) {
    if (typeof obj === "undefined" || obj === null) {
      obj = {};
    }
    if (typeof name197 !== "string") {
      throw new TypeError("createUnitSingle expects first parameter to be of type 'string'");
    }
    if (hasOwnProperty(UNITS, name197)) {
      throw new Error('Cannot create unit "' + name197 + '": a unit with that name already exists');
    }
    assertUnitNameIsValid(name197);
    var defUnit = null;
    var aliases = [];
    var offset = 0;
    var definition;
    var prefixes;
    var baseName;
    if (obj && obj.type === "Unit") {
      defUnit = obj.clone();
    } else if (typeof obj === "string") {
      if (obj !== "") {
        definition = obj;
      }
    } else if (typeof obj === "object") {
      definition = obj.definition;
      prefixes = obj.prefixes;
      offset = obj.offset;
      baseName = obj.baseName;
      if (obj.aliases) {
        aliases = obj.aliases.valueOf();
      }
    } else {
      throw new TypeError('Cannot create unit "' + name197 + '" from "' + obj.toString() + '": expecting "string" or "Unit" or "Object"');
    }
    if (aliases) {
      for (var i2 = 0; i2 < aliases.length; i2++) {
        if (hasOwnProperty(UNITS, aliases[i2])) {
          throw new Error('Cannot create alias "' + aliases[i2] + '": a unit with that name already exists');
        }
      }
    }
    if (definition && typeof definition === "string" && !defUnit) {
      try {
        defUnit = Unit2.parse(definition, {
          allowNoUnits: true
        });
      } catch (ex) {
        ex.message = 'Could not create unit "' + name197 + '" from "' + definition + '": ' + ex.message;
        throw ex;
      }
    } else if (definition && definition.type === "Unit") {
      defUnit = definition.clone();
    }
    aliases = aliases || [];
    offset = offset || 0;
    if (prefixes && prefixes.toUpperCase) {
      prefixes = PREFIXES[prefixes.toUpperCase()] || PREFIXES.NONE;
    } else {
      prefixes = PREFIXES.NONE;
    }
    var newUnit = {};
    if (!defUnit) {
      baseName = baseName || name197 + "_STUFF";
      if (BASE_DIMENSIONS.indexOf(baseName) >= 0) {
        throw new Error('Cannot create new base unit "' + name197 + '": a base unit with that name already exists (and cannot be overridden)');
      }
      BASE_DIMENSIONS.push(baseName);
      for (var b in BASE_UNITS) {
        if (hasOwnProperty(BASE_UNITS, b)) {
          BASE_UNITS[b].dimensions[BASE_DIMENSIONS.length - 1] = 0;
        }
      }
      var newBaseUnit = {
        dimensions: []
      };
      for (var _i6 = 0; _i6 < BASE_DIMENSIONS.length; _i6++) {
        newBaseUnit.dimensions[_i6] = 0;
      }
      newBaseUnit.dimensions[BASE_DIMENSIONS.length - 1] = 1;
      newBaseUnit.key = baseName;
      BASE_UNITS[baseName] = newBaseUnit;
      newUnit = {
        name: name197,
        value: 1,
        dimensions: BASE_UNITS[baseName].dimensions.slice(0),
        prefixes,
        offset,
        base: BASE_UNITS[baseName]
      };
      currentUnitSystem[baseName] = {
        unit: newUnit,
        prefix: PREFIXES.NONE[""]
      };
    } else {
      newUnit = {
        name: name197,
        value: defUnit.value,
        dimensions: defUnit.dimensions.slice(0),
        prefixes,
        offset
      };
      var anyMatch = false;
      for (var _i7 in BASE_UNITS) {
        if (hasOwnProperty(BASE_UNITS, _i7)) {
          var match = true;
          for (var j = 0; j < BASE_DIMENSIONS.length; j++) {
            if (Math.abs((newUnit.dimensions[j] || 0) - (BASE_UNITS[_i7].dimensions[j] || 0)) > 1e-12) {
              match = false;
              break;
            }
          }
          if (match) {
            anyMatch = true;
            newUnit.base = BASE_UNITS[_i7];
            break;
          }
        }
      }
      if (!anyMatch) {
        baseName = baseName || name197 + "_STUFF";
        var _newBaseUnit = {
          dimensions: defUnit.dimensions.slice(0)
        };
        _newBaseUnit.key = baseName;
        BASE_UNITS[baseName] = _newBaseUnit;
        currentUnitSystem[baseName] = {
          unit: newUnit,
          prefix: PREFIXES.NONE[""]
        };
        newUnit.base = BASE_UNITS[baseName];
      }
    }
    Unit2.UNITS[name197] = newUnit;
    for (var _i8 = 0; _i8 < aliases.length; _i8++) {
      var aliasName = aliases[_i8];
      var _alias = {};
      for (var _key6 in newUnit) {
        if (hasOwnProperty(newUnit, _key6)) {
          _alias[_key6] = newUnit[_key6];
        }
      }
      _alias.name = aliasName;
      Unit2.UNITS[aliasName] = _alias;
    }
    delete _findUnit.cache;
    return new Unit2(null, name197);
  };
  Unit2.deleteUnit = function(name197) {
    delete Unit2.UNITS[name197];
    delete _findUnit.cache;
  };
  Unit2.PREFIXES = PREFIXES;
  Unit2.BASE_DIMENSIONS = BASE_DIMENSIONS;
  Unit2.BASE_UNITS = BASE_UNITS;
  Unit2.UNIT_SYSTEMS = UNIT_SYSTEMS;
  Unit2.UNITS = UNITS;
  return Unit2;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/unit/function/unit.js
var name112 = "unit";
var dependencies112 = ["typed", "Unit"];
var createUnitFunction = factory(name112, dependencies112, (_ref) => {
  var {
    typed: typed2,
    Unit: Unit2
  } = _ref;
  return typed2(name112, {
    Unit: function Unit3(x) {
      return x.clone();
    },
    string: function string2(x) {
      if (Unit2.isValuelessUnit(x)) {
        return new Unit2(null, x);
      }
      return Unit2.parse(x, {
        allowNoUnits: true
      });
    },
    "number | BigNumber | Fraction | Complex, string | Unit": function number__BigNumber__Fraction__Complex_string__Unit(value, unit2) {
      return new Unit2(value, unit2);
    },
    "number | BigNumber | Fraction": function number__BigNumber__Fraction(value) {
      return new Unit2(value);
    },
    "Array | Matrix": typed2.referToSelf((self) => (x) => deepMap(x, self))
  });
});

// node_modules/mathjs/lib/esm/type/matrix/function/sparse.js
var name113 = "sparse";
var dependencies113 = ["typed", "SparseMatrix"];
var createSparse = factory(name113, dependencies113, (_ref) => {
  var {
    typed: typed2,
    SparseMatrix: SparseMatrix2
  } = _ref;
  return typed2(name113, {
    "": function _() {
      return new SparseMatrix2([]);
    },
    string: function string2(datatype) {
      return new SparseMatrix2([], datatype);
    },
    "Array | Matrix": function Array__Matrix(data) {
      return new SparseMatrix2(data);
    },
    "Array | Matrix, string": function Array__Matrix_string(data, datatype) {
      return new SparseMatrix2(data, datatype);
    }
  });
});

// node_modules/mathjs/lib/esm/type/unit/function/createUnit.js
var name114 = "createUnit";
var dependencies114 = ["typed", "Unit"];
var createCreateUnit = factory(name114, dependencies114, (_ref) => {
  var {
    typed: typed2,
    Unit: Unit2
  } = _ref;
  return typed2(name114, {
    // General function signature. First parameter is an object where each property is the definition of a new unit. The object keys are the unit names and the values are the definitions. The values can be objects, strings, or Units. If a property is an empty object or an empty string, a new base unit is created. The second parameter is the options.
    "Object, Object": function Object_Object(obj, options) {
      return Unit2.createUnit(obj, options);
    },
    // Same as above but without the options.
    Object: function Object2(obj) {
      return Unit2.createUnit(obj, {});
    },
    // Shortcut method for creating one unit.
    "string, Unit | string | Object, Object": function string_Unit__string__Object_Object(name197, def, options) {
      var obj = {};
      obj[name197] = def;
      return Unit2.createUnit(obj, options);
    },
    // Same as above but without the options.
    "string, Unit | string | Object": function string_Unit__string__Object(name197, def) {
      var obj = {};
      obj[name197] = def;
      return Unit2.createUnit(obj, {});
    },
    // Without a definition, creates a base unit.
    string: function string2(name197) {
      var obj = {};
      obj[name197] = {};
      return Unit2.createUnit(obj, {});
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/acos.js
var name115 = "acos";
var dependencies115 = ["typed", "config", "Complex"];
var createAcos = factory(name115, dependencies115, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    Complex: Complex3
  } = _ref;
  return typed2(name115, {
    number: function number2(x) {
      if (x >= -1 && x <= 1 || config2.predictable) {
        return Math.acos(x);
      } else {
        return new Complex3(x, 0).acos();
      }
    },
    Complex: function Complex4(x) {
      return x.acos();
    },
    BigNumber: function BigNumber2(x) {
      return x.acos();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/acosh.js
var name116 = "acosh";
var dependencies116 = ["typed", "config", "Complex"];
var createAcosh = factory(name116, dependencies116, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    Complex: Complex3
  } = _ref;
  return typed2(name116, {
    number: function number2(x) {
      if (x >= 1 || config2.predictable) {
        return acoshNumber(x);
      }
      if (x <= -1) {
        return new Complex3(Math.log(Math.sqrt(x * x - 1) - x), Math.PI);
      }
      return new Complex3(x, 0).acosh();
    },
    Complex: function Complex4(x) {
      return x.acosh();
    },
    BigNumber: function BigNumber2(x) {
      return x.acosh();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/acot.js
var name117 = "acot";
var dependencies117 = ["typed", "BigNumber"];
var createAcot = factory(name117, dependencies117, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name117, {
    number: acotNumber,
    Complex: function Complex3(x) {
      return x.acot();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(1).div(x).atan();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/acoth.js
var name118 = "acoth";
var dependencies118 = ["typed", "config", "Complex", "BigNumber"];
var createAcoth = factory(name118, dependencies118, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    Complex: Complex3,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name118, {
    number: function number2(x) {
      if (x >= 1 || x <= -1 || config2.predictable) {
        return acothNumber(x);
      }
      return new Complex3(x, 0).acoth();
    },
    Complex: function Complex4(x) {
      return x.acoth();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(1).div(x).atanh();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/acsc.js
var name119 = "acsc";
var dependencies119 = ["typed", "config", "Complex", "BigNumber"];
var createAcsc = factory(name119, dependencies119, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    Complex: Complex3,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name119, {
    number: function number2(x) {
      if (x <= -1 || x >= 1 || config2.predictable) {
        return acscNumber(x);
      }
      return new Complex3(x, 0).acsc();
    },
    Complex: function Complex4(x) {
      return x.acsc();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(1).div(x).asin();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/acsch.js
var name120 = "acsch";
var dependencies120 = ["typed", "BigNumber"];
var createAcsch = factory(name120, dependencies120, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name120, {
    number: acschNumber,
    Complex: function Complex3(x) {
      return x.acsch();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(1).div(x).asinh();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/asec.js
var name121 = "asec";
var dependencies121 = ["typed", "config", "Complex", "BigNumber"];
var createAsec = factory(name121, dependencies121, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    Complex: Complex3,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name121, {
    number: function number2(x) {
      if (x <= -1 || x >= 1 || config2.predictable) {
        return asecNumber(x);
      }
      return new Complex3(x, 0).asec();
    },
    Complex: function Complex4(x) {
      return x.asec();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(1).div(x).acos();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/asech.js
var name122 = "asech";
var dependencies122 = ["typed", "config", "Complex", "BigNumber"];
var createAsech = factory(name122, dependencies122, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    Complex: Complex3,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name122, {
    number: function number2(x) {
      if (x <= 1 && x >= -1 || config2.predictable) {
        var xInv = 1 / x;
        if (xInv > 0 || config2.predictable) {
          return asechNumber(x);
        }
        var ret = Math.sqrt(xInv * xInv - 1);
        return new Complex3(Math.log(ret - xInv), Math.PI);
      }
      return new Complex3(x, 0).asech();
    },
    Complex: function Complex4(x) {
      return x.asech();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(1).div(x).acosh();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/asin.js
var name123 = "asin";
var dependencies123 = ["typed", "config", "Complex"];
var createAsin = factory(name123, dependencies123, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    Complex: Complex3
  } = _ref;
  return typed2(name123, {
    number: function number2(x) {
      if (x >= -1 && x <= 1 || config2.predictable) {
        return Math.asin(x);
      } else {
        return new Complex3(x, 0).asin();
      }
    },
    Complex: function Complex4(x) {
      return x.asin();
    },
    BigNumber: function BigNumber2(x) {
      return x.asin();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/asinh.js
var name124 = "asinh";
var dependencies124 = ["typed"];
var createAsinh = factory(name124, dependencies124, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2("asinh", {
    number: asinhNumber,
    Complex: function Complex3(x) {
      return x.asinh();
    },
    BigNumber: function BigNumber2(x) {
      return x.asinh();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/atan.js
var name125 = "atan";
var dependencies125 = ["typed"];
var createAtan = factory(name125, dependencies125, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2("atan", {
    number: function number2(x) {
      return Math.atan(x);
    },
    Complex: function Complex3(x) {
      return x.atan();
    },
    BigNumber: function BigNumber2(x) {
      return x.atan();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/atan2.js
var name126 = "atan2";
var dependencies126 = ["typed", "matrix", "equalScalar", "BigNumber", "DenseMatrix", "concat"];
var createAtan2 = factory(name126, dependencies126, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    BigNumber: BigNumber2,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo09xS0Sf = createMatAlgo09xS0Sf({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat3
  });
  return typed2(name126, {
    "number, number": Math.atan2,
    // Complex numbers doesn't seem to have a reasonable implementation of
    // atan2(). Even Matlab removed the support, after they only calculated
    // the atan only on base of the real part of the numbers and ignored
    // the imaginary.
    "BigNumber, BigNumber": (y, x) => BigNumber2.atan2(y, x)
  }, matrixAlgorithmSuite({
    scalar: "number | BigNumber",
    SS: matAlgo09xS0Sf,
    DS: matAlgo03xDSf,
    SD: matAlgo02xDS0,
    Ss: matAlgo11xS0s,
    sS: matAlgo12xSfs
  }));
});

// node_modules/mathjs/lib/esm/function/trigonometry/atanh.js
var name127 = "atanh";
var dependencies127 = ["typed", "config", "Complex"];
var createAtanh = factory(name127, dependencies127, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    Complex: Complex3
  } = _ref;
  return typed2(name127, {
    number: function number2(x) {
      if (x <= 1 && x >= -1 || config2.predictable) {
        return atanhNumber(x);
      }
      return new Complex3(x, 0).atanh();
    },
    Complex: function Complex4(x) {
      return x.atanh();
    },
    BigNumber: function BigNumber2(x) {
      return x.atanh();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/trigUnit.js
var createTrigUnit = factory("trigUnit", ["typed"], (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return {
    Unit: typed2.referToSelf((self) => (x) => {
      if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
        throw new TypeError("Unit in function cot is no angle");
      }
      return typed2.find(self, x.valueType())(x.value);
    })
  };
});

// node_modules/mathjs/lib/esm/function/trigonometry/cos.js
var name128 = "cos";
var dependencies128 = ["typed"];
var createCos = factory(name128, dependencies128, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed2
  });
  return typed2(name128, {
    number: Math.cos,
    "Complex | BigNumber": (x) => x.cos()
  }, trigUnit);
});

// node_modules/mathjs/lib/esm/function/trigonometry/cosh.js
var name129 = "cosh";
var dependencies129 = ["typed"];
var createCosh = factory(name129, dependencies129, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name129, {
    number: cosh,
    "Complex | BigNumber": (x) => x.cosh()
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/cot.js
var name130 = "cot";
var dependencies130 = ["typed", "BigNumber"];
var createCot = factory(name130, dependencies130, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed2
  });
  return typed2(name130, {
    number: cotNumber,
    Complex: (x) => x.cot(),
    BigNumber: (x) => new _BigNumber(1).div(x.tan())
  }, trigUnit);
});

// node_modules/mathjs/lib/esm/function/trigonometry/coth.js
var name131 = "coth";
var dependencies131 = ["typed", "BigNumber"];
var createCoth = factory(name131, dependencies131, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name131, {
    number: cothNumber,
    Complex: (x) => x.coth(),
    BigNumber: (x) => new _BigNumber(1).div(x.tanh())
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/csc.js
var name132 = "csc";
var dependencies132 = ["typed", "BigNumber"];
var createCsc = factory(name132, dependencies132, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed2
  });
  return typed2(name132, {
    number: cscNumber,
    Complex: (x) => x.csc(),
    BigNumber: (x) => new _BigNumber(1).div(x.sin())
  }, trigUnit);
});

// node_modules/mathjs/lib/esm/function/trigonometry/csch.js
var name133 = "csch";
var dependencies133 = ["typed", "BigNumber"];
var createCsch = factory(name133, dependencies133, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name133, {
    number: cschNumber,
    Complex: (x) => x.csch(),
    BigNumber: (x) => new _BigNumber(1).div(x.sinh())
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/sec.js
var name134 = "sec";
var dependencies134 = ["typed", "BigNumber"];
var createSec = factory(name134, dependencies134, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed2
  });
  return typed2(name134, {
    number: secNumber,
    Complex: (x) => x.sec(),
    BigNumber: (x) => new _BigNumber(1).div(x.cos())
  }, trigUnit);
});

// node_modules/mathjs/lib/esm/function/trigonometry/sech.js
var name135 = "sech";
var dependencies135 = ["typed", "BigNumber"];
var createSech = factory(name135, dependencies135, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name135, {
    number: sechNumber,
    Complex: (x) => x.sech(),
    BigNumber: (x) => new _BigNumber(1).div(x.cosh())
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/sin.js
var name136 = "sin";
var dependencies136 = ["typed"];
var createSin = factory(name136, dependencies136, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed2
  });
  return typed2(name136, {
    number: Math.sin,
    "Complex | BigNumber": (x) => x.sin()
  }, trigUnit);
});

// node_modules/mathjs/lib/esm/function/trigonometry/sinh.js
var name137 = "sinh";
var dependencies137 = ["typed"];
var createSinh = factory(name137, dependencies137, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name137, {
    number: sinhNumber,
    "Complex | BigNumber": (x) => x.sinh()
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/tan.js
var name138 = "tan";
var dependencies138 = ["typed"];
var createTan = factory(name138, dependencies138, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed2
  });
  return typed2(name138, {
    number: Math.tan,
    "Complex | BigNumber": (x) => x.tan()
  }, trigUnit);
});

// node_modules/mathjs/lib/esm/function/trigonometry/tanh.js
var name139 = "tanh";
var dependencies139 = ["typed"];
var createTanh = factory(name139, dependencies139, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2("tanh", {
    number: tanh,
    "Complex | BigNumber": (x) => x.tanh()
  });
});

// node_modules/mathjs/lib/esm/function/set/setCartesian.js
var name140 = "setCartesian";
var dependencies140 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
var createSetCartesian = factory(name140, dependencies140, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return typed2(name140, {
    "Array | Matrix, Array | Matrix": function Array__Matrix_Array__Matrix(a1, a2) {
      var result = [];
      if (subset2(size2(a1), new Index2(0)) !== 0 && subset2(size2(a2), new Index2(0)) !== 0) {
        var b1 = flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural2);
        var b2 = flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural2);
        result = [];
        for (var i2 = 0; i2 < b1.length; i2++) {
          for (var j = 0; j < b2.length; j++) {
            result.push([b1[i2], b2[j]]);
          }
        }
      }
      if (Array.isArray(a1) && Array.isArray(a2)) {
        return result;
      }
      return new DenseMatrix2(result);
    }
  });
});

// node_modules/mathjs/lib/esm/function/set/setDifference.js
var name141 = "setDifference";
var dependencies141 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
var createSetDifference = factory(name141, dependencies141, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return typed2(name141, {
    "Array | Matrix, Array | Matrix": function Array__Matrix_Array__Matrix(a1, a2) {
      var result;
      if (subset2(size2(a1), new Index2(0)) === 0) {
        result = [];
      } else if (subset2(size2(a2), new Index2(0)) === 0) {
        return flatten(a1.toArray());
      } else {
        var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural2));
        var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural2));
        result = [];
        var inb2;
        for (var i2 = 0; i2 < b1.length; i2++) {
          inb2 = false;
          for (var j = 0; j < b2.length; j++) {
            if (compareNatural2(b1[i2].value, b2[j].value) === 0 && b1[i2].identifier === b2[j].identifier) {
              inb2 = true;
              break;
            }
          }
          if (!inb2) {
            result.push(b1[i2]);
          }
        }
      }
      if (Array.isArray(a1) && Array.isArray(a2)) {
        return generalize(result);
      }
      return new DenseMatrix2(generalize(result));
    }
  });
});

// node_modules/mathjs/lib/esm/function/set/setDistinct.js
var name142 = "setDistinct";
var dependencies142 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
var createSetDistinct = factory(name142, dependencies142, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return typed2(name142, {
    "Array | Matrix": function Array__Matrix(a) {
      var result;
      if (subset2(size2(a), new Index2(0)) === 0) {
        result = [];
      } else {
        var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural2);
        result = [];
        result.push(b[0]);
        for (var i2 = 1; i2 < b.length; i2++) {
          if (compareNatural2(b[i2], b[i2 - 1]) !== 0) {
            result.push(b[i2]);
          }
        }
      }
      if (Array.isArray(a)) {
        return result;
      }
      return new DenseMatrix2(result);
    }
  });
});

// node_modules/mathjs/lib/esm/function/set/setIntersect.js
var name143 = "setIntersect";
var dependencies143 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
var createSetIntersect = factory(name143, dependencies143, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return typed2(name143, {
    "Array | Matrix, Array | Matrix": function Array__Matrix_Array__Matrix(a1, a2) {
      var result;
      if (subset2(size2(a1), new Index2(0)) === 0 || subset2(size2(a2), new Index2(0)) === 0) {
        result = [];
      } else {
        var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural2));
        var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural2));
        result = [];
        for (var i2 = 0; i2 < b1.length; i2++) {
          for (var j = 0; j < b2.length; j++) {
            if (compareNatural2(b1[i2].value, b2[j].value) === 0 && b1[i2].identifier === b2[j].identifier) {
              result.push(b1[i2]);
              break;
            }
          }
        }
      }
      if (Array.isArray(a1) && Array.isArray(a2)) {
        return generalize(result);
      }
      return new DenseMatrix2(generalize(result));
    }
  });
});

// node_modules/mathjs/lib/esm/function/set/setIsSubset.js
var name144 = "setIsSubset";
var dependencies144 = ["typed", "size", "subset", "compareNatural", "Index"];
var createSetIsSubset = factory(name144, dependencies144, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2
  } = _ref;
  return typed2(name144, {
    "Array | Matrix, Array | Matrix": function Array__Matrix_Array__Matrix(a1, a2) {
      if (subset2(size2(a1), new Index2(0)) === 0) {
        return true;
      } else if (subset2(size2(a2), new Index2(0)) === 0) {
        return false;
      }
      var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural2));
      var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural2));
      var inb2;
      for (var i2 = 0; i2 < b1.length; i2++) {
        inb2 = false;
        for (var j = 0; j < b2.length; j++) {
          if (compareNatural2(b1[i2].value, b2[j].value) === 0 && b1[i2].identifier === b2[j].identifier) {
            inb2 = true;
            break;
          }
        }
        if (inb2 === false) {
          return false;
        }
      }
      return true;
    }
  });
});

// node_modules/mathjs/lib/esm/function/set/setMultiplicity.js
var name145 = "setMultiplicity";
var dependencies145 = ["typed", "size", "subset", "compareNatural", "Index"];
var createSetMultiplicity = factory(name145, dependencies145, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2
  } = _ref;
  return typed2(name145, {
    "number | BigNumber | Fraction | Complex, Array | Matrix": function number__BigNumber__Fraction__Complex_Array__Matrix(e2, a) {
      if (subset2(size2(a), new Index2(0)) === 0) {
        return 0;
      }
      var b = flatten(Array.isArray(a) ? a : a.toArray());
      var count2 = 0;
      for (var i2 = 0; i2 < b.length; i2++) {
        if (compareNatural2(b[i2], e2) === 0) {
          count2++;
        }
      }
      return count2;
    }
  });
});

// node_modules/mathjs/lib/esm/function/set/setPowerset.js
var name146 = "setPowerset";
var dependencies146 = ["typed", "size", "subset", "compareNatural", "Index"];
var createSetPowerset = factory(name146, dependencies146, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2
  } = _ref;
  return typed2(name146, {
    "Array | Matrix": function Array__Matrix(a) {
      if (subset2(size2(a), new Index2(0)) === 0) {
        return [];
      }
      var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural2);
      var result = [];
      var number2 = 0;
      while (number2.toString(2).length <= b.length) {
        result.push(_subset(b, number2.toString(2).split("").reverse()));
        number2++;
      }
      return _sort(result);
    }
  });
  function _subset(array, bitarray) {
    var result = [];
    for (var i2 = 0; i2 < bitarray.length; i2++) {
      if (bitarray[i2] === "1") {
        result.push(array[i2]);
      }
    }
    return result;
  }
  function _sort(array) {
    var temp = [];
    for (var i2 = array.length - 1; i2 > 0; i2--) {
      for (var j = 0; j < i2; j++) {
        if (array[j].length > array[j + 1].length) {
          temp = array[j];
          array[j] = array[j + 1];
          array[j + 1] = temp;
        }
      }
    }
    return array;
  }
});

// node_modules/mathjs/lib/esm/function/set/setSize.js
var name147 = "setSize";
var dependencies147 = ["typed", "compareNatural"];
var createSetSize = factory(name147, dependencies147, (_ref) => {
  var {
    typed: typed2,
    compareNatural: compareNatural2
  } = _ref;
  return typed2(name147, {
    "Array | Matrix": function Array__Matrix(a) {
      return Array.isArray(a) ? flatten(a).length : flatten(a.toArray()).length;
    },
    "Array | Matrix, boolean": function Array__Matrix_boolean(a, unique) {
      if (unique === false || a.length === 0) {
        return Array.isArray(a) ? flatten(a).length : flatten(a.toArray()).length;
      } else {
        var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural2);
        var count2 = 1;
        for (var i2 = 1; i2 < b.length; i2++) {
          if (compareNatural2(b[i2], b[i2 - 1]) !== 0) {
            count2++;
          }
        }
        return count2;
      }
    }
  });
});

// node_modules/mathjs/lib/esm/function/set/setSymDifference.js
var name148 = "setSymDifference";
var dependencies148 = ["typed", "size", "concat", "subset", "setDifference", "Index"];
var createSetSymDifference = factory(name148, dependencies148, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    concat: concat3,
    subset: subset2,
    setDifference: setDifference2,
    Index: Index2
  } = _ref;
  return typed2(name148, {
    "Array | Matrix, Array | Matrix": function Array__Matrix_Array__Matrix(a1, a2) {
      if (subset2(size2(a1), new Index2(0)) === 0) {
        return flatten(a2);
      } else if (subset2(size2(a2), new Index2(0)) === 0) {
        return flatten(a1);
      }
      var b1 = flatten(a1);
      var b2 = flatten(a2);
      return concat3(setDifference2(b1, b2), setDifference2(b2, b1));
    }
  });
});

// node_modules/mathjs/lib/esm/function/set/setUnion.js
var name149 = "setUnion";
var dependencies149 = ["typed", "size", "concat", "subset", "setIntersect", "setSymDifference", "Index"];
var createSetUnion = factory(name149, dependencies149, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    concat: concat3,
    subset: subset2,
    setIntersect: setIntersect2,
    setSymDifference: setSymDifference2,
    Index: Index2
  } = _ref;
  return typed2(name149, {
    "Array | Matrix, Array | Matrix": function Array__Matrix_Array__Matrix(a1, a2) {
      if (subset2(size2(a1), new Index2(0)) === 0) {
        return flatten(a2);
      } else if (subset2(size2(a2), new Index2(0)) === 0) {
        return flatten(a1);
      }
      var b1 = flatten(a1);
      var b2 = flatten(a2);
      return concat3(setSymDifference2(b1, b2), setIntersect2(b1, b2));
    }
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/add.js
var name150 = "add";
var dependencies150 = ["typed", "matrix", "addScalar", "equalScalar", "DenseMatrix", "SparseMatrix", "concat"];
var createAdd = factory(name150, dependencies150, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    addScalar: addScalar2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix: SparseMatrix2,
    concat: concat3
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo04xSidSid = createMatAlgo04xSidSid({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat3
  });
  return typed2(name150, {
    "any, any": addScalar2,
    "any, any, ...any": typed2.referToSelf((self) => (x, y, rest) => {
      var result = self(x, y);
      for (var i2 = 0; i2 < rest.length; i2++) {
        result = self(result, rest[i2]);
      }
      return result;
    })
  }, matrixAlgorithmSuite({
    elop: addScalar2,
    DS: matAlgo01xDSid,
    SS: matAlgo04xSidSid,
    Ss: matAlgo10xSids
  }));
});

// node_modules/mathjs/lib/esm/function/arithmetic/norm.js
var name151 = "norm";
var dependencies151 = ["typed", "abs", "add", "pow", "conj", "sqrt", "multiply", "equalScalar", "larger", "smaller", "matrix", "ctranspose", "eigs"];
var createNorm = factory(name151, dependencies151, (_ref) => {
  var {
    typed: typed2,
    abs: abs2,
    add: add2,
    pow: pow2,
    conj: conj2,
    sqrt: sqrt2,
    multiply: multiply2,
    equalScalar: equalScalar2,
    larger: larger2,
    smaller: smaller2,
    matrix: matrix2,
    ctranspose: ctranspose2,
    eigs: eigs2
  } = _ref;
  return typed2(name151, {
    number: Math.abs,
    Complex: function Complex3(x) {
      return x.abs();
    },
    BigNumber: function BigNumber2(x) {
      return x.abs();
    },
    boolean: function boolean2(x) {
      return Math.abs(x);
    },
    Array: function Array2(x) {
      return _norm(matrix2(x), 2);
    },
    Matrix: function Matrix2(x) {
      return _norm(x, 2);
    },
    "Array, number | BigNumber | string": function Array_number__BigNumber__string(x, p) {
      return _norm(matrix2(x), p);
    },
    "Matrix, number | BigNumber | string": function Matrix_number__BigNumber__string(x, p) {
      return _norm(x, p);
    }
  });
  function _vectorNormPlusInfinity(x) {
    var pinf = 0;
    x.forEach(function(value) {
      var v = abs2(value);
      if (larger2(v, pinf)) {
        pinf = v;
      }
    }, true);
    return pinf;
  }
  function _vectorNormMinusInfinity(x) {
    var ninf;
    x.forEach(function(value) {
      var v = abs2(value);
      if (!ninf || smaller2(v, ninf)) {
        ninf = v;
      }
    }, true);
    return ninf || 0;
  }
  function _vectorNorm(x, p) {
    if (p === Number.POSITIVE_INFINITY || p === "inf") {
      return _vectorNormPlusInfinity(x);
    }
    if (p === Number.NEGATIVE_INFINITY || p === "-inf") {
      return _vectorNormMinusInfinity(x);
    }
    if (p === "fro") {
      return _norm(x, 2);
    }
    if (typeof p === "number" && !isNaN(p)) {
      if (!equalScalar2(p, 0)) {
        var n = 0;
        x.forEach(function(value) {
          n = add2(pow2(abs2(value), p), n);
        }, true);
        return pow2(n, 1 / p);
      }
      return Number.POSITIVE_INFINITY;
    }
    throw new Error("Unsupported parameter value");
  }
  function _matrixNormFrobenius(x) {
    var fro = 0;
    x.forEach(function(value, index2) {
      fro = add2(fro, multiply2(value, conj2(value)));
    });
    return abs2(sqrt2(fro));
  }
  function _matrixNormOne(x) {
    var c = [];
    var maxc = 0;
    x.forEach(function(value, index2) {
      var j = index2[1];
      var cj = add2(c[j] || 0, abs2(value));
      if (larger2(cj, maxc)) {
        maxc = cj;
      }
      c[j] = cj;
    }, true);
    return maxc;
  }
  function _matrixNormTwo(x) {
    var sizeX = x.size();
    if (sizeX[0] !== sizeX[1]) {
      throw new RangeError("Invalid matrix dimensions");
    }
    var tx = ctranspose2(x);
    var squaredX = multiply2(tx, x);
    var eigenVals = eigs2(squaredX).values.toArray();
    var rho = eigenVals[eigenVals.length - 1];
    return abs2(sqrt2(rho));
  }
  function _matrixNormInfinity(x) {
    var r = [];
    var maxr = 0;
    x.forEach(function(value, index2) {
      var i2 = index2[0];
      var ri = add2(r[i2] || 0, abs2(value));
      if (larger2(ri, maxr)) {
        maxr = ri;
      }
      r[i2] = ri;
    }, true);
    return maxr;
  }
  function _matrixNorm(x, p) {
    if (p === 1) {
      return _matrixNormOne(x);
    }
    if (p === Number.POSITIVE_INFINITY || p === "inf") {
      return _matrixNormInfinity(x);
    }
    if (p === "fro") {
      return _matrixNormFrobenius(x);
    }
    if (p === 2) {
      return _matrixNormTwo(x);
    }
    throw new Error("Unsupported parameter value " + p);
  }
  function _norm(x, p) {
    var sizeX = x.size();
    if (sizeX.length === 1) {
      return _vectorNorm(x, p);
    }
    if (sizeX.length === 2) {
      if (sizeX[0] && sizeX[1]) {
        return _matrixNorm(x, p);
      } else {
        throw new RangeError("Invalid matrix dimensions");
      }
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/dot.js
var name152 = "dot";
var dependencies152 = ["typed", "addScalar", "multiplyScalar", "conj", "size"];
var createDot = factory(name152, dependencies152, (_ref) => {
  var {
    typed: typed2,
    addScalar: addScalar2,
    multiplyScalar: multiplyScalar2,
    conj: conj2,
    size: size2
  } = _ref;
  return typed2(name152, {
    "Array | DenseMatrix, Array | DenseMatrix": _denseDot,
    "SparseMatrix, SparseMatrix": _sparseDot
  });
  function _validateDim(x, y) {
    var xSize = _size(x);
    var ySize = _size(y);
    var xLen, yLen;
    if (xSize.length === 1) {
      xLen = xSize[0];
    } else if (xSize.length === 2 && xSize[1] === 1) {
      xLen = xSize[0];
    } else {
      throw new RangeError("Expected a column vector, instead got a matrix of size (" + xSize.join(", ") + ")");
    }
    if (ySize.length === 1) {
      yLen = ySize[0];
    } else if (ySize.length === 2 && ySize[1] === 1) {
      yLen = ySize[0];
    } else {
      throw new RangeError("Expected a column vector, instead got a matrix of size (" + ySize.join(", ") + ")");
    }
    if (xLen !== yLen) throw new RangeError("Vectors must have equal length (" + xLen + " != " + yLen + ")");
    if (xLen === 0) throw new RangeError("Cannot calculate the dot product of empty vectors");
    return xLen;
  }
  function _denseDot(a, b) {
    var N = _validateDim(a, b);
    var adata = isMatrix(a) ? a._data : a;
    var adt = isMatrix(a) ? a._datatype || a.getDataType() : void 0;
    var bdata = isMatrix(b) ? b._data : b;
    var bdt = isMatrix(b) ? b._datatype || b.getDataType() : void 0;
    var aIsColumn = _size(a).length === 2;
    var bIsColumn = _size(b).length === 2;
    var add2 = addScalar2;
    var mul = multiplyScalar2;
    if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
      var dt = adt;
      add2 = typed2.find(addScalar2, [dt, dt]);
      mul = typed2.find(multiplyScalar2, [dt, dt]);
    }
    if (!aIsColumn && !bIsColumn) {
      var c = mul(conj2(adata[0]), bdata[0]);
      for (var i2 = 1; i2 < N; i2++) {
        c = add2(c, mul(conj2(adata[i2]), bdata[i2]));
      }
      return c;
    }
    if (!aIsColumn && bIsColumn) {
      var _c = mul(conj2(adata[0]), bdata[0][0]);
      for (var _i = 1; _i < N; _i++) {
        _c = add2(_c, mul(conj2(adata[_i]), bdata[_i][0]));
      }
      return _c;
    }
    if (aIsColumn && !bIsColumn) {
      var _c2 = mul(conj2(adata[0][0]), bdata[0]);
      for (var _i2 = 1; _i2 < N; _i2++) {
        _c2 = add2(_c2, mul(conj2(adata[_i2][0]), bdata[_i2]));
      }
      return _c2;
    }
    if (aIsColumn && bIsColumn) {
      var _c3 = mul(conj2(adata[0][0]), bdata[0][0]);
      for (var _i3 = 1; _i3 < N; _i3++) {
        _c3 = add2(_c3, mul(conj2(adata[_i3][0]), bdata[_i3][0]));
      }
      return _c3;
    }
  }
  function _sparseDot(x, y) {
    _validateDim(x, y);
    var xindex = x._index;
    var xvalues = x._values;
    var yindex = y._index;
    var yvalues = y._values;
    var c = 0;
    var add2 = addScalar2;
    var mul = multiplyScalar2;
    var i2 = 0;
    var j = 0;
    while (i2 < xindex.length && j < yindex.length) {
      var I = xindex[i2];
      var J = yindex[j];
      if (I < J) {
        i2++;
        continue;
      }
      if (I > J) {
        j++;
        continue;
      }
      if (I === J) {
        c = add2(c, mul(xvalues[i2], yvalues[j]));
        i2++;
        j++;
      }
    }
    return c;
  }
  function _size(x) {
    return isMatrix(x) ? x.size() : size2(x);
  }
});

// node_modules/mathjs/lib/esm/function/matrix/trace.js
var name153 = "trace";
var dependencies153 = ["typed", "matrix", "add"];
var createTrace = factory(name153, dependencies153, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    add: add2
  } = _ref;
  return typed2("trace", {
    Array: function _arrayTrace(x) {
      return _denseTrace(matrix2(x));
    },
    SparseMatrix: _sparseTrace,
    DenseMatrix: _denseTrace,
    any: clone
  });
  function _denseTrace(m) {
    var size2 = m._size;
    var data = m._data;
    switch (size2.length) {
      case 1:
        if (size2[0] === 1) {
          return clone(data[0]);
        }
        throw new RangeError("Matrix must be square (size: " + format2(size2) + ")");
      case 2: {
        var rows = size2[0];
        var cols = size2[1];
        if (rows === cols) {
          var sum2 = 0;
          for (var i2 = 0; i2 < rows; i2++) {
            sum2 = add2(sum2, data[i2][i2]);
          }
          return sum2;
        } else {
          throw new RangeError("Matrix must be square (size: " + format2(size2) + ")");
        }
      }
      default:
        throw new RangeError("Matrix must be two dimensional (size: " + format2(size2) + ")");
    }
  }
  function _sparseTrace(m) {
    var values = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    var size2 = m._size;
    var rows = size2[0];
    var columns = size2[1];
    if (rows === columns) {
      var sum2 = 0;
      if (values.length > 0) {
        for (var j = 0; j < columns; j++) {
          var k0 = ptr[j];
          var k1 = ptr[j + 1];
          for (var k = k0; k < k1; k++) {
            var i2 = index2[k];
            if (i2 === j) {
              sum2 = add2(sum2, values[k]);
              break;
            }
            if (i2 > j) {
              break;
            }
          }
        }
      }
      return sum2;
    }
    throw new RangeError("Matrix must be square (size: " + format2(size2) + ")");
  }
});

// node_modules/mathjs/lib/esm/type/matrix/function/index.js
var name154 = "index";
var dependencies154 = ["typed", "Index"];
var createIndex = factory(name154, dependencies154, (_ref) => {
  var {
    typed: typed2,
    Index: Index2
  } = _ref;
  return typed2(name154, {
    "...number | string | BigNumber | Range | Array | Matrix": function number__string__BigNumber__Range__Array__Matrix(args) {
      var ranges = args.map(function(arg2) {
        if (isBigNumber(arg2)) {
          return arg2.toNumber();
        } else if (isArray(arg2) || isMatrix(arg2)) {
          return arg2.map(function(elem) {
            return isBigNumber(elem) ? elem.toNumber() : elem;
          });
        } else {
          return arg2;
        }
      });
      var res = new Index2();
      Index2.apply(res, ranges);
      return res;
    }
  });
});

// node_modules/mathjs/lib/esm/function/algebra/decomposition/lup.js
var name155 = "lup";
var dependencies155 = ["typed", "matrix", "abs", "addScalar", "divideScalar", "multiplyScalar", "subtractScalar", "larger", "equalScalar", "unaryMinus", "DenseMatrix", "SparseMatrix", "Spa"];
var createLup = factory(name155, dependencies155, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    abs: abs2,
    addScalar: addScalar2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    subtractScalar: subtractScalar2,
    larger: larger2,
    equalScalar: equalScalar2,
    unaryMinus: unaryMinus2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix: SparseMatrix2,
    Spa: Spa2
  } = _ref;
  return typed2(name155, {
    DenseMatrix: function DenseMatrix3(m) {
      return _denseLUP(m);
    },
    SparseMatrix: function SparseMatrix3(m) {
      return _sparseLUP(m);
    },
    Array: function Array2(a) {
      var m = matrix2(a);
      var r = _denseLUP(m);
      return {
        L: r.L.valueOf(),
        U: r.U.valueOf(),
        p: r.p
      };
    }
  });
  function _denseLUP(m) {
    var rows = m._size[0];
    var columns = m._size[1];
    var n = Math.min(rows, columns);
    var data = clone(m._data);
    var ldata = [];
    var lsize = [rows, n];
    var udata = [];
    var usize = [n, columns];
    var i2, j, k;
    var p = [];
    for (i2 = 0; i2 < rows; i2++) {
      p[i2] = i2;
    }
    for (j = 0; j < columns; j++) {
      if (j > 0) {
        for (i2 = 0; i2 < rows; i2++) {
          var min2 = Math.min(i2, j);
          var s = 0;
          for (k = 0; k < min2; k++) {
            s = addScalar2(s, multiplyScalar2(data[i2][k], data[k][j]));
          }
          data[i2][j] = subtractScalar2(data[i2][j], s);
        }
      }
      var pi2 = j;
      var pabsv = 0;
      var vjj = 0;
      for (i2 = j; i2 < rows; i2++) {
        var v = data[i2][j];
        var absv = abs2(v);
        if (larger2(absv, pabsv)) {
          pi2 = i2;
          pabsv = absv;
          vjj = v;
        }
      }
      if (j !== pi2) {
        p[j] = [p[pi2], p[pi2] = p[j]][0];
        DenseMatrix2._swapRows(j, pi2, data);
      }
      if (j < rows) {
        for (i2 = j + 1; i2 < rows; i2++) {
          var vij = data[i2][j];
          if (!equalScalar2(vij, 0)) {
            data[i2][j] = divideScalar2(data[i2][j], vjj);
          }
        }
      }
    }
    for (j = 0; j < columns; j++) {
      for (i2 = 0; i2 < rows; i2++) {
        if (j === 0) {
          if (i2 < columns) {
            udata[i2] = [];
          }
          ldata[i2] = [];
        }
        if (i2 < j) {
          if (i2 < columns) {
            udata[i2][j] = data[i2][j];
          }
          if (j < rows) {
            ldata[i2][j] = 0;
          }
          continue;
        }
        if (i2 === j) {
          if (i2 < columns) {
            udata[i2][j] = data[i2][j];
          }
          if (j < rows) {
            ldata[i2][j] = 1;
          }
          continue;
        }
        if (i2 < columns) {
          udata[i2][j] = 0;
        }
        if (j < rows) {
          ldata[i2][j] = data[i2][j];
        }
      }
    }
    var l = new DenseMatrix2({
      data: ldata,
      size: lsize
    });
    var u = new DenseMatrix2({
      data: udata,
      size: usize
    });
    var pv = [];
    for (i2 = 0, n = p.length; i2 < n; i2++) {
      pv[p[i2]] = i2;
    }
    return {
      L: l,
      U: u,
      p: pv,
      toString: function toString() {
        return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\nP: " + this.p;
      }
    };
  }
  function _sparseLUP(m) {
    var rows = m._size[0];
    var columns = m._size[1];
    var n = Math.min(rows, columns);
    var values = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    var lvalues = [];
    var lindex = [];
    var lptr = [];
    var lsize = [rows, n];
    var uvalues = [];
    var uindex = [];
    var uptr = [];
    var usize = [n, columns];
    var i2, j, k;
    var pvCo = [];
    var pvOc = [];
    for (i2 = 0; i2 < rows; i2++) {
      pvCo[i2] = i2;
      pvOc[i2] = i2;
    }
    var swapIndeces = function swapIndeces2(x, y) {
      var kx = pvOc[x];
      var ky = pvOc[y];
      pvCo[kx] = y;
      pvCo[ky] = x;
      pvOc[x] = ky;
      pvOc[y] = kx;
    };
    var _loop = function _loop2() {
      var spa = new Spa2();
      if (j < rows) {
        lptr.push(lvalues.length);
        lvalues.push(1);
        lindex.push(j);
      }
      uptr.push(uvalues.length);
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      for (k = k0; k < k1; k++) {
        i2 = index2[k];
        spa.set(pvCo[i2], values[k]);
      }
      if (j > 0) {
        spa.forEach(0, j - 1, function(k2, vkj) {
          SparseMatrix2._forEachRow(k2, lvalues, lindex, lptr, function(i3, vik) {
            if (i3 > k2) {
              spa.accumulate(i3, unaryMinus2(multiplyScalar2(vik, vkj)));
            }
          });
        });
      }
      var pi2 = j;
      var vjj = spa.get(j);
      var pabsv = abs2(vjj);
      spa.forEach(j + 1, rows - 1, function(x, v) {
        var absv = abs2(v);
        if (larger2(absv, pabsv)) {
          pi2 = x;
          pabsv = absv;
          vjj = v;
        }
      });
      if (j !== pi2) {
        SparseMatrix2._swapRows(j, pi2, lsize[1], lvalues, lindex, lptr);
        SparseMatrix2._swapRows(j, pi2, usize[1], uvalues, uindex, uptr);
        spa.swap(j, pi2);
        swapIndeces(j, pi2);
      }
      spa.forEach(0, rows - 1, function(x, v) {
        if (x <= j) {
          uvalues.push(v);
          uindex.push(x);
        } else {
          v = divideScalar2(v, vjj);
          if (!equalScalar2(v, 0)) {
            lvalues.push(v);
            lindex.push(x);
          }
        }
      });
    };
    for (j = 0; j < columns; j++) {
      _loop();
    }
    uptr.push(uvalues.length);
    lptr.push(lvalues.length);
    return {
      L: new SparseMatrix2({
        values: lvalues,
        index: lindex,
        ptr: lptr,
        size: lsize
      }),
      U: new SparseMatrix2({
        values: uvalues,
        index: uindex,
        ptr: uptr,
        size: usize
      }),
      p: pvCo,
      toString: function toString() {
        return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\nP: " + this.p;
      }
    };
  }
});

// node_modules/mathjs/lib/esm/function/algebra/decomposition/qr.js
var name156 = "qr";
var dependencies156 = ["typed", "matrix", "zeros", "identity", "isZero", "equal", "sign", "sqrt", "conj", "unaryMinus", "addScalar", "divideScalar", "multiplyScalar", "subtractScalar", "complex"];
var createQr = factory(name156, dependencies156, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    zeros: zeros2,
    identity: identity2,
    isZero: isZero2,
    equal: equal2,
    sign: sign2,
    sqrt: sqrt2,
    conj: conj2,
    unaryMinus: unaryMinus2,
    addScalar: addScalar2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    subtractScalar: subtractScalar2,
    complex: complex2
  } = _ref;
  return _extends(typed2(name156, {
    DenseMatrix: function DenseMatrix2(m) {
      return _denseQR(m);
    },
    SparseMatrix: function SparseMatrix2(m) {
      return _sparseQR(m);
    },
    Array: function Array2(a) {
      var m = matrix2(a);
      var r = _denseQR(m);
      return {
        Q: r.Q.valueOf(),
        R: r.R.valueOf()
      };
    }
  }), {
    _denseQRimpl
  });
  function _denseQRimpl(m) {
    var rows = m._size[0];
    var cols = m._size[1];
    var Q = identity2([rows], "dense");
    var Qdata = Q._data;
    var R = m.clone();
    var Rdata = R._data;
    var i2, j, k;
    var w = zeros2([rows], "");
    for (k = 0; k < Math.min(cols, rows); ++k) {
      var pivot = Rdata[k][k];
      var sgn = unaryMinus2(equal2(pivot, 0) ? 1 : sign2(pivot));
      var conjSgn = conj2(sgn);
      var alphaSquared = 0;
      for (i2 = k; i2 < rows; i2++) {
        alphaSquared = addScalar2(alphaSquared, multiplyScalar2(Rdata[i2][k], conj2(Rdata[i2][k])));
      }
      var alpha = multiplyScalar2(sgn, sqrt2(alphaSquared));
      if (!isZero2(alpha)) {
        var u1 = subtractScalar2(pivot, alpha);
        w[k] = 1;
        for (i2 = k + 1; i2 < rows; i2++) {
          w[i2] = divideScalar2(Rdata[i2][k], u1);
        }
        var tau2 = unaryMinus2(conj2(divideScalar2(u1, alpha)));
        var s = void 0;
        for (j = k; j < cols; j++) {
          s = 0;
          for (i2 = k; i2 < rows; i2++) {
            s = addScalar2(s, multiplyScalar2(conj2(w[i2]), Rdata[i2][j]));
          }
          s = multiplyScalar2(s, tau2);
          for (i2 = k; i2 < rows; i2++) {
            Rdata[i2][j] = multiplyScalar2(subtractScalar2(Rdata[i2][j], multiplyScalar2(w[i2], s)), conjSgn);
          }
        }
        for (i2 = 0; i2 < rows; i2++) {
          s = 0;
          for (j = k; j < rows; j++) {
            s = addScalar2(s, multiplyScalar2(Qdata[i2][j], w[j]));
          }
          s = multiplyScalar2(s, tau2);
          for (j = k; j < rows; ++j) {
            Qdata[i2][j] = divideScalar2(subtractScalar2(Qdata[i2][j], multiplyScalar2(s, conj2(w[j]))), conjSgn);
          }
        }
      }
    }
    return {
      Q,
      R,
      toString: function toString() {
        return "Q: " + this.Q.toString() + "\nR: " + this.R.toString();
      }
    };
  }
  function _denseQR(m) {
    var ret = _denseQRimpl(m);
    var Rdata = ret.R._data;
    if (m._data.length > 0) {
      var zero = Rdata[0][0].type === "Complex" ? complex2(0) : 0;
      for (var i2 = 0; i2 < Rdata.length; ++i2) {
        for (var j = 0; j < i2 && j < (Rdata[0] || []).length; ++j) {
          Rdata[i2][j] = zero;
        }
      }
    }
    return ret;
  }
  function _sparseQR(m) {
    throw new Error("qr not implemented for sparse matrices yet");
  }
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csPermute.js
function csPermute(a, pinv2, q, values) {
  var avalues = a._values;
  var aindex = a._index;
  var aptr = a._ptr;
  var asize = a._size;
  var adt = a._datatype;
  var m = asize[0];
  var n = asize[1];
  var cvalues = values && a._values ? [] : null;
  var cindex = [];
  var cptr = [];
  var nz = 0;
  for (var k = 0; k < n; k++) {
    cptr[k] = nz;
    var j = q ? q[k] : k;
    for (var t0 = aptr[j], t1 = aptr[j + 1], t = t0; t < t1; t++) {
      var r = pinv2 ? pinv2[aindex[t]] : aindex[t];
      cindex[nz] = r;
      if (cvalues) {
        cvalues[nz] = avalues[t];
      }
      nz++;
    }
  }
  cptr[n] = nz;
  return a.createSparseMatrix({
    values: cvalues,
    index: cindex,
    ptr: cptr,
    size: [m, n],
    datatype: adt
  });
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csTdfs.js
function csTdfs(j, k, w, head, next, post, stack) {
  var top = 0;
  w[stack] = j;
  while (top >= 0) {
    var p = w[stack + top];
    var i2 = w[head + p];
    if (i2 === -1) {
      top--;
      post[k++] = p;
    } else {
      w[head + p] = w[next + i2];
      ++top;
      w[stack + top] = i2;
    }
  }
  return k;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csPost.js
function csPost(parent, n) {
  if (!parent) {
    return null;
  }
  var k = 0;
  var j;
  var post = [];
  var w = [];
  var head = 0;
  var next = n;
  var stack = 2 * n;
  for (j = 0; j < n; j++) {
    w[head + j] = -1;
  }
  for (j = n - 1; j >= 0; j--) {
    if (parent[j] === -1) {
      continue;
    }
    w[next + j] = w[head + parent[j]];
    w[head + parent[j]] = j;
  }
  for (j = 0; j < n; j++) {
    if (parent[j] !== -1) {
      continue;
    }
    k = csTdfs(j, k, w, head, next, post, stack);
  }
  return post;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csEtree.js
function csEtree(a, ata) {
  if (!a) {
    return null;
  }
  var aindex = a._index;
  var aptr = a._ptr;
  var asize = a._size;
  var m = asize[0];
  var n = asize[1];
  var parent = [];
  var w = [];
  var ancestor = 0;
  var prev = n;
  var i2, inext;
  if (ata) {
    for (i2 = 0; i2 < m; i2++) {
      w[prev + i2] = -1;
    }
  }
  for (var k = 0; k < n; k++) {
    parent[k] = -1;
    w[ancestor + k] = -1;
    for (var p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {
      var r = aindex[p];
      i2 = ata ? w[prev + r] : r;
      for (; i2 !== -1 && i2 < k; i2 = inext) {
        inext = w[ancestor + i2];
        w[ancestor + i2] = k;
        if (inext === -1) {
          parent[i2] = k;
        }
      }
      if (ata) {
        w[prev + r] = k;
      }
    }
  }
  return parent;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csFkeep.js
function csFkeep(a, callback, other) {
  var avalues = a._values;
  var aindex = a._index;
  var aptr = a._ptr;
  var asize = a._size;
  var n = asize[1];
  var nz = 0;
  for (var j = 0; j < n; j++) {
    var p = aptr[j];
    aptr[j] = nz;
    for (; p < aptr[j + 1]; p++) {
      if (callback(aindex[p], j, avalues ? avalues[p] : 1, other)) {
        aindex[nz] = aindex[p];
        if (avalues) {
          avalues[nz] = avalues[p];
        }
        nz++;
      }
    }
  }
  aptr[n] = nz;
  aindex.splice(nz, aindex.length - nz);
  if (avalues) {
    avalues.splice(nz, avalues.length - nz);
  }
  return nz;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csFlip.js
function csFlip(i2) {
  return -i2 - 2;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csAmd.js
var name157 = "csAmd";
var dependencies157 = ["add", "multiply", "transpose"];
var createCsAmd = factory(name157, dependencies157, (_ref) => {
  var {
    add: add2,
    multiply: multiply2,
    transpose: transpose2
  } = _ref;
  return function csAmd(order, a) {
    if (!a || order <= 0 || order > 3) {
      return null;
    }
    var asize = a._size;
    var m = asize[0];
    var n = asize[1];
    var lemax = 0;
    var dense = Math.max(16, 10 * Math.sqrt(n));
    dense = Math.min(n - 2, dense);
    var cm = _createTargetMatrix(order, a, m, n, dense);
    csFkeep(cm, _diag, null);
    var cindex = cm._index;
    var cptr = cm._ptr;
    var cnz = cptr[n];
    var P3 = [];
    var W = [];
    var len = 0;
    var nv = n + 1;
    var next = 2 * (n + 1);
    var head = 3 * (n + 1);
    var elen = 4 * (n + 1);
    var degree = 5 * (n + 1);
    var w = 6 * (n + 1);
    var hhead = 7 * (n + 1);
    var last = P3;
    var mark = _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree);
    var nel = _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next);
    var mindeg = 0;
    var i2, j, k, k1, k2, e2, pj, ln, nvi, pk, eln, p1, p2, pn, h, d;
    while (nel < n) {
      for (k = -1; mindeg < n && (k = W[head + mindeg]) === -1; mindeg++) ;
      if (W[next + k] !== -1) {
        last[W[next + k]] = -1;
      }
      W[head + mindeg] = W[next + k];
      var elenk = W[elen + k];
      var nvk = W[nv + k];
      nel += nvk;
      var dk = 0;
      W[nv + k] = -nvk;
      var p = cptr[k];
      var pk1 = elenk === 0 ? p : cnz;
      var pk2 = pk1;
      for (k1 = 1; k1 <= elenk + 1; k1++) {
        if (k1 > elenk) {
          e2 = k;
          pj = p;
          ln = W[len + k] - elenk;
        } else {
          e2 = cindex[p++];
          pj = cptr[e2];
          ln = W[len + e2];
        }
        for (k2 = 1; k2 <= ln; k2++) {
          i2 = cindex[pj++];
          if ((nvi = W[nv + i2]) <= 0) {
            continue;
          }
          dk += nvi;
          W[nv + i2] = -nvi;
          cindex[pk2++] = i2;
          if (W[next + i2] !== -1) {
            last[W[next + i2]] = last[i2];
          }
          if (last[i2] !== -1) {
            W[next + last[i2]] = W[next + i2];
          } else {
            W[head + W[degree + i2]] = W[next + i2];
          }
        }
        if (e2 !== k) {
          cptr[e2] = csFlip(k);
          W[w + e2] = 0;
        }
      }
      if (elenk !== 0) {
        cnz = pk2;
      }
      W[degree + k] = dk;
      cptr[k] = pk1;
      W[len + k] = pk2 - pk1;
      W[elen + k] = -2;
      mark = _wclear(mark, lemax, W, w, n);
      for (pk = pk1; pk < pk2; pk++) {
        i2 = cindex[pk];
        if ((eln = W[elen + i2]) <= 0) {
          continue;
        }
        nvi = -W[nv + i2];
        var wnvi = mark - nvi;
        for (p = cptr[i2], p1 = cptr[i2] + eln - 1; p <= p1; p++) {
          e2 = cindex[p];
          if (W[w + e2] >= mark) {
            W[w + e2] -= nvi;
          } else if (W[w + e2] !== 0) {
            W[w + e2] = W[degree + e2] + wnvi;
          }
        }
      }
      for (pk = pk1; pk < pk2; pk++) {
        i2 = cindex[pk];
        p1 = cptr[i2];
        p2 = p1 + W[elen + i2] - 1;
        pn = p1;
        for (h = 0, d = 0, p = p1; p <= p2; p++) {
          e2 = cindex[p];
          if (W[w + e2] !== 0) {
            var dext = W[w + e2] - mark;
            if (dext > 0) {
              d += dext;
              cindex[pn++] = e2;
              h += e2;
            } else {
              cptr[e2] = csFlip(k);
              W[w + e2] = 0;
            }
          }
        }
        W[elen + i2] = pn - p1 + 1;
        var p3 = pn;
        var p4 = p1 + W[len + i2];
        for (p = p2 + 1; p < p4; p++) {
          j = cindex[p];
          var nvj = W[nv + j];
          if (nvj <= 0) {
            continue;
          }
          d += nvj;
          cindex[pn++] = j;
          h += j;
        }
        if (d === 0) {
          cptr[i2] = csFlip(k);
          nvi = -W[nv + i2];
          dk -= nvi;
          nvk += nvi;
          nel += nvi;
          W[nv + i2] = 0;
          W[elen + i2] = -1;
        } else {
          W[degree + i2] = Math.min(W[degree + i2], d);
          cindex[pn] = cindex[p3];
          cindex[p3] = cindex[p1];
          cindex[p1] = k;
          W[len + i2] = pn - p1 + 1;
          h = (h < 0 ? -h : h) % n;
          W[next + i2] = W[hhead + h];
          W[hhead + h] = i2;
          last[i2] = h;
        }
      }
      W[degree + k] = dk;
      lemax = Math.max(lemax, dk);
      mark = _wclear(mark + lemax, lemax, W, w, n);
      for (pk = pk1; pk < pk2; pk++) {
        i2 = cindex[pk];
        if (W[nv + i2] >= 0) {
          continue;
        }
        h = last[i2];
        i2 = W[hhead + h];
        W[hhead + h] = -1;
        for (; i2 !== -1 && W[next + i2] !== -1; i2 = W[next + i2], mark++) {
          ln = W[len + i2];
          eln = W[elen + i2];
          for (p = cptr[i2] + 1; p <= cptr[i2] + ln - 1; p++) {
            W[w + cindex[p]] = mark;
          }
          var jlast = i2;
          for (j = W[next + i2]; j !== -1; ) {
            var ok = W[len + j] === ln && W[elen + j] === eln;
            for (p = cptr[j] + 1; ok && p <= cptr[j] + ln - 1; p++) {
              if (W[w + cindex[p]] !== mark) {
                ok = 0;
              }
            }
            if (ok) {
              cptr[j] = csFlip(i2);
              W[nv + i2] += W[nv + j];
              W[nv + j] = 0;
              W[elen + j] = -1;
              j = W[next + j];
              W[next + jlast] = j;
            } else {
              jlast = j;
              j = W[next + j];
            }
          }
        }
      }
      for (p = pk1, pk = pk1; pk < pk2; pk++) {
        i2 = cindex[pk];
        if ((nvi = -W[nv + i2]) <= 0) {
          continue;
        }
        W[nv + i2] = nvi;
        d = W[degree + i2] + dk - nvi;
        d = Math.min(d, n - nel - nvi);
        if (W[head + d] !== -1) {
          last[W[head + d]] = i2;
        }
        W[next + i2] = W[head + d];
        last[i2] = -1;
        W[head + d] = i2;
        mindeg = Math.min(mindeg, d);
        W[degree + i2] = d;
        cindex[p++] = i2;
      }
      W[nv + k] = nvk;
      if ((W[len + k] = p - pk1) === 0) {
        cptr[k] = -1;
        W[w + k] = 0;
      }
      if (elenk !== 0) {
        cnz = p;
      }
    }
    for (i2 = 0; i2 < n; i2++) {
      cptr[i2] = csFlip(cptr[i2]);
    }
    for (j = 0; j <= n; j++) {
      W[head + j] = -1;
    }
    for (j = n; j >= 0; j--) {
      if (W[nv + j] > 0) {
        continue;
      }
      W[next + j] = W[head + cptr[j]];
      W[head + cptr[j]] = j;
    }
    for (e2 = n; e2 >= 0; e2--) {
      if (W[nv + e2] <= 0) {
        continue;
      }
      if (cptr[e2] !== -1) {
        W[next + e2] = W[head + cptr[e2]];
        W[head + cptr[e2]] = e2;
      }
    }
    for (k = 0, i2 = 0; i2 <= n; i2++) {
      if (cptr[i2] === -1) {
        k = csTdfs(i2, k, W, head, next, P3, w);
      }
    }
    P3.splice(P3.length - 1, 1);
    return P3;
  };
  function _createTargetMatrix(order, a, m, n, dense) {
    var at = transpose2(a);
    if (order === 1 && n === m) {
      return add2(a, at);
    }
    if (order === 2) {
      var tindex = at._index;
      var tptr = at._ptr;
      var p2 = 0;
      for (var j = 0; j < m; j++) {
        var p = tptr[j];
        tptr[j] = p2;
        if (tptr[j + 1] - p > dense) {
          continue;
        }
        for (var p1 = tptr[j + 1]; p < p1; p++) {
          tindex[p2++] = tindex[p];
        }
      }
      tptr[m] = p2;
      a = transpose2(at);
      return multiply2(at, a);
    }
    return multiply2(at, a);
  }
  function _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree) {
    for (var k = 0; k < n; k++) {
      W[len + k] = cptr[k + 1] - cptr[k];
    }
    W[len + n] = 0;
    for (var i2 = 0; i2 <= n; i2++) {
      W[head + i2] = -1;
      last[i2] = -1;
      W[next + i2] = -1;
      W[hhead + i2] = -1;
      W[nv + i2] = 1;
      W[w + i2] = 1;
      W[elen + i2] = 0;
      W[degree + i2] = W[len + i2];
    }
    var mark = _wclear(0, 0, W, w, n);
    W[elen + n] = -2;
    cptr[n] = -1;
    W[w + n] = 0;
    return mark;
  }
  function _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next) {
    var nel = 0;
    for (var i2 = 0; i2 < n; i2++) {
      var d = W[degree + i2];
      if (d === 0) {
        W[elen + i2] = -2;
        nel++;
        cptr[i2] = -1;
        W[w + i2] = 0;
      } else if (d > dense) {
        W[nv + i2] = 0;
        W[elen + i2] = -1;
        nel++;
        cptr[i2] = csFlip(n);
        W[nv + n]++;
      } else {
        var h = W[head + d];
        if (h !== -1) {
          last[h] = i2;
        }
        W[next + i2] = W[head + d];
        W[head + d] = i2;
      }
    }
    return nel;
  }
  function _wclear(mark, lemax, W, w, n) {
    if (mark < 2 || mark + lemax < 0) {
      for (var k = 0; k < n; k++) {
        if (W[w + k] !== 0) {
          W[w + k] = 1;
        }
      }
      mark = 2;
    }
    return mark;
  }
  function _diag(i2, j) {
    return i2 !== j;
  }
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csLeaf.js
function csLeaf(i2, j, w, first, maxfirst, prevleaf, ancestor) {
  var s, sparent;
  var jleaf = 0;
  var q;
  if (i2 <= j || w[first + j] <= w[maxfirst + i2]) {
    return -1;
  }
  w[maxfirst + i2] = w[first + j];
  var jprev = w[prevleaf + i2];
  w[prevleaf + i2] = j;
  if (jprev === -1) {
    jleaf = 1;
    q = i2;
  } else {
    jleaf = 2;
    for (q = jprev; q !== w[ancestor + q]; q = w[ancestor + q]) ;
    for (s = jprev; s !== q; s = sparent) {
      sparent = w[ancestor + s];
      w[ancestor + s] = q;
    }
  }
  return {
    jleaf,
    q
  };
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csCounts.js
var name158 = "csCounts";
var dependencies158 = ["transpose"];
var createCsCounts = factory(name158, dependencies158, (_ref) => {
  var {
    transpose: transpose2
  } = _ref;
  return function(a, parent, post, ata) {
    if (!a || !parent || !post) {
      return null;
    }
    var asize = a._size;
    var m = asize[0];
    var n = asize[1];
    var i2, j, k, J, p, p0, p1;
    var s = 4 * n + (ata ? n + m + 1 : 0);
    var w = [];
    var ancestor = 0;
    var maxfirst = n;
    var prevleaf = 2 * n;
    var first = 3 * n;
    var head = 4 * n;
    var next = 5 * n + 1;
    for (k = 0; k < s; k++) {
      w[k] = -1;
    }
    var colcount = [];
    var at = transpose2(a);
    var tindex = at._index;
    var tptr = at._ptr;
    for (k = 0; k < n; k++) {
      j = post[k];
      colcount[j] = w[first + j] === -1 ? 1 : 0;
      for (; j !== -1 && w[first + j] === -1; j = parent[j]) {
        w[first + j] = k;
      }
    }
    if (ata) {
      for (k = 0; k < n; k++) {
        w[post[k]] = k;
      }
      for (i2 = 0; i2 < m; i2++) {
        for (k = n, p0 = tptr[i2], p1 = tptr[i2 + 1], p = p0; p < p1; p++) {
          k = Math.min(k, w[tindex[p]]);
        }
        w[next + i2] = w[head + k];
        w[head + k] = i2;
      }
    }
    for (i2 = 0; i2 < n; i2++) {
      w[ancestor + i2] = i2;
    }
    for (k = 0; k < n; k++) {
      j = post[k];
      if (parent[j] !== -1) {
        colcount[parent[j]]--;
      }
      for (J = ata ? w[head + k] : j; J !== -1; J = ata ? w[next + J] : -1) {
        for (p = tptr[J]; p < tptr[J + 1]; p++) {
          i2 = tindex[p];
          var r = csLeaf(i2, j, w, first, maxfirst, prevleaf, ancestor);
          if (r.jleaf >= 1) {
            colcount[j]++;
          }
          if (r.jleaf === 2) {
            colcount[r.q]--;
          }
        }
      }
      if (parent[j] !== -1) {
        w[ancestor + j] = parent[j];
      }
    }
    for (j = 0; j < n; j++) {
      if (parent[j] !== -1) {
        colcount[parent[j]] += colcount[j];
      }
    }
    return colcount;
  };
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csSqr.js
var name159 = "csSqr";
var dependencies159 = ["add", "multiply", "transpose"];
var createCsSqr = factory(name159, dependencies159, (_ref) => {
  var {
    add: add2,
    multiply: multiply2,
    transpose: transpose2
  } = _ref;
  var csAmd = createCsAmd({
    add: add2,
    multiply: multiply2,
    transpose: transpose2
  });
  var csCounts = createCsCounts({
    transpose: transpose2
  });
  return function csSqr(order, a, qr2) {
    var aptr = a._ptr;
    var asize = a._size;
    var n = asize[1];
    var k;
    var s = {};
    s.q = csAmd(order, a);
    if (order && !s.q) {
      return null;
    }
    if (qr2) {
      var c = order ? csPermute(a, null, s.q, 0) : a;
      s.parent = csEtree(c, 1);
      var post = csPost(s.parent, n);
      s.cp = csCounts(c, s.parent, post, 1);
      if (c && s.parent && s.cp && _vcount(c, s)) {
        for (s.unz = 0, k = 0; k < n; k++) {
          s.unz += s.cp[k];
        }
      }
    } else {
      s.unz = 4 * aptr[n] + n;
      s.lnz = s.unz;
    }
    return s;
  };
  function _vcount(a, s) {
    var aptr = a._ptr;
    var aindex = a._index;
    var asize = a._size;
    var m = asize[0];
    var n = asize[1];
    s.pinv = [];
    s.leftmost = [];
    var parent = s.parent;
    var pinv2 = s.pinv;
    var leftmost = s.leftmost;
    var w = [];
    var next = 0;
    var head = m;
    var tail = m + n;
    var nque = m + 2 * n;
    var i2, k, p, p0, p1;
    for (k = 0; k < n; k++) {
      w[head + k] = -1;
      w[tail + k] = -1;
      w[nque + k] = 0;
    }
    for (i2 = 0; i2 < m; i2++) {
      leftmost[i2] = -1;
    }
    for (k = n - 1; k >= 0; k--) {
      for (p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {
        leftmost[aindex[p]] = k;
      }
    }
    for (i2 = m - 1; i2 >= 0; i2--) {
      pinv2[i2] = -1;
      k = leftmost[i2];
      if (k === -1) {
        continue;
      }
      if (w[nque + k]++ === 0) {
        w[tail + k] = i2;
      }
      w[next + i2] = w[head + k];
      w[head + k] = i2;
    }
    s.lnz = 0;
    s.m2 = m;
    for (k = 0; k < n; k++) {
      i2 = w[head + k];
      s.lnz++;
      if (i2 < 0) {
        i2 = s.m2++;
      }
      pinv2[i2] = k;
      if (--nque[k] <= 0) {
        continue;
      }
      s.lnz += w[nque + k];
      var pa = parent[k];
      if (pa !== -1) {
        if (w[nque + pa] === 0) {
          w[tail + pa] = w[tail + k];
        }
        w[next + w[tail + k]] = w[head + pa];
        w[head + pa] = w[next + i2];
        w[nque + pa] += w[nque + k];
      }
    }
    for (i2 = 0; i2 < m; i2++) {
      if (pinv2[i2] < 0) {
        pinv2[i2] = k++;
      }
    }
    return true;
  }
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csMarked.js
function csMarked(w, j) {
  return w[j] < 0;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csMark.js
function csMark(w, j) {
  w[j] = csFlip(w[j]);
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csUnflip.js
function csUnflip(i2) {
  return i2 < 0 ? csFlip(i2) : i2;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csDfs.js
function csDfs(j, g, top, xi, pinv2) {
  var index2 = g._index;
  var ptr = g._ptr;
  var size2 = g._size;
  var n = size2[1];
  var i2, p, p2;
  var head = 0;
  xi[0] = j;
  while (head >= 0) {
    j = xi[head];
    var jnew = pinv2 ? pinv2[j] : j;
    if (!csMarked(ptr, j)) {
      csMark(ptr, j);
      xi[n + head] = jnew < 0 ? 0 : csUnflip(ptr[jnew]);
    }
    var done = 1;
    for (p = xi[n + head], p2 = jnew < 0 ? 0 : csUnflip(ptr[jnew + 1]); p < p2; p++) {
      i2 = index2[p];
      if (csMarked(ptr, i2)) {
        continue;
      }
      xi[n + head] = p;
      xi[++head] = i2;
      done = 0;
      break;
    }
    if (done) {
      head--;
      xi[--top] = j;
    }
  }
  return top;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csReach.js
function csReach(g, b, k, xi, pinv2) {
  var gptr = g._ptr;
  var gsize = g._size;
  var bindex = b._index;
  var bptr = b._ptr;
  var n = gsize[1];
  var p, p0, p1;
  var top = n;
  for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {
    var i2 = bindex[p];
    if (!csMarked(gptr, i2)) {
      top = csDfs(i2, g, top, xi, pinv2);
    }
  }
  for (p = top; p < n; p++) {
    csMark(gptr, xi[p]);
  }
  return top;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csSpsolve.js
var name160 = "csSpsolve";
var dependencies160 = ["divideScalar", "multiply", "subtract"];
var createCsSpsolve = factory(name160, dependencies160, (_ref) => {
  var {
    divideScalar: divideScalar2,
    multiply: multiply2,
    subtract: subtract2
  } = _ref;
  return function csSpsolve(g, b, k, xi, x, pinv2, lo) {
    var gvalues = g._values;
    var gindex = g._index;
    var gptr = g._ptr;
    var gsize = g._size;
    var n = gsize[1];
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var p, p0, p1, q;
    var top = csReach(g, b, k, xi, pinv2);
    for (p = top; p < n; p++) {
      x[xi[p]] = 0;
    }
    for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {
      x[bindex[p]] = bvalues[p];
    }
    for (var px = top; px < n; px++) {
      var j = xi[px];
      var J = pinv2 ? pinv2[j] : j;
      if (J < 0) {
        continue;
      }
      p0 = gptr[J];
      p1 = gptr[J + 1];
      x[j] = divideScalar2(x[j], gvalues[lo ? p0 : p1 - 1]);
      p = lo ? p0 + 1 : p0;
      q = lo ? p1 : p1 - 1;
      for (; p < q; p++) {
        var i2 = gindex[p];
        x[i2] = subtract2(x[i2], multiply2(gvalues[p], x[j]));
      }
    }
    return top;
  };
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csLu.js
var name161 = "csLu";
var dependencies161 = ["abs", "divideScalar", "multiply", "subtract", "larger", "largerEq", "SparseMatrix"];
var createCsLu = factory(name161, dependencies161, (_ref) => {
  var {
    abs: abs2,
    divideScalar: divideScalar2,
    multiply: multiply2,
    subtract: subtract2,
    larger: larger2,
    largerEq: largerEq2,
    SparseMatrix: SparseMatrix2
  } = _ref;
  var csSpsolve = createCsSpsolve({
    divideScalar: divideScalar2,
    multiply: multiply2,
    subtract: subtract2
  });
  return function csLu(m, s, tol) {
    if (!m) {
      return null;
    }
    var size2 = m._size;
    var n = size2[1];
    var q;
    var lnz = 100;
    var unz = 100;
    if (s) {
      q = s.q;
      lnz = s.lnz || lnz;
      unz = s.unz || unz;
    }
    var lvalues = [];
    var lindex = [];
    var lptr = [];
    var L = new SparseMatrix2({
      values: lvalues,
      index: lindex,
      ptr: lptr,
      size: [n, n]
    });
    var uvalues = [];
    var uindex = [];
    var uptr = [];
    var U = new SparseMatrix2({
      values: uvalues,
      index: uindex,
      ptr: uptr,
      size: [n, n]
    });
    var pinv2 = [];
    var i2, p;
    var x = [];
    var xi = [];
    for (i2 = 0; i2 < n; i2++) {
      x[i2] = 0;
      pinv2[i2] = -1;
      lptr[i2 + 1] = 0;
    }
    lnz = 0;
    unz = 0;
    for (var k = 0; k < n; k++) {
      lptr[k] = lnz;
      uptr[k] = unz;
      var col = q ? q[k] : k;
      var top = csSpsolve(L, m, col, xi, x, pinv2, 1);
      var ipiv = -1;
      var a = -1;
      for (p = top; p < n; p++) {
        i2 = xi[p];
        if (pinv2[i2] < 0) {
          var xabs = abs2(x[i2]);
          if (larger2(xabs, a)) {
            a = xabs;
            ipiv = i2;
          }
        } else {
          uindex[unz] = pinv2[i2];
          uvalues[unz++] = x[i2];
        }
      }
      if (ipiv === -1 || a <= 0) {
        return null;
      }
      if (pinv2[col] < 0 && largerEq2(abs2(x[col]), multiply2(a, tol))) {
        ipiv = col;
      }
      var pivot = x[ipiv];
      uindex[unz] = k;
      uvalues[unz++] = pivot;
      pinv2[ipiv] = k;
      lindex[lnz] = ipiv;
      lvalues[lnz++] = 1;
      for (p = top; p < n; p++) {
        i2 = xi[p];
        if (pinv2[i2] < 0) {
          lindex[lnz] = i2;
          lvalues[lnz++] = divideScalar2(x[i2], pivot);
        }
        x[i2] = 0;
      }
    }
    lptr[n] = lnz;
    uptr[n] = unz;
    for (p = 0; p < lnz; p++) {
      lindex[p] = pinv2[lindex[p]];
    }
    lvalues.splice(lnz, lvalues.length - lnz);
    lindex.splice(lnz, lindex.length - lnz);
    uvalues.splice(unz, uvalues.length - unz);
    uindex.splice(unz, uindex.length - unz);
    return {
      L,
      U,
      pinv: pinv2
    };
  };
});

// node_modules/mathjs/lib/esm/function/algebra/decomposition/slu.js
var name162 = "slu";
var dependencies162 = ["typed", "abs", "add", "multiply", "transpose", "divideScalar", "subtract", "larger", "largerEq", "SparseMatrix"];
var createSlu = factory(name162, dependencies162, (_ref) => {
  var {
    typed: typed2,
    abs: abs2,
    add: add2,
    multiply: multiply2,
    transpose: transpose2,
    divideScalar: divideScalar2,
    subtract: subtract2,
    larger: larger2,
    largerEq: largerEq2,
    SparseMatrix: SparseMatrix2
  } = _ref;
  var csSqr = createCsSqr({
    add: add2,
    multiply: multiply2,
    transpose: transpose2
  });
  var csLu = createCsLu({
    abs: abs2,
    divideScalar: divideScalar2,
    multiply: multiply2,
    subtract: subtract2,
    larger: larger2,
    largerEq: largerEq2,
    SparseMatrix: SparseMatrix2
  });
  return typed2(name162, {
    "SparseMatrix, number, number": function SparseMatrix_number_number(a, order, threshold) {
      if (!isInteger(order) || order < 0 || order > 3) {
        throw new Error("Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]");
      }
      if (threshold < 0 || threshold > 1) {
        throw new Error("Partial pivoting threshold must be a number from 0 to 1");
      }
      var s = csSqr(order, a, false);
      var f = csLu(a, s, threshold);
      return {
        L: f.L,
        U: f.U,
        p: f.pinv,
        q: s.q,
        toString: function toString() {
          return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\np: " + this.p.toString() + (this.q ? "\nq: " + this.q.toString() : "") + "\n";
        }
      };
    }
  });
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csIpvec.js
function csIpvec(p, b) {
  var k;
  var n = b.length;
  var x = [];
  if (p) {
    for (k = 0; k < n; k++) {
      x[p[k]] = b[k];
    }
  } else {
    for (k = 0; k < n; k++) {
      x[k] = b[k];
    }
  }
  return x;
}

// node_modules/mathjs/lib/esm/function/algebra/solver/lusolve.js
var name163 = "lusolve";
var dependencies163 = ["typed", "matrix", "lup", "slu", "usolve", "lsolve", "DenseMatrix"];
var createLusolve = factory(name163, dependencies163, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    lup: lup2,
    slu: slu2,
    usolve: usolve2,
    lsolve: lsolve2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix: DenseMatrix2
  });
  return typed2(name163, {
    "Array, Array | Matrix": function Array_Array__Matrix(a, b) {
      a = matrix2(a);
      var d = lup2(a);
      var x = _lusolve(d.L, d.U, d.p, null, b);
      return x.valueOf();
    },
    "DenseMatrix, Array | Matrix": function DenseMatrix_Array__Matrix(a, b) {
      var d = lup2(a);
      return _lusolve(d.L, d.U, d.p, null, b);
    },
    "SparseMatrix, Array | Matrix": function SparseMatrix_Array__Matrix(a, b) {
      var d = lup2(a);
      return _lusolve(d.L, d.U, d.p, null, b);
    },
    "SparseMatrix, Array | Matrix, number, number": function SparseMatrix_Array__Matrix_number_number(a, b, order, threshold) {
      var d = slu2(a, order, threshold);
      return _lusolve(d.L, d.U, d.p, d.q, b);
    },
    "Object, Array | Matrix": function Object_Array__Matrix(d, b) {
      return _lusolve(d.L, d.U, d.p, d.q, b);
    }
  });
  function _toMatrix(a) {
    if (isMatrix(a)) {
      return a;
    }
    if (isArray(a)) {
      return matrix2(a);
    }
    throw new TypeError("Invalid Matrix LU decomposition");
  }
  function _lusolve(l, u, p, q, b) {
    l = _toMatrix(l);
    u = _toMatrix(u);
    if (p) {
      b = solveValidation(l, b, true);
      b._data = csIpvec(p, b._data);
    }
    var y = lsolve2(l, b);
    var x = usolve2(u, y);
    if (q) {
      x._data = csIpvec(q, x._data);
    }
    return x;
  }
});

// node_modules/mathjs/lib/esm/function/algebra/polynomialRoot.js
var name164 = "polynomialRoot";
var dependencies164 = ["typed", "isZero", "equalScalar", "add", "subtract", "multiply", "divide", "sqrt", "unaryMinus", "cbrt", "typeOf", "im", "re"];
var createPolynomialRoot = factory(name164, dependencies164, (_ref) => {
  var {
    typed: typed2,
    isZero: isZero2,
    equalScalar: equalScalar2,
    add: add2,
    subtract: subtract2,
    multiply: multiply2,
    divide: divide2,
    sqrt: sqrt2,
    unaryMinus: unaryMinus2,
    cbrt: cbrt2,
    typeOf: typeOf3,
    im: im2,
    re: re2
  } = _ref;
  return typed2(name164, {
    "number|Complex, ...number|Complex": (constant, restCoeffs) => {
      var coeffs = [constant, ...restCoeffs];
      while (coeffs.length > 0 && isZero2(coeffs[coeffs.length - 1])) {
        coeffs.pop();
      }
      if (coeffs.length < 2) {
        throw new RangeError("Polynomial [".concat(constant, ", ").concat(restCoeffs, "] must have a non-zero non-constant coefficient"));
      }
      switch (coeffs.length) {
        case 2:
          return [unaryMinus2(divide2(coeffs[0], coeffs[1]))];
        case 3: {
          var [c, b, a] = coeffs;
          var denom = multiply2(2, a);
          var d1 = multiply2(b, b);
          var d2 = multiply2(4, a, c);
          if (equalScalar2(d1, d2)) return [divide2(unaryMinus2(b), denom)];
          var discriminant = sqrt2(subtract2(d1, d2));
          return [divide2(subtract2(discriminant, b), denom), divide2(subtract2(unaryMinus2(discriminant), b), denom)];
        }
        case 4: {
          var [d, _c, _b, _a] = coeffs;
          var _denom = unaryMinus2(multiply2(3, _a));
          var D0_1 = multiply2(_b, _b);
          var D0_2 = multiply2(3, _a, _c);
          var D1_1 = add2(multiply2(2, _b, _b, _b), multiply2(27, _a, _a, d));
          var D1_2 = multiply2(9, _a, _b, _c);
          if (equalScalar2(D0_1, D0_2) && equalScalar2(D1_1, D1_2)) {
            return [divide2(_b, _denom)];
          }
          var Delta0 = subtract2(D0_1, D0_2);
          var Delta1 = subtract2(D1_1, D1_2);
          var discriminant1 = add2(multiply2(18, _a, _b, _c, d), multiply2(_b, _b, _c, _c));
          var discriminant2 = add2(multiply2(4, _b, _b, _b, d), multiply2(4, _a, _c, _c, _c), multiply2(27, _a, _a, d, d));
          if (equalScalar2(discriminant1, discriminant2)) {
            return [
              divide2(subtract2(multiply2(4, _a, _b, _c), add2(multiply2(9, _a, _a, d), multiply2(_b, _b, _b))), multiply2(_a, Delta0)),
              // simple root
              divide2(subtract2(multiply2(9, _a, d), multiply2(_b, _c)), multiply2(2, Delta0))
              // double root
            ];
          }
          var Ccubed;
          if (equalScalar2(D0_1, D0_2)) {
            Ccubed = Delta1;
          } else {
            Ccubed = divide2(add2(Delta1, sqrt2(subtract2(multiply2(Delta1, Delta1), multiply2(4, Delta0, Delta0, Delta0)))), 2);
          }
          var allRoots = true;
          var rawRoots = cbrt2(Ccubed, allRoots).toArray().map((C) => divide2(add2(_b, C, divide2(Delta0, C)), _denom));
          return rawRoots.map((r) => {
            if (typeOf3(r) === "Complex" && equalScalar2(re2(r), re2(r) + im2(r))) {
              return re2(r);
            }
            return r;
          });
        }
        default:
          throw new RangeError("only implemented for cubic or lower-order polynomials, not ".concat(coeffs));
      }
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/det.js
var name165 = "det";
var dependencies165 = ["typed", "matrix", "subtractScalar", "multiply", "divideScalar", "isZero", "unaryMinus"];
var createDet = factory(name165, dependencies165, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    subtractScalar: subtractScalar2,
    multiply: multiply2,
    divideScalar: divideScalar2,
    isZero: isZero2,
    unaryMinus: unaryMinus2
  } = _ref;
  return typed2(name165, {
    any: function any(x) {
      return clone(x);
    },
    "Array | Matrix": function det2(x) {
      var size2;
      if (isMatrix(x)) {
        size2 = x.size();
      } else if (Array.isArray(x)) {
        x = matrix2(x);
        size2 = x.size();
      } else {
        size2 = [];
      }
      switch (size2.length) {
        case 0:
          return clone(x);
        case 1:
          if (size2[0] === 1) {
            return clone(x.valueOf()[0]);
          }
          if (size2[0] === 0) {
            return 1;
          } else {
            throw new RangeError("Matrix must be square (size: " + format2(size2) + ")");
          }
        case 2: {
          var rows = size2[0];
          var cols = size2[1];
          if (rows === cols) {
            return _det(x.clone().valueOf(), rows, cols);
          }
          if (cols === 0) {
            return 1;
          } else {
            throw new RangeError("Matrix must be square (size: " + format2(size2) + ")");
          }
        }
        default:
          throw new RangeError("Matrix must be two dimensional (size: " + format2(size2) + ")");
      }
    }
  });
  function _det(matrix3, rows, cols) {
    if (rows === 1) {
      return clone(matrix3[0][0]);
    } else if (rows === 2) {
      return subtractScalar2(multiply2(matrix3[0][0], matrix3[1][1]), multiply2(matrix3[1][0], matrix3[0][1]));
    } else {
      var negated = false;
      var rowIndices = new Array(rows).fill(0).map((_, i3) => i3);
      for (var k = 0; k < rows; k++) {
        var k_ = rowIndices[k];
        if (isZero2(matrix3[k_][k])) {
          var _k = void 0;
          for (_k = k + 1; _k < rows; _k++) {
            if (!isZero2(matrix3[rowIndices[_k]][k])) {
              k_ = rowIndices[_k];
              rowIndices[_k] = rowIndices[k];
              rowIndices[k] = k_;
              negated = !negated;
              break;
            }
          }
          if (_k === rows) return matrix3[k_][k];
        }
        var piv = matrix3[k_][k];
        var piv_ = k === 0 ? 1 : matrix3[rowIndices[k - 1]][k - 1];
        for (var i2 = k + 1; i2 < rows; i2++) {
          var i_ = rowIndices[i2];
          for (var j = k + 1; j < rows; j++) {
            matrix3[i_][j] = divideScalar2(subtractScalar2(multiply2(matrix3[i_][j], piv), multiply2(matrix3[i_][k], matrix3[k_][j])), piv_);
          }
        }
      }
      var det2 = matrix3[rowIndices[rows - 1]][rows - 1];
      return negated ? unaryMinus2(det2) : det2;
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/inv.js
var name166 = "inv";
var dependencies166 = ["typed", "matrix", "divideScalar", "addScalar", "multiply", "unaryMinus", "det", "identity", "abs"];
var createInv = factory(name166, dependencies166, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    divideScalar: divideScalar2,
    addScalar: addScalar2,
    multiply: multiply2,
    unaryMinus: unaryMinus2,
    det: det2,
    identity: identity2,
    abs: abs2
  } = _ref;
  return typed2(name166, {
    "Array | Matrix": function Array__Matrix(x) {
      var size2 = isMatrix(x) ? x.size() : arraySize(x);
      switch (size2.length) {
        case 1:
          if (size2[0] === 1) {
            if (isMatrix(x)) {
              return matrix2([divideScalar2(1, x.valueOf()[0])]);
            } else {
              return [divideScalar2(1, x[0])];
            }
          } else {
            throw new RangeError("Matrix must be square (size: " + format2(size2) + ")");
          }
        case 2: {
          var rows = size2[0];
          var cols = size2[1];
          if (rows === cols) {
            if (isMatrix(x)) {
              return matrix2(_inv(x.valueOf(), rows, cols), x.storage());
            } else {
              return _inv(x, rows, cols);
            }
          } else {
            throw new RangeError("Matrix must be square (size: " + format2(size2) + ")");
          }
        }
        default:
          throw new RangeError("Matrix must be two dimensional (size: " + format2(size2) + ")");
      }
    },
    any: function any(x) {
      return divideScalar2(1, x);
    }
  });
  function _inv(mat, rows, cols) {
    var r, s, f, value, temp;
    if (rows === 1) {
      value = mat[0][0];
      if (value === 0) {
        throw Error("Cannot calculate inverse, determinant is zero");
      }
      return [[divideScalar2(1, value)]];
    } else if (rows === 2) {
      var d = det2(mat);
      if (d === 0) {
        throw Error("Cannot calculate inverse, determinant is zero");
      }
      return [[divideScalar2(mat[1][1], d), divideScalar2(unaryMinus2(mat[0][1]), d)], [divideScalar2(unaryMinus2(mat[1][0]), d), divideScalar2(mat[0][0], d)]];
    } else {
      var A = mat.concat();
      for (r = 0; r < rows; r++) {
        A[r] = A[r].concat();
      }
      var B = identity2(rows).valueOf();
      for (var c = 0; c < cols; c++) {
        var ABig = abs2(A[c][c]);
        var rBig = c;
        r = c + 1;
        while (r < rows) {
          if (abs2(A[r][c]) > ABig) {
            ABig = abs2(A[r][c]);
            rBig = r;
          }
          r++;
        }
        if (ABig === 0) {
          throw Error("Cannot calculate inverse, determinant is zero");
        }
        r = rBig;
        if (r !== c) {
          temp = A[c];
          A[c] = A[r];
          A[r] = temp;
          temp = B[c];
          B[c] = B[r];
          B[r] = temp;
        }
        var Ac = A[c];
        var Bc = B[c];
        for (r = 0; r < rows; r++) {
          var Ar = A[r];
          var Br = B[r];
          if (r !== c) {
            if (Ar[c] !== 0) {
              f = divideScalar2(unaryMinus2(Ar[c]), Ac[c]);
              for (s = c; s < cols; s++) {
                Ar[s] = addScalar2(Ar[s], multiply2(f, Ac[s]));
              }
              for (s = 0; s < cols; s++) {
                Br[s] = addScalar2(Br[s], multiply2(f, Bc[s]));
              }
            }
          } else {
            f = Ac[c];
            for (s = c; s < cols; s++) {
              Ar[s] = divideScalar2(Ar[s], f);
            }
            for (s = 0; s < cols; s++) {
              Br[s] = divideScalar2(Br[s], f);
            }
          }
        }
      }
      return B;
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/pinv.js
var name167 = "pinv";
var dependencies167 = ["typed", "matrix", "inv", "deepEqual", "equal", "dotDivide", "dot", "ctranspose", "divideScalar", "multiply", "add", "Complex"];
var createPinv = factory(name167, dependencies167, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    inv: inv2,
    deepEqual: deepEqual2,
    equal: equal2,
    dotDivide: dotDivide2,
    dot: dot2,
    ctranspose: ctranspose2,
    divideScalar: divideScalar2,
    multiply: multiply2,
    add: add2,
    Complex: Complex3
  } = _ref;
  return typed2(name167, {
    "Array | Matrix": function Array__Matrix(x) {
      var size2 = isMatrix(x) ? x.size() : arraySize(x);
      switch (size2.length) {
        case 1:
          if (_isZeros(x)) return ctranspose2(x);
          if (size2[0] === 1) {
            return inv2(x);
          } else {
            return dotDivide2(ctranspose2(x), dot2(x, x));
          }
        case 2: {
          if (_isZeros(x)) return ctranspose2(x);
          var rows = size2[0];
          var cols = size2[1];
          if (rows === cols) {
            try {
              return inv2(x);
            } catch (err) {
              if (err instanceof Error && err.message.match(/Cannot calculate inverse, determinant is zero/)) {
              } else {
                throw err;
              }
            }
          }
          if (isMatrix(x)) {
            return matrix2(_pinv(x.valueOf(), rows, cols), x.storage());
          } else {
            return _pinv(x, rows, cols);
          }
        }
        default:
          throw new RangeError("Matrix must be two dimensional (size: " + format2(size2) + ")");
      }
    },
    any: function any(x) {
      if (equal2(x, 0)) return clone(x);
      return divideScalar2(1, x);
    }
  });
  function _pinv(mat, rows, cols) {
    var {
      C,
      F
    } = _rankFact(mat, rows, cols);
    var Cpinv = multiply2(inv2(multiply2(ctranspose2(C), C)), ctranspose2(C));
    var Fpinv = multiply2(ctranspose2(F), inv2(multiply2(F, ctranspose2(F))));
    return multiply2(Fpinv, Cpinv);
  }
  function _rref(mat, rows, cols) {
    var M = clone(mat);
    var lead = 0;
    for (var r = 0; r < rows; r++) {
      if (cols <= lead) {
        return M;
      }
      var i2 = r;
      while (_isZero(M[i2][lead])) {
        i2++;
        if (rows === i2) {
          i2 = r;
          lead++;
          if (cols === lead) {
            return M;
          }
        }
      }
      [M[i2], M[r]] = [M[r], M[i2]];
      var val = M[r][lead];
      for (var j = 0; j < cols; j++) {
        M[r][j] = dotDivide2(M[r][j], val);
      }
      for (var _i = 0; _i < rows; _i++) {
        if (_i === r) continue;
        val = M[_i][lead];
        for (var _j = 0; _j < cols; _j++) {
          M[_i][_j] = add2(M[_i][_j], multiply2(-1, multiply2(val, M[r][_j])));
        }
      }
      lead++;
    }
    return M;
  }
  function _rankFact(mat, rows, cols) {
    var rref = _rref(mat, rows, cols);
    var C = mat.map((_, i2) => _.filter((_2, j) => j < rows && !_isZero(dot2(rref[j], rref[j]))));
    var F = rref.filter((_, i2) => !_isZero(dot2(rref[i2], rref[i2])));
    return {
      C,
      F
    };
  }
  function _isZero(x) {
    return equal2(add2(x, Complex3(1, 1)), add2(0, Complex3(1, 1)));
  }
  function _isZeros(arr) {
    return deepEqual2(add2(arr, Complex3(1, 1)), add2(multiply2(arr, 0), Complex3(1, 1)));
  }
});

// node_modules/mathjs/lib/esm/function/matrix/eigs/complexEigs.js
function createComplexEigs(_ref) {
  var {
    addScalar: addScalar2,
    subtract: subtract2,
    flatten: flatten3,
    multiply: multiply2,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    sqrt: sqrt2,
    abs: abs2,
    bignumber: bignumber2,
    diag: diag2,
    size: size2,
    reshape: reshape3,
    inv: inv2,
    qr: qr2,
    usolve: usolve2,
    usolveAll: usolveAll2,
    equal: equal2,
    complex: complex2,
    larger: larger2,
    smaller: smaller2,
    matrixFromColumns: matrixFromColumns2,
    dot: dot2
  } = _ref;
  function complexEigs(arr, N, prec, type) {
    var findVectors = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
    var R = balance(arr, N, prec, type, findVectors);
    reduceToHessenberg(arr, N, prec, type, findVectors, R);
    var {
      values,
      C
    } = iterateUntilTriangular(arr, N, prec, type, findVectors);
    if (findVectors) {
      var eigenvectors = findEigenvectors(arr, N, C, R, values, prec, type);
      return {
        values,
        eigenvectors
      };
    }
    return {
      values
    };
  }
  function balance(arr, N, prec, type, findVectors) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var realzero = big ? bignumber2(0) : 0;
    var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
    var realone = big ? bignumber2(1) : 1;
    var radix = big ? bignumber2(10) : 2;
    var radixSq = multiplyScalar2(radix, radix);
    var Rdiag;
    if (findVectors) {
      Rdiag = Array(N).fill(one);
    }
    var last = false;
    while (!last) {
      last = true;
      for (var i2 = 0; i2 < N; i2++) {
        var colNorm = realzero;
        var rowNorm = realzero;
        for (var j = 0; j < N; j++) {
          if (i2 === j) continue;
          colNorm = addScalar2(colNorm, abs2(arr[j][i2]));
          rowNorm = addScalar2(rowNorm, abs2(arr[i2][j]));
        }
        if (!equal2(colNorm, 0) && !equal2(rowNorm, 0)) {
          var f = realone;
          var c = colNorm;
          var rowDivRadix = divideScalar2(rowNorm, radix);
          var rowMulRadix = multiplyScalar2(rowNorm, radix);
          while (smaller2(c, rowDivRadix)) {
            c = multiplyScalar2(c, radixSq);
            f = multiplyScalar2(f, radix);
          }
          while (larger2(c, rowMulRadix)) {
            c = divideScalar2(c, radixSq);
            f = divideScalar2(f, radix);
          }
          var condition = smaller2(divideScalar2(addScalar2(c, rowNorm), f), multiplyScalar2(addScalar2(colNorm, rowNorm), 0.95));
          if (condition) {
            last = false;
            var g = divideScalar2(1, f);
            for (var _j = 0; _j < N; _j++) {
              if (i2 === _j) {
                continue;
              }
              arr[i2][_j] = multiplyScalar2(arr[i2][_j], g);
              arr[_j][i2] = multiplyScalar2(arr[_j][i2], f);
            }
            if (findVectors) {
              Rdiag[i2] = multiplyScalar2(Rdiag[i2], g);
            }
          }
        }
      }
    }
    return findVectors ? diag2(Rdiag) : null;
  }
  function reduceToHessenberg(arr, N, prec, type, findVectors, R) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var zero = big ? bignumber2(0) : cplx ? complex2(0) : 0;
    if (big) {
      prec = bignumber2(prec);
    }
    for (var i2 = 0; i2 < N - 2; i2++) {
      var maxIndex = 0;
      var max2 = zero;
      for (var j = i2 + 1; j < N; j++) {
        var el = arr[j][i2];
        if (smaller2(abs2(max2), abs2(el))) {
          max2 = el;
          maxIndex = j;
        }
      }
      if (smaller2(abs2(max2), prec)) {
        continue;
      }
      if (maxIndex !== i2 + 1) {
        var tmp1 = arr[maxIndex];
        arr[maxIndex] = arr[i2 + 1];
        arr[i2 + 1] = tmp1;
        for (var _j2 = 0; _j2 < N; _j2++) {
          var tmp2 = arr[_j2][maxIndex];
          arr[_j2][maxIndex] = arr[_j2][i2 + 1];
          arr[_j2][i2 + 1] = tmp2;
        }
        if (findVectors) {
          var tmp3 = R[maxIndex];
          R[maxIndex] = R[i2 + 1];
          R[i2 + 1] = tmp3;
        }
      }
      for (var _j3 = i2 + 2; _j3 < N; _j3++) {
        var n = divideScalar2(arr[_j3][i2], max2);
        if (n === 0) {
          continue;
        }
        for (var k = 0; k < N; k++) {
          arr[_j3][k] = subtract2(arr[_j3][k], multiplyScalar2(n, arr[i2 + 1][k]));
        }
        for (var _k = 0; _k < N; _k++) {
          arr[_k][i2 + 1] = addScalar2(arr[_k][i2 + 1], multiplyScalar2(n, arr[_k][_j3]));
        }
        if (findVectors) {
          for (var _k2 = 0; _k2 < N; _k2++) {
            R[_j3][_k2] = subtract2(R[_j3][_k2], multiplyScalar2(n, R[i2 + 1][_k2]));
          }
        }
      }
    }
    return R;
  }
  function iterateUntilTriangular(A, N, prec, type, findVectors) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
    if (big) {
      prec = bignumber2(prec);
    }
    var arr = clone(A);
    var lambdas = [];
    var n = N;
    var Sdiag = [];
    var Qtotal = findVectors ? diag2(Array(N).fill(one)) : void 0;
    var Qpartial = findVectors ? diag2(Array(n).fill(one)) : void 0;
    var lastConvergenceBefore = 0;
    while (lastConvergenceBefore <= 100) {
      lastConvergenceBefore += 1;
      var k = arr[n - 1][n - 1];
      for (var i2 = 0; i2 < n; i2++) {
        arr[i2][i2] = subtract2(arr[i2][i2], k);
      }
      var {
        Q,
        R
      } = qr2(arr);
      arr = multiply2(R, Q);
      for (var _i = 0; _i < n; _i++) {
        arr[_i][_i] = addScalar2(arr[_i][_i], k);
      }
      if (findVectors) {
        Qpartial = multiply2(Qpartial, Q);
      }
      if (n === 1 || smaller2(abs2(arr[n - 1][n - 2]), prec)) {
        lastConvergenceBefore = 0;
        lambdas.push(arr[n - 1][n - 1]);
        if (findVectors) {
          Sdiag.unshift([[1]]);
          inflateMatrix(Qpartial, N);
          Qtotal = multiply2(Qtotal, Qpartial);
          if (n > 1) {
            Qpartial = diag2(Array(n - 1).fill(one));
          }
        }
        n -= 1;
        arr.pop();
        for (var _i2 = 0; _i2 < n; _i2++) {
          arr[_i2].pop();
        }
      } else if (n === 2 || smaller2(abs2(arr[n - 2][n - 3]), prec)) {
        lastConvergenceBefore = 0;
        var ll = eigenvalues2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1]);
        lambdas.push(...ll);
        if (findVectors) {
          Sdiag.unshift(jordanBase2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1], ll[0], ll[1], prec, type));
          inflateMatrix(Qpartial, N);
          Qtotal = multiply2(Qtotal, Qpartial);
          if (n > 2) {
            Qpartial = diag2(Array(n - 2).fill(one));
          }
        }
        n -= 2;
        arr.pop();
        arr.pop();
        for (var _i3 = 0; _i3 < n; _i3++) {
          arr[_i3].pop();
          arr[_i3].pop();
        }
      }
      if (n === 0) {
        break;
      }
    }
    lambdas.sort((a, b) => +subtract2(abs2(a), abs2(b)));
    if (lastConvergenceBefore > 100) {
      var err = Error("The eigenvalues failed to converge. Only found these eigenvalues: " + lambdas.join(", "));
      err.values = lambdas;
      err.vectors = [];
      throw err;
    }
    var C = findVectors ? multiply2(Qtotal, blockDiag(Sdiag, N)) : void 0;
    return {
      values: lambdas,
      C
    };
  }
  function findEigenvectors(A, N, C, R, values, prec, type) {
    var Cinv = inv2(C);
    var U = multiply2(Cinv, A, C);
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var zero = big ? bignumber2(0) : cplx ? complex2(0) : 0;
    var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
    var uniqueValues = [];
    var multiplicities = [];
    for (var lambda of values) {
      var i2 = indexOf(uniqueValues, lambda, equal2);
      if (i2 === -1) {
        uniqueValues.push(lambda);
        multiplicities.push(1);
      } else {
        multiplicities[i2] += 1;
      }
    }
    var vectors = [];
    var len = uniqueValues.length;
    var b = Array(N).fill(zero);
    var E = diag2(Array(N).fill(one));
    var _loop = function _loop2() {
      var lambda2 = uniqueValues[_i4];
      var S = subtract2(U, multiply2(lambda2, E));
      var solutions = usolveAll2(S, b);
      solutions.shift();
      while (solutions.length < multiplicities[_i4]) {
        var approxVec = inverseIterate(S, N, solutions, prec, type);
        if (approxVec === null) {
          break;
        }
        solutions.push(approxVec);
      }
      var correction = multiply2(inv2(R), C);
      solutions = solutions.map((v) => multiply2(correction, v));
      vectors.push(...solutions.map((v) => ({
        value: lambda2,
        vector: flatten3(v)
      })));
    };
    for (var _i4 = 0; _i4 < len; _i4++) {
      _loop();
    }
    return vectors;
  }
  function eigenvalues2x2(a, b, c, d) {
    var trA = addScalar2(a, d);
    var detA = subtract2(multiplyScalar2(a, d), multiplyScalar2(b, c));
    var x = multiplyScalar2(trA, 0.5);
    var y = multiplyScalar2(sqrt2(subtract2(multiplyScalar2(trA, trA), multiplyScalar2(4, detA))), 0.5);
    return [addScalar2(x, y), subtract2(x, y)];
  }
  function jordanBase2x2(a, b, c, d, l1, l2, prec, type) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var zero = big ? bignumber2(0) : cplx ? complex2(0) : 0;
    var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
    if (smaller2(abs2(c), prec)) {
      return [[one, zero], [zero, one]];
    }
    if (larger2(abs2(subtract2(l1, l2)), prec)) {
      return [[subtract2(l1, d), subtract2(l2, d)], [c, c]];
    }
    var na = subtract2(a, l1);
    var nd = subtract2(d, l1);
    if (smaller2(abs2(b), prec) && smaller2(abs2(nd), prec)) {
      return [[na, one], [c, zero]];
    } else {
      return [[b, zero], [nd, one]];
    }
  }
  function inflateMatrix(arr, N) {
    for (var i2 = 0; i2 < arr.length; i2++) {
      arr[i2].push(...Array(N - arr[i2].length).fill(0));
    }
    for (var _i5 = arr.length; _i5 < N; _i5++) {
      arr.push(Array(N).fill(0));
      arr[_i5][_i5] = 1;
    }
    return arr;
  }
  function blockDiag(arr, N) {
    var M = [];
    for (var i2 = 0; i2 < N; i2++) {
      M[i2] = Array(N).fill(0);
    }
    var I = 0;
    for (var sub of arr) {
      var n = sub.length;
      for (var _i6 = 0; _i6 < n; _i6++) {
        for (var j = 0; j < n; j++) {
          M[I + _i6][I + j] = sub[_i6][j];
        }
      }
      I += n;
    }
    return M;
  }
  function indexOf(arr, el, fn) {
    for (var i2 = 0; i2 < arr.length; i2++) {
      if (fn(arr[i2], el)) {
        return i2;
      }
    }
    return -1;
  }
  function inverseIterate(A, N, orthog, prec, type) {
    var largeNum = type === "BigNumber" ? bignumber2(1e3) : 1e3;
    var b;
    var i2 = 0;
    for (; i2 < 5; ++i2) {
      b = randomOrthogonalVector(N, orthog, type);
      try {
        b = usolve2(A, b);
      } catch (_unused) {
        continue;
      }
      if (larger2(norm2(b), largeNum)) {
        break;
      }
    }
    if (i2 >= 5) {
      return null;
    }
    i2 = 0;
    while (true) {
      var c = usolve2(A, b);
      if (smaller2(norm2(orthogonalComplement(b, [c])), prec)) {
        break;
      }
      if (++i2 >= 10) {
        return null;
      }
      b = normalize(c);
    }
    return b;
  }
  function randomOrthogonalVector(N, orthog, type) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var v = Array(N).fill(0).map((_) => 2 * Math.random() - 1);
    if (big) {
      v = v.map((n) => bignumber2(n));
    }
    if (cplx) {
      v = v.map((n) => complex2(n));
    }
    v = orthogonalComplement(v, orthog);
    return normalize(v, type);
  }
  function orthogonalComplement(v, orthog) {
    var vectorShape = size2(v);
    for (var w of orthog) {
      w = reshape3(w, vectorShape);
      v = subtract2(v, multiply2(divideScalar2(dot2(w, v), dot2(w, w)), w));
    }
    return v;
  }
  function norm2(v) {
    return abs2(sqrt2(dot2(v, v)));
  }
  function normalize(v, type) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
    return multiply2(divideScalar2(one, norm2(v)), v);
  }
  return complexEigs;
}

// node_modules/mathjs/lib/esm/function/matrix/eigs/realSymmetric.js
function createRealSymmetric(_ref) {
  var {
    config: config2,
    addScalar: addScalar2,
    subtract: subtract2,
    abs: abs2,
    atan: atan3,
    cos: cos2,
    sin: sin2,
    multiplyScalar: multiplyScalar2,
    inv: inv2,
    bignumber: bignumber2,
    multiply: multiply2,
    add: add2
  } = _ref;
  function main(arr, N) {
    var prec = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : config2.relTol;
    var type = arguments.length > 3 ? arguments[3] : void 0;
    var computeVectors = arguments.length > 4 ? arguments[4] : void 0;
    if (type === "number") {
      return diag2(arr, prec, computeVectors);
    }
    if (type === "BigNumber") {
      return diagBig(arr, prec, computeVectors);
    }
    throw TypeError("Unsupported data type: " + type);
  }
  function diag2(x, precision, computeVectors) {
    var N = x.length;
    var e0 = Math.abs(precision / N);
    var psi;
    var Sij;
    if (computeVectors) {
      Sij = new Array(N);
      for (var i2 = 0; i2 < N; i2++) {
        Sij[i2] = Array(N).fill(0);
        Sij[i2][i2] = 1;
      }
    }
    var Vab = getAij(x);
    while (Math.abs(Vab[1]) >= Math.abs(e0)) {
      var _i = Vab[0][0];
      var j = Vab[0][1];
      psi = getTheta(x[_i][_i], x[j][j], x[_i][j]);
      x = x1(x, psi, _i, j);
      if (computeVectors) Sij = Sij1(Sij, psi, _i, j);
      Vab = getAij(x);
    }
    var Ei = Array(N).fill(0);
    for (var _i2 = 0; _i2 < N; _i2++) {
      Ei[_i2] = x[_i2][_i2];
    }
    return sorting(clone(Ei), Sij, computeVectors);
  }
  function diagBig(x, precision, computeVectors) {
    var N = x.length;
    var e0 = abs2(precision / N);
    var psi;
    var Sij;
    if (computeVectors) {
      Sij = new Array(N);
      for (var i2 = 0; i2 < N; i2++) {
        Sij[i2] = Array(N).fill(0);
        Sij[i2][i2] = 1;
      }
    }
    var Vab = getAijBig(x);
    while (abs2(Vab[1]) >= abs2(e0)) {
      var _i3 = Vab[0][0];
      var j = Vab[0][1];
      psi = getThetaBig(x[_i3][_i3], x[j][j], x[_i3][j]);
      x = x1Big(x, psi, _i3, j);
      if (computeVectors) Sij = Sij1Big(Sij, psi, _i3, j);
      Vab = getAijBig(x);
    }
    var Ei = Array(N).fill(0);
    for (var _i4 = 0; _i4 < N; _i4++) {
      Ei[_i4] = x[_i4][_i4];
    }
    return sorting(clone(Ei), Sij, computeVectors);
  }
  function getTheta(aii, ajj, aij) {
    var denom = ajj - aii;
    if (Math.abs(denom) <= config2.relTol) {
      return Math.PI / 4;
    } else {
      return 0.5 * Math.atan(2 * aij / (ajj - aii));
    }
  }
  function getThetaBig(aii, ajj, aij) {
    var denom = subtract2(ajj, aii);
    if (abs2(denom) <= config2.relTol) {
      return bignumber2(-1).acos().div(4);
    } else {
      return multiplyScalar2(0.5, atan3(multiply2(2, aij, inv2(denom))));
    }
  }
  function Sij1(Sij, theta, i2, j) {
    var N = Sij.length;
    var c = Math.cos(theta);
    var s = Math.sin(theta);
    var Ski = Array(N).fill(0);
    var Skj = Array(N).fill(0);
    for (var k = 0; k < N; k++) {
      Ski[k] = c * Sij[k][i2] - s * Sij[k][j];
      Skj[k] = s * Sij[k][i2] + c * Sij[k][j];
    }
    for (var _k = 0; _k < N; _k++) {
      Sij[_k][i2] = Ski[_k];
      Sij[_k][j] = Skj[_k];
    }
    return Sij;
  }
  function Sij1Big(Sij, theta, i2, j) {
    var N = Sij.length;
    var c = cos2(theta);
    var s = sin2(theta);
    var Ski = Array(N).fill(bignumber2(0));
    var Skj = Array(N).fill(bignumber2(0));
    for (var k = 0; k < N; k++) {
      Ski[k] = subtract2(multiplyScalar2(c, Sij[k][i2]), multiplyScalar2(s, Sij[k][j]));
      Skj[k] = addScalar2(multiplyScalar2(s, Sij[k][i2]), multiplyScalar2(c, Sij[k][j]));
    }
    for (var _k2 = 0; _k2 < N; _k2++) {
      Sij[_k2][i2] = Ski[_k2];
      Sij[_k2][j] = Skj[_k2];
    }
    return Sij;
  }
  function x1Big(Hij, theta, i2, j) {
    var N = Hij.length;
    var c = bignumber2(cos2(theta));
    var s = bignumber2(sin2(theta));
    var c2 = multiplyScalar2(c, c);
    var s2 = multiplyScalar2(s, s);
    var Aki = Array(N).fill(bignumber2(0));
    var Akj = Array(N).fill(bignumber2(0));
    var csHij = multiply2(bignumber2(2), c, s, Hij[i2][j]);
    var Aii = addScalar2(subtract2(multiplyScalar2(c2, Hij[i2][i2]), csHij), multiplyScalar2(s2, Hij[j][j]));
    var Ajj = add2(multiplyScalar2(s2, Hij[i2][i2]), csHij, multiplyScalar2(c2, Hij[j][j]));
    for (var k = 0; k < N; k++) {
      Aki[k] = subtract2(multiplyScalar2(c, Hij[i2][k]), multiplyScalar2(s, Hij[j][k]));
      Akj[k] = addScalar2(multiplyScalar2(s, Hij[i2][k]), multiplyScalar2(c, Hij[j][k]));
    }
    Hij[i2][i2] = Aii;
    Hij[j][j] = Ajj;
    Hij[i2][j] = bignumber2(0);
    Hij[j][i2] = bignumber2(0);
    for (var _k3 = 0; _k3 < N; _k3++) {
      if (_k3 !== i2 && _k3 !== j) {
        Hij[i2][_k3] = Aki[_k3];
        Hij[_k3][i2] = Aki[_k3];
        Hij[j][_k3] = Akj[_k3];
        Hij[_k3][j] = Akj[_k3];
      }
    }
    return Hij;
  }
  function x1(Hij, theta, i2, j) {
    var N = Hij.length;
    var c = Math.cos(theta);
    var s = Math.sin(theta);
    var c2 = c * c;
    var s2 = s * s;
    var Aki = Array(N).fill(0);
    var Akj = Array(N).fill(0);
    var Aii = c2 * Hij[i2][i2] - 2 * c * s * Hij[i2][j] + s2 * Hij[j][j];
    var Ajj = s2 * Hij[i2][i2] + 2 * c * s * Hij[i2][j] + c2 * Hij[j][j];
    for (var k = 0; k < N; k++) {
      Aki[k] = c * Hij[i2][k] - s * Hij[j][k];
      Akj[k] = s * Hij[i2][k] + c * Hij[j][k];
    }
    Hij[i2][i2] = Aii;
    Hij[j][j] = Ajj;
    Hij[i2][j] = 0;
    Hij[j][i2] = 0;
    for (var _k4 = 0; _k4 < N; _k4++) {
      if (_k4 !== i2 && _k4 !== j) {
        Hij[i2][_k4] = Aki[_k4];
        Hij[_k4][i2] = Aki[_k4];
        Hij[j][_k4] = Akj[_k4];
        Hij[_k4][j] = Akj[_k4];
      }
    }
    return Hij;
  }
  function getAij(Mij) {
    var N = Mij.length;
    var maxMij = 0;
    var maxIJ = [0, 1];
    for (var i2 = 0; i2 < N; i2++) {
      for (var j = i2 + 1; j < N; j++) {
        if (Math.abs(maxMij) < Math.abs(Mij[i2][j])) {
          maxMij = Math.abs(Mij[i2][j]);
          maxIJ = [i2, j];
        }
      }
    }
    return [maxIJ, maxMij];
  }
  function getAijBig(Mij) {
    var N = Mij.length;
    var maxMij = 0;
    var maxIJ = [0, 1];
    for (var i2 = 0; i2 < N; i2++) {
      for (var j = i2 + 1; j < N; j++) {
        if (abs2(maxMij) < abs2(Mij[i2][j])) {
          maxMij = abs2(Mij[i2][j]);
          maxIJ = [i2, j];
        }
      }
    }
    return [maxIJ, maxMij];
  }
  function sorting(E, S, computeVectors) {
    var N = E.length;
    var values = Array(N);
    var vecs;
    if (computeVectors) {
      vecs = Array(N);
      for (var k = 0; k < N; k++) {
        vecs[k] = Array(N);
      }
    }
    for (var i2 = 0; i2 < N; i2++) {
      var minID = 0;
      var minE = E[0];
      for (var j = 0; j < E.length; j++) {
        if (abs2(E[j]) < abs2(minE)) {
          minID = j;
          minE = E[minID];
        }
      }
      values[i2] = E.splice(minID, 1)[0];
      if (computeVectors) {
        for (var _k5 = 0; _k5 < N; _k5++) {
          vecs[i2][_k5] = S[_k5][minID];
          S[_k5].splice(minID, 1);
        }
      }
    }
    if (!computeVectors) return {
      values
    };
    var eigenvectors = vecs.map((vector, i3) => ({
      value: values[i3],
      vector
    }));
    return {
      values,
      eigenvectors
    };
  }
  return main;
}

// node_modules/mathjs/lib/esm/function/matrix/eigs.js
var name168 = "eigs";
var dependencies168 = ["config", "typed", "matrix", "addScalar", "equal", "subtract", "abs", "atan", "cos", "sin", "multiplyScalar", "divideScalar", "inv", "bignumber", "multiply", "add", "larger", "column", "flatten", "number", "complex", "sqrt", "diag", "size", "reshape", "qr", "usolve", "usolveAll", "im", "re", "smaller", "matrixFromColumns", "dot"];
var createEigs = factory(name168, dependencies168, (_ref) => {
  var {
    config: config2,
    typed: typed2,
    matrix: matrix2,
    addScalar: addScalar2,
    subtract: subtract2,
    equal: equal2,
    abs: abs2,
    atan: atan3,
    cos: cos2,
    sin: sin2,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    inv: inv2,
    bignumber: bignumber2,
    multiply: multiply2,
    add: add2,
    larger: larger2,
    column: column2,
    flatten: flatten3,
    number: number2,
    complex: complex2,
    sqrt: sqrt2,
    diag: diag2,
    size: size2,
    reshape: reshape3,
    qr: qr2,
    usolve: usolve2,
    usolveAll: usolveAll2,
    im: im2,
    re: re2,
    smaller: smaller2,
    matrixFromColumns: matrixFromColumns2,
    dot: dot2
  } = _ref;
  var doRealSymmetric = createRealSymmetric({
    config: config2,
    addScalar: addScalar2,
    subtract: subtract2,
    column: column2,
    flatten: flatten3,
    equal: equal2,
    abs: abs2,
    atan: atan3,
    cos: cos2,
    sin: sin2,
    multiplyScalar: multiplyScalar2,
    inv: inv2,
    bignumber: bignumber2,
    complex: complex2,
    multiply: multiply2,
    add: add2
  });
  var doComplexEigs = createComplexEigs({
    config: config2,
    addScalar: addScalar2,
    subtract: subtract2,
    multiply: multiply2,
    multiplyScalar: multiplyScalar2,
    flatten: flatten3,
    divideScalar: divideScalar2,
    sqrt: sqrt2,
    abs: abs2,
    bignumber: bignumber2,
    diag: diag2,
    size: size2,
    reshape: reshape3,
    qr: qr2,
    inv: inv2,
    usolve: usolve2,
    usolveAll: usolveAll2,
    equal: equal2,
    complex: complex2,
    larger: larger2,
    smaller: smaller2,
    matrixFromColumns: matrixFromColumns2,
    dot: dot2
  });
  return typed2("eigs", {
    // The conversion to matrix in the first two implementations,
    // just to convert back to an array right away in
    // computeValuesAndVectors, is unfortunate, and should perhaps be
    // streamlined. It is done because the Matrix object carries some
    // type information about its entries, and so constructing the matrix
    // is a roundabout way of doing type detection.
    Array: function Array2(x) {
      return doEigs(matrix2(x));
    },
    "Array, number|BigNumber": function Array_numberBigNumber(x, prec) {
      return doEigs(matrix2(x), {
        precision: prec
      });
    },
    "Array, Object"(x, opts) {
      return doEigs(matrix2(x), opts);
    },
    Matrix: function Matrix2(mat) {
      return doEigs(mat, {
        matricize: true
      });
    },
    "Matrix, number|BigNumber": function Matrix_numberBigNumber(mat, prec) {
      return doEigs(mat, {
        precision: prec,
        matricize: true
      });
    },
    "Matrix, Object": function Matrix_Object(mat, opts) {
      var useOpts = {
        matricize: true
      };
      _extends(useOpts, opts);
      return doEigs(mat, useOpts);
    }
  });
  function doEigs(mat) {
    var _opts$precision;
    var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var computeVectors = "eigenvectors" in opts ? opts.eigenvectors : true;
    var prec = (_opts$precision = opts.precision) !== null && _opts$precision !== void 0 ? _opts$precision : config2.relTol;
    var result = computeValuesAndVectors(mat, prec, computeVectors);
    if (opts.matricize) {
      result.values = matrix2(result.values);
      if (computeVectors) {
        result.eigenvectors = result.eigenvectors.map((_ref2) => {
          var {
            value,
            vector
          } = _ref2;
          return {
            value,
            vector: matrix2(vector)
          };
        });
      }
    }
    if (computeVectors) {
      Object.defineProperty(result, "vectors", {
        enumerable: false,
        // to make sure that the eigenvectors can still be
        // converted to string.
        get: () => {
          throw new Error("eigs(M).vectors replaced with eigs(M).eigenvectors");
        }
      });
    }
    return result;
  }
  function computeValuesAndVectors(mat, prec, computeVectors) {
    var arr = mat.toArray();
    var asize = mat.size();
    if (asize.length !== 2 || asize[0] !== asize[1]) {
      throw new RangeError("Matrix must be square (size: ".concat(format2(asize), ")"));
    }
    var N = asize[0];
    if (isReal(arr, N, prec)) {
      coerceReal(arr, N);
      if (isSymmetric(arr, N, prec)) {
        var _type = coerceTypes(mat, arr, N);
        return doRealSymmetric(arr, N, prec, _type, computeVectors);
      }
    }
    var type = coerceTypes(mat, arr, N);
    return doComplexEigs(arr, N, prec, type, computeVectors);
  }
  function isSymmetric(arr, N, prec) {
    for (var i2 = 0; i2 < N; i2++) {
      for (var j = i2; j < N; j++) {
        if (larger2(bignumber2(abs2(subtract2(arr[i2][j], arr[j][i2]))), prec)) {
          return false;
        }
      }
    }
    return true;
  }
  function isReal(arr, N, prec) {
    for (var i2 = 0; i2 < N; i2++) {
      for (var j = 0; j < N; j++) {
        if (larger2(bignumber2(abs2(im2(arr[i2][j]))), prec)) {
          return false;
        }
      }
    }
    return true;
  }
  function coerceReal(arr, N) {
    for (var i2 = 0; i2 < N; i2++) {
      for (var j = 0; j < N; j++) {
        arr[i2][j] = re2(arr[i2][j]);
      }
    }
  }
  function coerceTypes(mat, arr, N) {
    var type = mat.datatype();
    if (type === "number" || type === "BigNumber" || type === "Complex") {
      return type;
    }
    var hasNumber = false;
    var hasBig = false;
    var hasComplex = false;
    for (var i2 = 0; i2 < N; i2++) {
      for (var j = 0; j < N; j++) {
        var el = arr[i2][j];
        if (isNumber(el) || isFraction(el)) {
          hasNumber = true;
        } else if (isBigNumber(el)) {
          hasBig = true;
        } else if (isComplex(el)) {
          hasComplex = true;
        } else {
          throw TypeError("Unsupported type in Matrix: " + typeOf(el));
        }
      }
    }
    if (hasBig && hasComplex) {
      console.warn("Complex BigNumbers not supported, this operation will lose precission.");
    }
    if (hasComplex) {
      for (var _i = 0; _i < N; _i++) {
        for (var _j = 0; _j < N; _j++) {
          arr[_i][_j] = complex2(arr[_i][_j]);
        }
      }
      return "Complex";
    }
    if (hasBig) {
      for (var _i2 = 0; _i2 < N; _i2++) {
        for (var _j2 = 0; _j2 < N; _j2++) {
          arr[_i2][_j2] = bignumber2(arr[_i2][_j2]);
        }
      }
      return "BigNumber";
    }
    if (hasNumber) {
      for (var _i3 = 0; _i3 < N; _i3++) {
        for (var _j3 = 0; _j3 < N; _j3++) {
          arr[_i3][_j3] = number2(arr[_i3][_j3]);
        }
      }
      return "number";
    } else {
      throw TypeError("Matrix contains unsupported types only.");
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/expm.js
var name169 = "expm";
var dependencies169 = ["typed", "abs", "add", "identity", "inv", "multiply"];
var createExpm = factory(name169, dependencies169, (_ref) => {
  var {
    typed: typed2,
    abs: abs2,
    add: add2,
    identity: identity2,
    inv: inv2,
    multiply: multiply2
  } = _ref;
  return typed2(name169, {
    Matrix: function Matrix2(A) {
      var size2 = A.size();
      if (size2.length !== 2 || size2[0] !== size2[1]) {
        throw new RangeError("Matrix must be square (size: " + format2(size2) + ")");
      }
      var n = size2[0];
      var eps = 1e-15;
      var infNorm = infinityNorm(A);
      var params = findParams(infNorm, eps);
      var q = params.q;
      var j = params.j;
      var Apos = multiply2(A, Math.pow(2, -j));
      var N = identity2(n);
      var D = identity2(n);
      var factor = 1;
      var AposToI = Apos;
      var alternate = -1;
      for (var i2 = 1; i2 <= q; i2++) {
        if (i2 > 1) {
          AposToI = multiply2(AposToI, Apos);
          alternate = -alternate;
        }
        factor = factor * (q - i2 + 1) / ((2 * q - i2 + 1) * i2);
        N = add2(N, multiply2(factor, AposToI));
        D = add2(D, multiply2(factor * alternate, AposToI));
      }
      var R = multiply2(inv2(D), N);
      for (var _i = 0; _i < j; _i++) {
        R = multiply2(R, R);
      }
      return isSparseMatrix(A) ? A.createSparseMatrix(R) : R;
    }
  });
  function infinityNorm(A) {
    var n = A.size()[0];
    var infNorm = 0;
    for (var i2 = 0; i2 < n; i2++) {
      var rowSum = 0;
      for (var j = 0; j < n; j++) {
        rowSum += abs2(A.get([i2, j]));
      }
      infNorm = Math.max(rowSum, infNorm);
    }
    return infNorm;
  }
  function findParams(infNorm, eps) {
    var maxSearchSize = 30;
    for (var k = 0; k < maxSearchSize; k++) {
      for (var q = 0; q <= k; q++) {
        var j = k - q;
        if (errorEstimate(infNorm, q, j) < eps) {
          return {
            q,
            j
          };
        }
      }
    }
    throw new Error("Could not find acceptable parameters to compute the matrix exponential (try increasing maxSearchSize in expm.js)");
  }
  function errorEstimate(infNorm, q, j) {
    var qfac = 1;
    for (var i2 = 2; i2 <= q; i2++) {
      qfac *= i2;
    }
    var twoqfac = qfac;
    for (var _i2 = q + 1; _i2 <= 2 * q; _i2++) {
      twoqfac *= _i2;
    }
    var twoqp1fac = twoqfac * (2 * q + 1);
    return 8 * Math.pow(infNorm / Math.pow(2, j), 2 * q) * qfac * qfac / (twoqfac * twoqp1fac);
  }
});

// node_modules/mathjs/lib/esm/function/matrix/sqrtm.js
var name170 = "sqrtm";
var dependencies170 = ["typed", "abs", "add", "multiply", "map", "sqrt", "subtract", "inv", "size", "max", "identity"];
var createSqrtm = factory(name170, dependencies170, (_ref) => {
  var {
    typed: typed2,
    abs: abs2,
    add: add2,
    multiply: multiply2,
    map: map2,
    sqrt: sqrt2,
    subtract: subtract2,
    inv: inv2,
    size: size2,
    max: max2,
    identity: identity2
  } = _ref;
  var _maxIterations = 1e3;
  var _tolerance = 1e-6;
  function _denmanBeavers(A) {
    var error;
    var iterations = 0;
    var Y = A;
    var Z = identity2(size2(A));
    do {
      var Yk = Y;
      Y = multiply2(0.5, add2(Yk, inv2(Z)));
      Z = multiply2(0.5, add2(Z, inv2(Yk)));
      error = max2(abs2(subtract2(Y, Yk)));
      if (error > _tolerance && ++iterations > _maxIterations) {
        throw new Error("computing square root of matrix: iterative method could not converge");
      }
    } while (error > _tolerance);
    return Y;
  }
  return typed2(name170, {
    "Array | Matrix": function Array__Matrix(A) {
      var size3 = isMatrix(A) ? A.size() : arraySize(A);
      switch (size3.length) {
        case 1:
          if (size3[0] === 1) {
            return map2(A, sqrt2);
          } else {
            throw new RangeError("Matrix must be square (size: " + format2(size3) + ")");
          }
        case 2: {
          var rows = size3[0];
          var cols = size3[1];
          if (rows === cols) {
            return _denmanBeavers(A);
          } else {
            throw new RangeError("Matrix must be square (size: " + format2(size3) + ")");
          }
        }
        default:
          throw new RangeError("Matrix must be at most two dimensional (size: " + format2(size3) + ")");
      }
    }
  });
});

// node_modules/mathjs/lib/esm/function/algebra/sylvester.js
var name171 = "sylvester";
var dependencies171 = ["typed", "schur", "matrixFromColumns", "matrix", "multiply", "range", "concat", "transpose", "index", "subset", "add", "subtract", "identity", "lusolve", "abs"];
var createSylvester = factory(name171, dependencies171, (_ref) => {
  var {
    typed: typed2,
    schur: schur2,
    matrixFromColumns: matrixFromColumns2,
    matrix: matrix2,
    multiply: multiply2,
    range: range2,
    concat: concat3,
    transpose: transpose2,
    index: index2,
    subset: subset2,
    add: add2,
    subtract: subtract2,
    identity: identity2,
    lusolve: lusolve2,
    abs: abs2
  } = _ref;
  return typed2(name171, {
    "Matrix, Matrix, Matrix": _sylvester,
    "Array, Matrix, Matrix": function Array_Matrix_Matrix(A, B, C) {
      return _sylvester(matrix2(A), B, C);
    },
    "Array, Array, Matrix": function Array_Array_Matrix(A, B, C) {
      return _sylvester(matrix2(A), matrix2(B), C);
    },
    "Array, Matrix, Array": function Array_Matrix_Array(A, B, C) {
      return _sylvester(matrix2(A), B, matrix2(C));
    },
    "Matrix, Array, Matrix": function Matrix_Array_Matrix(A, B, C) {
      return _sylvester(A, matrix2(B), C);
    },
    "Matrix, Array, Array": function Matrix_Array_Array(A, B, C) {
      return _sylvester(A, matrix2(B), matrix2(C));
    },
    "Matrix, Matrix, Array": function Matrix_Matrix_Array(A, B, C) {
      return _sylvester(A, B, matrix2(C));
    },
    "Array, Array, Array": function Array_Array_Array(A, B, C) {
      return _sylvester(matrix2(A), matrix2(B), matrix2(C)).toArray();
    }
  });
  function _sylvester(A, B, C) {
    var n = B.size()[0];
    var m = A.size()[0];
    var sA = schur2(A);
    var F = sA.T;
    var U = sA.U;
    var sB = schur2(multiply2(-1, B));
    var G = sB.T;
    var V = sB.U;
    var D = multiply2(multiply2(transpose2(U), C), V);
    var all2 = range2(0, m);
    var y = [];
    var hc = (a, b) => concat3(a, b, 1);
    var vc = (a, b) => concat3(a, b, 0);
    for (var k = 0; k < n; k++) {
      if (k < n - 1 && abs2(subset2(G, index2(k + 1, k))) > 1e-5) {
        var RHS = vc(subset2(D, index2(all2, k)), subset2(D, index2(all2, k + 1)));
        for (var j = 0; j < k; j++) {
          RHS = add2(RHS, vc(multiply2(y[j], subset2(G, index2(j, k))), multiply2(y[j], subset2(G, index2(j, k + 1)))));
        }
        var gkk = multiply2(identity2(m), multiply2(-1, subset2(G, index2(k, k))));
        var gmk = multiply2(identity2(m), multiply2(-1, subset2(G, index2(k + 1, k))));
        var gkm = multiply2(identity2(m), multiply2(-1, subset2(G, index2(k, k + 1))));
        var gmm = multiply2(identity2(m), multiply2(-1, subset2(G, index2(k + 1, k + 1))));
        var LHS = vc(hc(add2(F, gkk), gmk), hc(gkm, add2(F, gmm)));
        var yAux = lusolve2(LHS, RHS);
        y[k] = yAux.subset(index2(range2(0, m), 0));
        y[k + 1] = yAux.subset(index2(range2(m, 2 * m), 0));
        k++;
      } else {
        var _RHS = subset2(D, index2(all2, k));
        for (var _j = 0; _j < k; _j++) {
          _RHS = add2(_RHS, multiply2(y[_j], subset2(G, index2(_j, k))));
        }
        var _gkk = subset2(G, index2(k, k));
        var _LHS = subtract2(F, multiply2(_gkk, identity2(m)));
        y[k] = lusolve2(_LHS, _RHS);
      }
    }
    var Y = matrix2(matrixFromColumns2(...y));
    var X = multiply2(U, multiply2(Y, transpose2(V)));
    return X;
  }
});

// node_modules/mathjs/lib/esm/function/algebra/decomposition/schur.js
var name172 = "schur";
var dependencies172 = ["typed", "matrix", "identity", "multiply", "qr", "norm", "subtract"];
var createSchur = factory(name172, dependencies172, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    identity: identity2,
    multiply: multiply2,
    qr: qr2,
    norm: norm2,
    subtract: subtract2
  } = _ref;
  return typed2(name172, {
    Array: function Array2(X) {
      var r = _schur(matrix2(X));
      return {
        U: r.U.valueOf(),
        T: r.T.valueOf()
      };
    },
    Matrix: function Matrix2(X) {
      return _schur(X);
    }
  });
  function _schur(X) {
    var n = X.size()[0];
    var A = X;
    var U = identity2(n);
    var k = 0;
    var A0;
    do {
      A0 = A;
      var QR = qr2(A);
      var Q = QR.Q;
      var R = QR.R;
      A = multiply2(R, Q);
      U = multiply2(U, Q);
      if (k++ > 100) {
        break;
      }
    } while (norm2(subtract2(A, A0)) > 1e-4);
    return {
      U,
      T: A
    };
  }
});

// node_modules/mathjs/lib/esm/function/algebra/lyap.js
var name173 = "lyap";
var dependencies173 = ["typed", "matrix", "sylvester", "multiply", "transpose"];
var createLyap = factory(name173, dependencies173, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    sylvester: sylvester2,
    multiply: multiply2,
    transpose: transpose2
  } = _ref;
  return typed2(name173, {
    "Matrix, Matrix": function Matrix_Matrix(A, Q) {
      return sylvester2(A, transpose2(A), multiply2(-1, Q));
    },
    "Array, Matrix": function Array_Matrix(A, Q) {
      return sylvester2(matrix2(A), transpose2(matrix2(A)), multiply2(-1, Q));
    },
    "Matrix, Array": function Matrix_Array(A, Q) {
      return sylvester2(A, transpose2(matrix2(A)), matrix2(multiply2(-1, Q)));
    },
    "Array, Array": function Array_Array(A, Q) {
      return sylvester2(matrix2(A), transpose2(matrix2(A)), matrix2(multiply2(-1, Q))).toArray();
    }
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/divide.js
var name174 = "divide";
var dependencies174 = ["typed", "matrix", "multiply", "equalScalar", "divideScalar", "inv"];
var createDivide = factory(name174, dependencies174, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    multiply: multiply2,
    equalScalar: equalScalar2,
    divideScalar: divideScalar2,
    inv: inv2
  } = _ref;
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  return typed2("divide", extend({
    // we extend the signatures of divideScalar with signatures dealing with matrices
    "Array | Matrix, Array | Matrix": function Array__Matrix_Array__Matrix(x, y) {
      return multiply2(x, inv2(y));
    },
    "DenseMatrix, any": function DenseMatrix_any(x, y) {
      return matAlgo14xDs(x, y, divideScalar2, false);
    },
    "SparseMatrix, any": function SparseMatrix_any(x, y) {
      return matAlgo11xS0s(x, y, divideScalar2, false);
    },
    "Array, any": function Array_any(x, y) {
      return matAlgo14xDs(matrix2(x), y, divideScalar2, false).valueOf();
    },
    "any, Array | Matrix": function any_Array__Matrix(x, y) {
      return multiply2(x, inv2(y));
    }
  }, divideScalar2.signatures));
});

// node_modules/mathjs/lib/esm/function/geometry/distance.js
var name175 = "distance";
var dependencies175 = ["typed", "addScalar", "subtractScalar", "divideScalar", "multiplyScalar", "deepEqual", "sqrt", "abs"];
var createDistance = factory(name175, dependencies175, (_ref) => {
  var {
    typed: typed2,
    addScalar: addScalar2,
    subtractScalar: subtractScalar2,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    deepEqual: deepEqual2,
    sqrt: sqrt2,
    abs: abs2
  } = _ref;
  return typed2(name175, {
    "Array, Array, Array": function Array_Array_Array(x, y, z) {
      if (x.length === 2 && y.length === 2 && z.length === 2) {
        if (!_2d(x)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
        }
        if (!_2d(y)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");
        }
        if (!_2d(z)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");
        }
        if (deepEqual2(y, z)) {
          throw new TypeError("LinePoint1 should not be same with LinePoint2");
        }
        var xCoeff = subtractScalar2(z[1], y[1]);
        var yCoeff = subtractScalar2(y[0], z[0]);
        var constant = subtractScalar2(multiplyScalar2(z[0], y[1]), multiplyScalar2(y[0], z[1]));
        return _distancePointLine2D(x[0], x[1], xCoeff, yCoeff, constant);
      } else {
        throw new TypeError("Invalid Arguments: Try again");
      }
    },
    "Object, Object, Object": function Object_Object_Object(x, y, z) {
      if (Object.keys(x).length === 2 && Object.keys(y).length === 2 && Object.keys(z).length === 2) {
        if (!_2d(x)) {
          throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");
        }
        if (!_2d(y)) {
          throw new TypeError("Values of lineOnePtX and lineOnePtY should be numbers or BigNumbers");
        }
        if (!_2d(z)) {
          throw new TypeError("Values of lineTwoPtX and lineTwoPtY should be numbers or BigNumbers");
        }
        if (deepEqual2(_objectToArray(y), _objectToArray(z))) {
          throw new TypeError("LinePoint1 should not be same with LinePoint2");
        }
        if ("pointX" in x && "pointY" in x && "lineOnePtX" in y && "lineOnePtY" in y && "lineTwoPtX" in z && "lineTwoPtY" in z) {
          var xCoeff = subtractScalar2(z.lineTwoPtY, y.lineOnePtY);
          var yCoeff = subtractScalar2(y.lineOnePtX, z.lineTwoPtX);
          var constant = subtractScalar2(multiplyScalar2(z.lineTwoPtX, y.lineOnePtY), multiplyScalar2(y.lineOnePtX, z.lineTwoPtY));
          return _distancePointLine2D(x.pointX, x.pointY, xCoeff, yCoeff, constant);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else {
        throw new TypeError("Invalid Arguments: Try again");
      }
    },
    "Array, Array": function Array_Array(x, y) {
      if (x.length === 2 && y.length === 3) {
        if (!_2d(x)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
        }
        if (!_3d(y)) {
          throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
        }
        return _distancePointLine2D(x[0], x[1], y[0], y[1], y[2]);
      } else if (x.length === 3 && y.length === 6) {
        if (!_3d(x)) {
          throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
        }
        if (!_parametricLine(y)) {
          throw new TypeError("Array with 6 numbers or BigNumbers expected for second argument");
        }
        return _distancePointLine3D(x[0], x[1], x[2], y[0], y[1], y[2], y[3], y[4], y[5]);
      } else if (x.length === y.length && x.length > 0) {
        if (!_containsOnlyNumbers(x)) {
          throw new TypeError("All values of an array should be numbers or BigNumbers");
        }
        if (!_containsOnlyNumbers(y)) {
          throw new TypeError("All values of an array should be numbers or BigNumbers");
        }
        return _euclideanDistance(x, y);
      } else {
        throw new TypeError("Invalid Arguments: Try again");
      }
    },
    "Object, Object": function Object_Object(x, y) {
      if (Object.keys(x).length === 2 && Object.keys(y).length === 3) {
        if (!_2d(x)) {
          throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");
        }
        if (!_3d(y)) {
          throw new TypeError("Values of xCoeffLine, yCoeffLine and constant should be numbers or BigNumbers");
        }
        if ("pointX" in x && "pointY" in x && "xCoeffLine" in y && "yCoeffLine" in y && "constant" in y) {
          return _distancePointLine2D(x.pointX, x.pointY, y.xCoeffLine, y.yCoeffLine, y.constant);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else if (Object.keys(x).length === 3 && Object.keys(y).length === 6) {
        if (!_3d(x)) {
          throw new TypeError("Values of pointX, pointY and pointZ should be numbers or BigNumbers");
        }
        if (!_parametricLine(y)) {
          throw new TypeError("Values of x0, y0, z0, a, b and c should be numbers or BigNumbers");
        }
        if ("pointX" in x && "pointY" in x && "x0" in y && "y0" in y && "z0" in y && "a" in y && "b" in y && "c" in y) {
          return _distancePointLine3D(x.pointX, x.pointY, x.pointZ, y.x0, y.y0, y.z0, y.a, y.b, y.c);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else if (Object.keys(x).length === 2 && Object.keys(y).length === 2) {
        if (!_2d(x)) {
          throw new TypeError("Values of pointOneX and pointOneY should be numbers or BigNumbers");
        }
        if (!_2d(y)) {
          throw new TypeError("Values of pointTwoX and pointTwoY should be numbers or BigNumbers");
        }
        if ("pointOneX" in x && "pointOneY" in x && "pointTwoX" in y && "pointTwoY" in y) {
          return _euclideanDistance([x.pointOneX, x.pointOneY], [y.pointTwoX, y.pointTwoY]);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else if (Object.keys(x).length === 3 && Object.keys(y).length === 3) {
        if (!_3d(x)) {
          throw new TypeError("Values of pointOneX, pointOneY and pointOneZ should be numbers or BigNumbers");
        }
        if (!_3d(y)) {
          throw new TypeError("Values of pointTwoX, pointTwoY and pointTwoZ should be numbers or BigNumbers");
        }
        if ("pointOneX" in x && "pointOneY" in x && "pointOneZ" in x && "pointTwoX" in y && "pointTwoY" in y && "pointTwoZ" in y) {
          return _euclideanDistance([x.pointOneX, x.pointOneY, x.pointOneZ], [y.pointTwoX, y.pointTwoY, y.pointTwoZ]);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else {
        throw new TypeError("Invalid Arguments: Try again");
      }
    },
    Array: function Array2(arr) {
      if (!_pairwise(arr)) {
        throw new TypeError("Incorrect array format entered for pairwise distance calculation");
      }
      return _distancePairwise(arr);
    }
  });
  function _isNumber(a) {
    return typeof a === "number" || isBigNumber(a);
  }
  function _2d(a) {
    if (a.constructor !== Array) {
      a = _objectToArray(a);
    }
    return _isNumber(a[0]) && _isNumber(a[1]);
  }
  function _3d(a) {
    if (a.constructor !== Array) {
      a = _objectToArray(a);
    }
    return _isNumber(a[0]) && _isNumber(a[1]) && _isNumber(a[2]);
  }
  function _containsOnlyNumbers(a) {
    if (!Array.isArray(a)) {
      a = _objectToArray(a);
    }
    return a.every(_isNumber);
  }
  function _parametricLine(a) {
    if (a.constructor !== Array) {
      a = _objectToArray(a);
    }
    return _isNumber(a[0]) && _isNumber(a[1]) && _isNumber(a[2]) && _isNumber(a[3]) && _isNumber(a[4]) && _isNumber(a[5]);
  }
  function _objectToArray(o) {
    var keys = Object.keys(o);
    var a = [];
    for (var i2 = 0; i2 < keys.length; i2++) {
      a.push(o[keys[i2]]);
    }
    return a;
  }
  function _pairwise(a) {
    if (a[0].length === 2 && _isNumber(a[0][0]) && _isNumber(a[0][1])) {
      if (a.some((aI) => aI.length !== 2 || !_isNumber(aI[0]) || !_isNumber(aI[1]))) {
        return false;
      }
    } else if (a[0].length === 3 && _isNumber(a[0][0]) && _isNumber(a[0][1]) && _isNumber(a[0][2])) {
      if (a.some((aI) => aI.length !== 3 || !_isNumber(aI[0]) || !_isNumber(aI[1]) || !_isNumber(aI[2]))) {
        return false;
      }
    } else {
      return false;
    }
    return true;
  }
  function _distancePointLine2D(x, y, a, b, c) {
    var num = abs2(addScalar2(addScalar2(multiplyScalar2(a, x), multiplyScalar2(b, y)), c));
    var den = sqrt2(addScalar2(multiplyScalar2(a, a), multiplyScalar2(b, b)));
    return divideScalar2(num, den);
  }
  function _distancePointLine3D(x, y, z, x0, y0, z0, a, b, c) {
    var num = [subtractScalar2(multiplyScalar2(subtractScalar2(y0, y), c), multiplyScalar2(subtractScalar2(z0, z), b)), subtractScalar2(multiplyScalar2(subtractScalar2(z0, z), a), multiplyScalar2(subtractScalar2(x0, x), c)), subtractScalar2(multiplyScalar2(subtractScalar2(x0, x), b), multiplyScalar2(subtractScalar2(y0, y), a))];
    num = sqrt2(addScalar2(addScalar2(multiplyScalar2(num[0], num[0]), multiplyScalar2(num[1], num[1])), multiplyScalar2(num[2], num[2])));
    var den = sqrt2(addScalar2(addScalar2(multiplyScalar2(a, a), multiplyScalar2(b, b)), multiplyScalar2(c, c)));
    return divideScalar2(num, den);
  }
  function _euclideanDistance(x, y) {
    var vectorSize = x.length;
    var result = 0;
    var diff2 = 0;
    for (var i2 = 0; i2 < vectorSize; i2++) {
      diff2 = subtractScalar2(x[i2], y[i2]);
      result = addScalar2(multiplyScalar2(diff2, diff2), result);
    }
    return sqrt2(result);
  }
  function _distancePairwise(a) {
    var result = [];
    var pointA = [];
    var pointB = [];
    for (var i2 = 0; i2 < a.length - 1; i2++) {
      for (var j = i2 + 1; j < a.length; j++) {
        if (a[0].length === 2) {
          pointA = [a[i2][0], a[i2][1]];
          pointB = [a[j][0], a[j][1]];
        } else if (a[0].length === 3) {
          pointA = [a[i2][0], a[i2][1], a[i2][2]];
          pointB = [a[j][0], a[j][1], a[j][2]];
        }
        result.push(_euclideanDistance(pointA, pointB));
      }
    }
    return result;
  }
});

// node_modules/mathjs/lib/esm/function/geometry/intersect.js
var name176 = "intersect";
var dependencies176 = ["typed", "config", "abs", "add", "addScalar", "matrix", "multiply", "multiplyScalar", "divideScalar", "subtract", "smaller", "equalScalar", "flatten", "isZero", "isNumeric"];
var createIntersect = factory(name176, dependencies176, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    abs: abs2,
    add: add2,
    addScalar: addScalar2,
    matrix: matrix2,
    multiply: multiply2,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    subtract: subtract2,
    smaller: smaller2,
    equalScalar: equalScalar2,
    flatten: flatten3,
    isZero: isZero2,
    isNumeric: isNumeric2
  } = _ref;
  return typed2("intersect", {
    "Array, Array, Array": _AAA,
    "Array, Array, Array, Array": _AAAA,
    "Matrix, Matrix, Matrix": function Matrix_Matrix_Matrix(x, y, plane) {
      var arr = _AAA(x.valueOf(), y.valueOf(), plane.valueOf());
      return arr === null ? null : matrix2(arr);
    },
    "Matrix, Matrix, Matrix, Matrix": function Matrix_Matrix_Matrix_Matrix(w, x, y, z) {
      var arr = _AAAA(w.valueOf(), x.valueOf(), y.valueOf(), z.valueOf());
      return arr === null ? null : matrix2(arr);
    }
  });
  function _AAA(x, y, plane) {
    x = _coerceArr(x);
    y = _coerceArr(y);
    plane = _coerceArr(plane);
    if (!_3d(x)) {
      throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
    }
    if (!_3d(y)) {
      throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
    }
    if (!_4d(plane)) {
      throw new TypeError("Array with 4 numbers expected as third argument");
    }
    return _intersectLinePlane(x[0], x[1], x[2], y[0], y[1], y[2], plane[0], plane[1], plane[2], plane[3]);
  }
  function _AAAA(w, x, y, z) {
    w = _coerceArr(w);
    x = _coerceArr(x);
    y = _coerceArr(y);
    z = _coerceArr(z);
    if (w.length === 2) {
      if (!_2d(w)) {
        throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
      }
      if (!_2d(x)) {
        throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");
      }
      if (!_2d(y)) {
        throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");
      }
      if (!_2d(z)) {
        throw new TypeError("Array with 2 numbers or BigNumbers expected for fourth argument");
      }
      return _intersect2d(w, x, y, z);
    } else if (w.length === 3) {
      if (!_3d(w)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
      }
      if (!_3d(x)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
      }
      if (!_3d(y)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for third argument");
      }
      if (!_3d(z)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for fourth argument");
      }
      return _intersect3d(w[0], w[1], w[2], x[0], x[1], x[2], y[0], y[1], y[2], z[0], z[1], z[2]);
    } else {
      throw new TypeError("Arrays with two or thee dimensional points expected");
    }
  }
  function _coerceArr(arr) {
    if (arr.length === 1) return arr[0];
    if (arr.length > 1 && Array.isArray(arr[0])) {
      if (arr.every((el) => Array.isArray(el) && el.length === 1)) return flatten3(arr);
    }
    return arr;
  }
  function _2d(x) {
    return x.length === 2 && isNumeric2(x[0]) && isNumeric2(x[1]);
  }
  function _3d(x) {
    return x.length === 3 && isNumeric2(x[0]) && isNumeric2(x[1]) && isNumeric2(x[2]);
  }
  function _4d(x) {
    return x.length === 4 && isNumeric2(x[0]) && isNumeric2(x[1]) && isNumeric2(x[2]) && isNumeric2(x[3]);
  }
  function _intersect2d(p1a, p1b, p2a, p2b) {
    var o1 = p1a;
    var o2 = p2a;
    var d1 = subtract2(o1, p1b);
    var d2 = subtract2(o2, p2b);
    var det2 = subtract2(multiplyScalar2(d1[0], d2[1]), multiplyScalar2(d2[0], d1[1]));
    if (isZero2(det2)) return null;
    if (smaller2(abs2(det2), config2.relTol)) {
      return null;
    }
    var d20o11 = multiplyScalar2(d2[0], o1[1]);
    var d21o10 = multiplyScalar2(d2[1], o1[0]);
    var d20o21 = multiplyScalar2(d2[0], o2[1]);
    var d21o20 = multiplyScalar2(d2[1], o2[0]);
    var t = divideScalar2(addScalar2(subtract2(subtract2(d20o11, d21o10), d20o21), d21o20), det2);
    return add2(multiply2(d1, t), o1);
  }
  function _intersect3dHelper(a, b, c, d, e2, f, g, h, i2, j, k, l) {
    var add1 = multiplyScalar2(subtract2(a, b), subtract2(c, d));
    var add22 = multiplyScalar2(subtract2(e2, f), subtract2(g, h));
    var add3 = multiplyScalar2(subtract2(i2, j), subtract2(k, l));
    return addScalar2(addScalar2(add1, add22), add3);
  }
  function _intersect3d(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {
    var d1343 = _intersect3dHelper(x1, x3, x4, x3, y1, y3, y4, y3, z1, z3, z4, z3);
    var d4321 = _intersect3dHelper(x4, x3, x2, x1, y4, y3, y2, y1, z4, z3, z2, z1);
    var d1321 = _intersect3dHelper(x1, x3, x2, x1, y1, y3, y2, y1, z1, z3, z2, z1);
    var d4343 = _intersect3dHelper(x4, x3, x4, x3, y4, y3, y4, y3, z4, z3, z4, z3);
    var d2121 = _intersect3dHelper(x2, x1, x2, x1, y2, y1, y2, y1, z2, z1, z2, z1);
    var numerator = subtract2(multiplyScalar2(d1343, d4321), multiplyScalar2(d1321, d4343));
    var denominator = subtract2(multiplyScalar2(d2121, d4343), multiplyScalar2(d4321, d4321));
    if (isZero2(denominator)) return null;
    var ta = divideScalar2(numerator, denominator);
    var tb = divideScalar2(addScalar2(d1343, multiplyScalar2(ta, d4321)), d4343);
    var pax = addScalar2(x1, multiplyScalar2(ta, subtract2(x2, x1)));
    var pay = addScalar2(y1, multiplyScalar2(ta, subtract2(y2, y1)));
    var paz = addScalar2(z1, multiplyScalar2(ta, subtract2(z2, z1)));
    var pbx = addScalar2(x3, multiplyScalar2(tb, subtract2(x4, x3)));
    var pby = addScalar2(y3, multiplyScalar2(tb, subtract2(y4, y3)));
    var pbz = addScalar2(z3, multiplyScalar2(tb, subtract2(z4, z3)));
    if (equalScalar2(pax, pbx) && equalScalar2(pay, pby) && equalScalar2(paz, pbz)) {
      return [pax, pay, paz];
    } else {
      return null;
    }
  }
  function _intersectLinePlane(x1, y1, z1, x2, y2, z2, x, y, z, c) {
    var x1x = multiplyScalar2(x1, x);
    var x2x = multiplyScalar2(x2, x);
    var y1y = multiplyScalar2(y1, y);
    var y2y = multiplyScalar2(y2, y);
    var z1z = multiplyScalar2(z1, z);
    var z2z = multiplyScalar2(z2, z);
    var numerator = subtract2(subtract2(subtract2(c, x1x), y1y), z1z);
    var denominator = subtract2(subtract2(subtract2(addScalar2(addScalar2(x2x, y2y), z2z), x1x), y1y), z1z);
    var t = divideScalar2(numerator, denominator);
    var px = addScalar2(x1, multiplyScalar2(t, subtract2(x2, x1)));
    var py = addScalar2(y1, multiplyScalar2(t, subtract2(y2, y1)));
    var pz = addScalar2(z1, multiplyScalar2(t, subtract2(z2, z1)));
    return [px, py, pz];
  }
});

// node_modules/mathjs/lib/esm/function/probability/combinations.js
var name177 = "combinations";
var dependencies177 = ["typed"];
var createCombinations = factory(name177, dependencies177, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name177, {
    "number, number": combinationsNumber,
    "BigNumber, BigNumber": function BigNumber_BigNumber(n, k) {
      var BigNumber2 = n.constructor;
      var result, i2;
      var nMinusk = n.minus(k);
      var one = new BigNumber2(1);
      if (!isPositiveInteger(n) || !isPositiveInteger(k)) {
        throw new TypeError("Positive integer value expected in function combinations");
      }
      if (k.gt(n)) {
        throw new TypeError("k must be less than n in function combinations");
      }
      result = one;
      if (k.lt(nMinusk)) {
        for (i2 = one; i2.lte(nMinusk); i2 = i2.plus(one)) {
          result = result.times(k.plus(i2)).dividedBy(i2);
        }
      } else {
        for (i2 = one; i2.lte(k); i2 = i2.plus(one)) {
          result = result.times(nMinusk.plus(i2)).dividedBy(i2);
        }
      }
      return result;
    }
    // TODO: implement support for collection in combinations
  });
});
function isPositiveInteger(n) {
  return n.isInteger() && n.gte(0);
}

// node_modules/mathjs/lib/esm/function/probability/gamma.js
var name178 = "gamma";
var dependencies178 = ["typed", "config", "multiplyScalar", "pow", "BigNumber", "Complex"];
var createGamma = factory(name178, dependencies178, (_ref) => {
  var {
    typed: typed2,
    config: config2,
    multiplyScalar: multiplyScalar2,
    pow: pow2,
    BigNumber: _BigNumber,
    Complex: Complex3
  } = _ref;
  function gammaComplex(n) {
    if (n.im === 0) {
      return gammaNumber(n.re);
    }
    if (n.re < 0.5) {
      var _t = new Complex3(1 - n.re, -n.im);
      var r = new Complex3(Math.PI * n.re, Math.PI * n.im);
      return new Complex3(Math.PI).div(r.sin()).div(gammaComplex(_t));
    }
    n = new Complex3(n.re - 1, n.im);
    var x = new Complex3(gammaP[0], 0);
    for (var i2 = 1; i2 < gammaP.length; ++i2) {
      var gammaPval = new Complex3(gammaP[i2], 0);
      x = x.add(gammaPval.div(n.add(i2)));
    }
    var t = new Complex3(n.re + gammaG + 0.5, n.im);
    var twoPiSqrt = Math.sqrt(2 * Math.PI);
    var tpow = t.pow(n.add(0.5));
    var expt = t.neg().exp();
    return x.mul(twoPiSqrt).mul(tpow).mul(expt);
  }
  return typed2(name178, {
    number: gammaNumber,
    Complex: gammaComplex,
    BigNumber: function BigNumber2(n) {
      if (n.isInteger()) {
        return n.isNegative() || n.isZero() ? new _BigNumber(Infinity) : bigFactorial(n.minus(1));
      }
      if (!n.isFinite()) {
        return new _BigNumber(n.isNegative() ? NaN : Infinity);
      }
      throw new Error("Integer BigNumber expected");
    }
  });
  function bigFactorial(n) {
    if (n < 8) {
      return new _BigNumber([1, 1, 2, 6, 24, 120, 720, 5040][n]);
    }
    var precision = config2.precision + (Math.log(n.toNumber()) | 0);
    var Big = _BigNumber.clone({
      precision
    });
    if (n % 2 === 1) {
      return n.times(bigFactorial(new _BigNumber(n - 1)));
    }
    var p = n;
    var prod2 = new Big(n);
    var sum2 = n.toNumber();
    while (p > 2) {
      p -= 2;
      sum2 += p;
      prod2 = prod2.times(sum2);
    }
    return new _BigNumber(prod2.toPrecision(_BigNumber.precision));
  }
});

// node_modules/mathjs/lib/esm/function/probability/lgamma.js
var name179 = "lgamma";
var dependencies179 = ["Complex", "typed"];
var createLgamma = factory(name179, dependencies179, (_ref) => {
  var {
    Complex: Complex3,
    typed: typed2
  } = _ref;
  var SMALL_RE = 7;
  var SMALL_IM = 7;
  var coeffs = [-0.029550653594771242, 0.00641025641025641, -0.0019175269175269176, 8417508417508417e-19, -5952380952380953e-19, 7936507936507937e-19, -0.002777777777777778, 0.08333333333333333];
  return typed2(name179, {
    number: lgammaNumber,
    Complex: lgammaComplex,
    BigNumber: function BigNumber2() {
      throw new Error("mathjs doesn't yet provide an implementation of the algorithm lgamma for BigNumber");
    }
  });
  function lgammaComplex(n) {
    var TWOPI = 6.283185307179586;
    var LOGPI = 1.1447298858494002;
    var REFLECTION = 0.1;
    if (n.isNaN()) {
      return new Complex3(NaN, NaN);
    } else if (n.im === 0) {
      return new Complex3(lgammaNumber(n.re), 0);
    } else if (n.re >= SMALL_RE || Math.abs(n.im) >= SMALL_IM) {
      return lgammaStirling(n);
    } else if (n.re <= REFLECTION) {
      var tmp = copysign(TWOPI, n.im) * Math.floor(0.5 * n.re + 0.25);
      var a = n.mul(Math.PI).sin().log();
      var b = lgammaComplex(new Complex3(1 - n.re, -n.im));
      return new Complex3(LOGPI, tmp).sub(a).sub(b);
    } else if (n.im >= 0) {
      return lgammaRecurrence(n);
    } else {
      return lgammaRecurrence(n.conjugate()).conjugate();
    }
  }
  function lgammaStirling(z) {
    var leftPart = z.sub(0.5).mul(z.log()).sub(z).add(lnSqrt2PI);
    var rz = new Complex3(1, 0).div(z);
    var rzz = rz.div(z);
    var a = coeffs[0];
    var b = coeffs[1];
    var r = 2 * rzz.re;
    var s = rzz.re * rzz.re + rzz.im * rzz.im;
    for (var i2 = 2; i2 < 8; i2++) {
      var tmp = b;
      b = -s * a + coeffs[i2];
      a = r * a + tmp;
    }
    var rightPart = rz.mul(rzz.mul(a).add(b));
    return leftPart.add(rightPart);
  }
  function lgammaRecurrence(z) {
    var signflips = 0;
    var sb = 0;
    var shiftprod = z;
    z = z.add(1);
    while (z.re <= SMALL_RE) {
      shiftprod = shiftprod.mul(z);
      var nsb = shiftprod.im < 0 ? 1 : 0;
      if (nsb !== 0 && sb === 0) signflips++;
      sb = nsb;
      z = z.add(1);
    }
    return lgammaStirling(z).sub(shiftprod.log()).sub(new Complex3(0, signflips * 2 * Math.PI * 1));
  }
});

// node_modules/mathjs/lib/esm/function/probability/kldivergence.js
var name180 = "kldivergence";
var dependencies180 = ["typed", "matrix", "divide", "sum", "multiply", "map", "dotDivide", "log", "isNumeric"];
var createKldivergence = factory(name180, dependencies180, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    divide: divide2,
    sum: sum2,
    multiply: multiply2,
    map: map2,
    dotDivide: dotDivide2,
    log: log3,
    isNumeric: isNumeric2
  } = _ref;
  return typed2(name180, {
    "Array, Array": function Array_Array(q, p) {
      return _kldiv(matrix2(q), matrix2(p));
    },
    "Matrix, Array": function Matrix_Array(q, p) {
      return _kldiv(q, matrix2(p));
    },
    "Array, Matrix": function Array_Matrix(q, p) {
      return _kldiv(matrix2(q), p);
    },
    "Matrix, Matrix": function Matrix_Matrix(q, p) {
      return _kldiv(q, p);
    }
  });
  function _kldiv(q, p) {
    var plength = p.size().length;
    var qlength = q.size().length;
    if (plength > 1) {
      throw new Error("first object must be one dimensional");
    }
    if (qlength > 1) {
      throw new Error("second object must be one dimensional");
    }
    if (plength !== qlength) {
      throw new Error("Length of two vectors must be equal");
    }
    var sumq = sum2(q);
    if (sumq === 0) {
      throw new Error("Sum of elements in first object must be non zero");
    }
    var sump = sum2(p);
    if (sump === 0) {
      throw new Error("Sum of elements in second object must be non zero");
    }
    var qnorm = divide2(q, sum2(q));
    var pnorm = divide2(p, sum2(p));
    var result = sum2(multiply2(qnorm, map2(dotDivide2(qnorm, pnorm), (x) => log3(x))));
    if (isNumeric2(result)) {
      return result;
    } else {
      return Number.NaN;
    }
  }
});

// node_modules/mathjs/lib/esm/function/algebra/leafCount.js
var name181 = "leafCount";
var dependencies181 = ["parse", "typed"];
var createLeafCount = factory(name181, dependencies181, (_ref) => {
  var {
    parse: parse4,
    typed: typed2
  } = _ref;
  function countLeaves(node) {
    var count2 = 0;
    node.forEach((n) => {
      count2 += countLeaves(n);
    });
    return count2 || 1;
  }
  return typed2(name181, {
    Node: function Node2(expr) {
      return countLeaves(expr);
    }
  });
});

// node_modules/mathjs/lib/esm/function/algebra/symbolicEqual.js
var name182 = "symbolicEqual";
var dependencies182 = ["parse", "simplify", "typed", "OperatorNode"];
var createSymbolicEqual = factory(name182, dependencies182, (_ref) => {
  var {
    parse: parse4,
    simplify: simplify2,
    typed: typed2,
    OperatorNode: OperatorNode2
  } = _ref;
  function _symbolicEqual(e1, e2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var diff2 = new OperatorNode2("-", "subtract", [e1, e2]);
    var simplified = simplify2(diff2, {}, options);
    return isConstantNode(simplified) && !simplified.value;
  }
  return typed2(name182, {
    "Node, Node": _symbolicEqual,
    "Node, Node, Object": _symbolicEqual
  });
});

// node_modules/mathjs/lib/esm/function/signal/zpk2tf.js
var name183 = "zpk2tf";
var dependencies183 = ["typed", "add", "multiply", "Complex", "number"];
var createZpk2tf = factory(name183, dependencies183, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    multiply: multiply2,
    Complex: Complex3,
    number: number2
  } = _ref;
  return typed2(name183, {
    "Array,Array,number": function ArrayArrayNumber(z, p, k) {
      return _zpk2tf(z, p, k);
    },
    "Array,Array": function ArrayArray(z, p) {
      return _zpk2tf(z, p, 1);
    },
    "Matrix,Matrix,number": function MatrixMatrixNumber(z, p, k) {
      return _zpk2tf(z.valueOf(), p.valueOf(), k);
    },
    "Matrix,Matrix": function MatrixMatrix(z, p) {
      return _zpk2tf(z.valueOf(), p.valueOf(), 1);
    }
  });
  function _zpk2tf(z, p, k) {
    if (z.some((el) => el.type === "BigNumber")) {
      z = z.map((el) => number2(el));
    }
    if (p.some((el) => el.type === "BigNumber")) {
      p = p.map((el) => number2(el));
    }
    var num = [Complex3(1, 0)];
    var den = [Complex3(1, 0)];
    for (var i2 = 0; i2 < z.length; i2++) {
      var zero = z[i2];
      if (typeof zero === "number") zero = Complex3(zero, 0);
      num = _multiply(num, [Complex3(1, 0), Complex3(-zero.re, -zero.im)]);
    }
    for (var _i = 0; _i < p.length; _i++) {
      var pole = p[_i];
      if (typeof pole === "number") pole = Complex3(pole, 0);
      den = _multiply(den, [Complex3(1, 0), Complex3(-pole.re, -pole.im)]);
    }
    for (var _i2 = 0; _i2 < num.length; _i2++) {
      num[_i2] = multiply2(num[_i2], k);
    }
    return [num, den];
  }
  function _multiply(a, b) {
    var c = [];
    for (var i2 = 0; i2 < a.length + b.length - 1; i2++) {
      c[i2] = Complex3(0, 0);
      for (var j = 0; j < a.length; j++) {
        if (i2 - j >= 0 && i2 - j < b.length) {
          c[i2] = add2(c[i2], multiply2(a[j], b[i2 - j]));
        }
      }
    }
    return c;
  }
});

// node_modules/mathjs/lib/esm/function/signal/freqz.js
var name184 = "freqz";
var dependencies184 = ["typed", "add", "multiply", "Complex", "divide", "matrix"];
var createFreqz = factory(name184, dependencies184, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    multiply: multiply2,
    Complex: Complex3,
    divide: divide2,
    matrix: matrix2
  } = _ref;
  return typed2(name184, {
    "Array, Array": function Array_Array(b, a) {
      var w = createBins(512);
      return _freqz(b, a, w);
    },
    "Array, Array, Array": function Array_Array_Array(b, a, w) {
      return _freqz(b, a, w);
    },
    "Array, Array, number": function Array_Array_number(b, a, w) {
      if (w < 0) {
        throw new Error("w must be a positive number");
      }
      var w2 = createBins(w);
      return _freqz(b, a, w2);
    },
    "Matrix, Matrix": function Matrix_Matrix(b, a) {
      var _w = createBins(512);
      var {
        w,
        h
      } = _freqz(b.valueOf(), a.valueOf(), _w);
      return {
        w: matrix2(w),
        h: matrix2(h)
      };
    },
    "Matrix, Matrix, Matrix": function Matrix_Matrix_Matrix(b, a, w) {
      var {
        h
      } = _freqz(b.valueOf(), a.valueOf(), w.valueOf());
      return {
        h: matrix2(h),
        w: matrix2(w)
      };
    },
    "Matrix, Matrix, number": function Matrix_Matrix_number(b, a, w) {
      if (w < 0) {
        throw new Error("w must be a positive number");
      }
      var _w = createBins(w);
      var {
        h
      } = _freqz(b.valueOf(), a.valueOf(), _w);
      return {
        h: matrix2(h),
        w: matrix2(_w)
      };
    }
  });
  function _freqz(b, a, w) {
    var num = [];
    var den = [];
    for (var i2 = 0; i2 < w.length; i2++) {
      var sumNum = Complex3(0, 0);
      var sumDen = Complex3(0, 0);
      for (var j = 0; j < b.length; j++) {
        sumNum = add2(sumNum, multiply2(b[j], Complex3(Math.cos(-j * w[i2]), Math.sin(-j * w[i2]))));
      }
      for (var _j = 0; _j < a.length; _j++) {
        sumDen = add2(sumDen, multiply2(a[_j], Complex3(Math.cos(-_j * w[i2]), Math.sin(-_j * w[i2]))));
      }
      num.push(sumNum);
      den.push(sumDen);
    }
    var h = [];
    for (var _i = 0; _i < num.length; _i++) {
      h.push(divide2(num[_i], den[_i]));
    }
    return {
      h,
      w
    };
  }
  function createBins(n) {
    var bins = [];
    for (var i2 = 0; i2 < n; i2++) {
      bins.push(i2 / n * Math.PI);
    }
    return bins;
  }
});

// node_modules/mathjs/lib/esm/type/unit/physicalConstants.js
var createSpeedOfLight = unitFactory("speedOfLight", "299792458", "m s^-1");
var createGravitationConstant = unitFactory("gravitationConstant", "6.67430e-11", "m^3 kg^-1 s^-2");
var createPlanckConstant = unitFactory("planckConstant", "6.62607015e-34", "J s");
var createReducedPlanckConstant = unitFactory("reducedPlanckConstant", "1.0545718176461565e-34", "J s");
var createMagneticConstant = unitFactory("magneticConstant", "1.25663706212e-6", "N A^-2");
var createElectricConstant = unitFactory("electricConstant", "8.8541878128e-12", "F m^-1");
var createVacuumImpedance = unitFactory("vacuumImpedance", "376.730313667", "ohm");
var createCoulomb = unitFactory("coulomb", "8.987551792261171e9", "N m^2 C^-2");
var createElementaryCharge = unitFactory("elementaryCharge", "1.602176634e-19", "C");
var createBohrMagneton = unitFactory("bohrMagneton", "9.2740100783e-24", "J T^-1");
var createConductanceQuantum = unitFactory("conductanceQuantum", "7.748091729863649e-5", "S");
var createInverseConductanceQuantum = unitFactory("inverseConductanceQuantum", "12906.403729652257", "ohm");
var createMagneticFluxQuantum = unitFactory("magneticFluxQuantum", "2.0678338484619295e-15", "Wb");
var createNuclearMagneton = unitFactory("nuclearMagneton", "5.0507837461e-27", "J T^-1");
var createKlitzing = unitFactory("klitzing", "25812.807459304513", "ohm");
var createJosephson = unitFactory("josephson", "4.835978484169836e14 Hz V", "Hz V^-1");
var createBohrRadius = unitFactory("bohrRadius", "5.29177210903e-11", "m");
var createClassicalElectronRadius = unitFactory("classicalElectronRadius", "2.8179403262e-15", "m");
var createElectronMass = unitFactory("electronMass", "9.1093837015e-31", "kg");
var createFermiCoupling = unitFactory("fermiCoupling", "1.1663787e-5", "GeV^-2");
var createFineStructure = numberFactory("fineStructure", 0.0072973525693);
var createHartreeEnergy = unitFactory("hartreeEnergy", "4.3597447222071e-18", "J");
var createProtonMass = unitFactory("protonMass", "1.67262192369e-27", "kg");
var createDeuteronMass = unitFactory("deuteronMass", "3.3435830926e-27", "kg");
var createNeutronMass = unitFactory("neutronMass", "1.6749271613e-27", "kg");
var createQuantumOfCirculation = unitFactory("quantumOfCirculation", "3.6369475516e-4", "m^2 s^-1");
var createRydberg = unitFactory("rydberg", "10973731.568160", "m^-1");
var createThomsonCrossSection = unitFactory("thomsonCrossSection", "6.6524587321e-29", "m^2");
var createWeakMixingAngle = numberFactory("weakMixingAngle", 0.2229);
var createEfimovFactor = numberFactory("efimovFactor", 22.7);
var createAtomicMass = unitFactory("atomicMass", "1.66053906660e-27", "kg");
var createAvogadro = unitFactory("avogadro", "6.02214076e23", "mol^-1");
var createBoltzmann = unitFactory("boltzmann", "1.380649e-23", "J K^-1");
var createFaraday = unitFactory("faraday", "96485.33212331001", "C mol^-1");
var createFirstRadiation = unitFactory("firstRadiation", "3.7417718521927573e-16", "W m^2");
var createLoschmidt = unitFactory("loschmidt", "2.686780111798444e25", "m^-3");
var createGasConstant = unitFactory("gasConstant", "8.31446261815324", "J K^-1 mol^-1");
var createMolarPlanckConstant = unitFactory("molarPlanckConstant", "3.990312712893431e-10", "J s mol^-1");
var createMolarVolume = unitFactory("molarVolume", "0.022413969545014137", "m^3 mol^-1");
var createSackurTetrode = numberFactory("sackurTetrode", -1.16487052358);
var createSecondRadiation = unitFactory("secondRadiation", "0.014387768775039337", "m K");
var createStefanBoltzmann = unitFactory("stefanBoltzmann", "5.67037441918443e-8", "W m^-2 K^-4");
var createWienDisplacement = unitFactory("wienDisplacement", "2.897771955e-3", "m K");
var createMolarMass = unitFactory("molarMass", "0.99999999965e-3", "kg mol^-1");
var createMolarMassC12 = unitFactory("molarMassC12", "11.9999999958e-3", "kg mol^-1");
var createGravity = unitFactory("gravity", "9.80665", "m s^-2");
var createPlanckLength = unitFactory("planckLength", "1.616255e-35", "m");
var createPlanckMass = unitFactory("planckMass", "2.176435e-8", "kg");
var createPlanckTime = unitFactory("planckTime", "5.391245e-44", "s");
var createPlanckCharge = unitFactory("planckCharge", "1.87554603778e-18", "C");
var createPlanckTemperature = unitFactory("planckTemperature", "1.416785e+32", "K");
function unitFactory(name197, valueStr, unitStr) {
  var dependencies197 = ["config", "Unit", "BigNumber"];
  return factory(name197, dependencies197, (_ref) => {
    var {
      config: config2,
      Unit: Unit2,
      BigNumber: BigNumber2
    } = _ref;
    var value = config2.number === "BigNumber" ? new BigNumber2(valueStr) : parseFloat(valueStr);
    var unit2 = new Unit2(value, unitStr);
    unit2.fixPrefix = true;
    return unit2;
  });
}
function numberFactory(name197, value) {
  var dependencies197 = ["config", "BigNumber"];
  return factory(name197, dependencies197, (_ref2) => {
    var {
      config: config2,
      BigNumber: BigNumber2
    } = _ref2;
    return config2.number === "BigNumber" ? new BigNumber2(value) : value;
  });
}

// node_modules/mathjs/lib/esm/expression/transform/column.transform.js
var name185 = "column";
var dependencies185 = ["typed", "Index", "matrix", "range"];
var createColumnTransform = factory(name185, dependencies185, (_ref) => {
  var {
    typed: typed2,
    Index: Index2,
    matrix: matrix2,
    range: range2
  } = _ref;
  var column2 = createColumn({
    typed: typed2,
    Index: Index2,
    matrix: matrix2,
    range: range2
  });
  return typed2("column", {
    "...any": function any(args) {
      var lastIndex = args.length - 1;
      var last = args[lastIndex];
      if (isNumber(last)) {
        args[lastIndex] = last - 1;
      }
      try {
        return column2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/index.transform.js
var name186 = "index";
var dependencies186 = ["Index", "getMatrixDataType"];
var createIndexTransform = factory(name186, dependencies186, (_ref) => {
  var {
    Index: Index2,
    getMatrixDataType: getMatrixDataType2
  } = _ref;
  return function indexTransform() {
    var args = [];
    for (var i2 = 0, ii = arguments.length; i2 < ii; i2++) {
      var arg2 = arguments[i2];
      if (isRange(arg2)) {
        arg2.start--;
        arg2.end -= arg2.step > 0 ? 0 : 2;
      } else if (arg2 && arg2.isSet === true) {
        arg2 = arg2.map(function(v) {
          return v - 1;
        });
      } else if (isArray(arg2) || isMatrix(arg2)) {
        if (getMatrixDataType2(arg2) !== "boolean") {
          arg2 = arg2.map(function(v) {
            return v - 1;
          });
        }
      } else if (isNumber(arg2) || isBigInt(arg2)) {
        arg2--;
      } else if (isBigNumber(arg2)) {
        arg2 = arg2.toNumber() - 1;
      } else if (typeof arg2 === "string") {
      } else {
        throw new TypeError("Dimension must be an Array, Matrix, number, bigint, string, or Range");
      }
      args[i2] = arg2;
    }
    var res = new Index2();
    Index2.apply(res, args);
    return res;
  };
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/row.transform.js
var name187 = "row";
var dependencies187 = ["typed", "Index", "matrix", "range"];
var createRowTransform = factory(name187, dependencies187, (_ref) => {
  var {
    typed: typed2,
    Index: Index2,
    matrix: matrix2,
    range: range2
  } = _ref;
  var row2 = createRow({
    typed: typed2,
    Index: Index2,
    matrix: matrix2,
    range: range2
  });
  return typed2("row", {
    "...any": function any(args) {
      var lastIndex = args.length - 1;
      var last = args[lastIndex];
      if (isNumber(last)) {
        args[lastIndex] = last - 1;
      }
      try {
        return row2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/subset.transform.js
var name188 = "subset";
var dependencies188 = ["typed", "matrix", "zeros", "add"];
var createSubsetTransform = factory(name188, dependencies188, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    zeros: zeros2,
    add: add2
  } = _ref;
  var subset2 = createSubset({
    typed: typed2,
    matrix: matrix2,
    zeros: zeros2,
    add: add2
  });
  return typed2("subset", {
    "...any": function any(args) {
      try {
        return subset2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/concat.transform.js
var name189 = "concat";
var dependencies189 = ["typed", "matrix", "isInteger"];
var createConcatTransform = factory(name189, dependencies189, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    isInteger: isInteger3
  } = _ref;
  var concat3 = createConcat({
    typed: typed2,
    matrix: matrix2,
    isInteger: isInteger3
  });
  return typed2("concat", {
    "...any": function any(args) {
      var lastIndex = args.length - 1;
      var last = args[lastIndex];
      if (isNumber(last)) {
        args[lastIndex] = last - 1;
      } else if (isBigNumber(last)) {
        args[lastIndex] = last.minus(1);
      }
      try {
        return concat3.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/diff.transform.js
var name190 = "diff";
var dependencies190 = ["typed", "matrix", "subtract", "number", "bignumber"];
var createDiffTransform = factory(name190, dependencies190, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    subtract: subtract2,
    number: number2,
    bignumber: bignumber2
  } = _ref;
  var diff2 = createDiff({
    typed: typed2,
    matrix: matrix2,
    subtract: subtract2,
    number: number2,
    bignumber: bignumber2
  });
  return typed2(name190, {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return diff2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/quantileSeq.transform.js
var name191 = "quantileSeq";
var dependencies191 = ["typed", "bignumber", "add", "subtract", "divide", "multiply", "partitionSelect", "compare", "isInteger", "smaller", "smallerEq", "larger", "mapSlices"];
var createQuantileSeqTransform = factory(name191, dependencies191, (_ref) => {
  var {
    typed: typed2,
    bignumber: bignumber2,
    add: add2,
    subtract: subtract2,
    divide: divide2,
    multiply: multiply2,
    partitionSelect: partitionSelect2,
    compare: compare2,
    isInteger: isInteger3,
    smaller: smaller2,
    smallerEq: smallerEq2,
    larger: larger2,
    mapSlices: mapSlices2
  } = _ref;
  var quantileSeq2 = createQuantileSeq({
    typed: typed2,
    bignumber: bignumber2,
    add: add2,
    subtract: subtract2,
    divide: divide2,
    multiply: multiply2,
    partitionSelect: partitionSelect2,
    compare: compare2,
    isInteger: isInteger3,
    smaller: smaller2,
    smallerEq: smallerEq2,
    larger: larger2,
    mapSlices: mapSlices2
  });
  return typed2("quantileSeq", {
    "Array | Matrix, number | BigNumber": quantileSeq2,
    "Array | Matrix, number | BigNumber, number": (arr, prob, dim) => quantileSeq2(arr, prob, dimToZeroBase(dim)),
    "Array | Matrix, number | BigNumber, boolean": quantileSeq2,
    "Array | Matrix, number | BigNumber, boolean, number": (arr, prob, sorted, dim) => quantileSeq2(arr, prob, sorted, dimToZeroBase(dim)),
    "Array | Matrix, Array | Matrix": quantileSeq2,
    "Array | Matrix, Array | Matrix, number": (data, prob, dim) => quantileSeq2(data, prob, dimToZeroBase(dim)),
    "Array | Matrix, Array | Matrix, boolean": quantileSeq2,
    "Array | Matrix, Array | Matrix, boolean, number": (data, prob, sorted, dim) => quantileSeq2(data, prob, sorted, dimToZeroBase(dim))
  });
  function dimToZeroBase(dim) {
    return lastDimToZeroBase([[], dim])[1];
  }
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/print.transform.js
var name192 = "print";
var dependencies192 = ["typed", "matrix", "zeros", "add"];
var createPrintTransform = factory(name192, dependencies192, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    zeros: zeros2,
    add: add2
  } = _ref;
  var print2 = createPrint({
    typed: typed2,
    matrix: matrix2,
    zeros: zeros2,
    add: add2
  });
  return typed2(name192, {
    "string, Object | Array": function string_Object__Array(template, values) {
      return print2(_convertTemplateToZeroBasedIndex(template), values);
    },
    "string, Object | Array, number | Object": function string_Object__Array_number__Object(template, values, options) {
      return print2(_convertTemplateToZeroBasedIndex(template), values, options);
    }
  });
  function _convertTemplateToZeroBasedIndex(template) {
    return template.replace(printTemplate, (x) => {
      var parts = x.slice(1).split(".");
      var result = parts.map(function(part) {
        if (!isNaN(part) && part.length > 0) {
          return parseInt(part) - 1;
        } else {
          return part;
        }
      });
      return "$" + result.join(".");
    });
  }
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/and.transform.js
var name193 = "and";
var dependencies193 = ["typed", "matrix", "zeros", "add", "equalScalar", "not", "concat"];
var createAndTransform = factory(name193, dependencies193, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    not: not2,
    concat: concat3
  } = _ref;
  var and2 = createAnd({
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    not: not2,
    concat: concat3
  });
  function andTransform(args, math2, scope) {
    var condition1 = args[0].compile().evaluate(scope);
    if (!isCollection(condition1) && !and2(condition1, true)) {
      return false;
    }
    var condition2 = args[1].compile().evaluate(scope);
    return and2(condition1, condition2);
  }
  andTransform.rawArgs = true;
  return andTransform;
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/or.transform.js
var name194 = "or";
var dependencies194 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
var createOrTransform = factory(name194, dependencies194, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  } = _ref;
  var or2 = createOr({
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  });
  function orTransform(args, math2, scope) {
    var condition1 = args[0].compile().evaluate(scope);
    if (!isCollection(condition1) && or2(condition1, false)) {
      return true;
    }
    var condition2 = args[1].compile().evaluate(scope);
    return or2(condition1, condition2);
  }
  orTransform.rawArgs = true;
  return orTransform;
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/bitAnd.transform.js
var name195 = "bitAnd";
var dependencies195 = ["typed", "matrix", "zeros", "add", "equalScalar", "not", "concat"];
var createBitAndTransform = factory(name195, dependencies195, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    not: not2,
    concat: concat3
  } = _ref;
  var bitAnd2 = createBitAnd({
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    not: not2,
    concat: concat3
  });
  function bitAndTransform(args, math2, scope) {
    var condition1 = args[0].compile().evaluate(scope);
    if (!isCollection(condition1)) {
      if (isNaN(condition1)) {
        return NaN;
      }
      if (condition1 === 0 || condition1 === false) {
        return 0;
      }
    }
    var condition2 = args[1].compile().evaluate(scope);
    return bitAnd2(condition1, condition2);
  }
  bitAndTransform.rawArgs = true;
  return bitAndTransform;
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/bitOr.transform.js
var name196 = "bitOr";
var dependencies196 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
var createBitOrTransform = factory(name196, dependencies196, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  } = _ref;
  var bitOr2 = createBitOr({
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  });
  function bitOrTransform(args, math2, scope) {
    var condition1 = args[0].compile().evaluate(scope);
    if (!isCollection(condition1)) {
      if (isNaN(condition1)) {
        return NaN;
      }
      if (condition1 === -1) {
        return -1;
      }
      if (condition1 === true) {
        return 1;
      }
    }
    var condition2 = args[1].compile().evaluate(scope);
    return bitOr2(condition1, condition2);
  }
  bitOrTransform.rawArgs = true;
  return bitOrTransform;
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/entry/pureFunctionsAny.generated.js
var BigNumber = createBigNumberClass({
  config
});
var Complex2 = createComplexClass({});
var e = createE({
  BigNumber,
  config
});
var _false = createFalse({});
var fineStructure = createFineStructure({
  BigNumber,
  config
});
var Fraction2 = createFractionClass({});
var i = createI({
  Complex: Complex2
});
var _Infinity = createInfinity({
  BigNumber,
  config
});
var LN10 = createLN10({
  BigNumber,
  config
});
var LOG10E = createLOG10E({
  BigNumber,
  config
});
var Matrix = createMatrixClass({});
var _NaN = createNaN({
  BigNumber,
  config
});
var _null = createNull({});
var phi = createPhi({
  BigNumber,
  config
});
var Range = createRangeClass({});
var ResultSet = createResultSet({});
var SQRT1_2 = createSQRT1_2({
  BigNumber,
  config
});
var sackurTetrode = createSackurTetrode({
  BigNumber,
  config
});
var tau = createTau({
  BigNumber,
  config
});
var _true = createTrue({});
var version = createVersion({});
var DenseMatrix = createDenseMatrixClass({
  Matrix
});
var efimovFactor = createEfimovFactor({
  BigNumber,
  config
});
var LN2 = createLN2({
  BigNumber,
  config
});
var pi = createPi({
  BigNumber,
  config
});
var replacer = createReplacer({});
var SQRT2 = createSQRT2({
  BigNumber,
  config
});
var typed = createTyped({
  BigNumber,
  Complex: Complex2,
  DenseMatrix,
  Fraction: Fraction2
});
var weakMixingAngle = createWeakMixingAngle({
  BigNumber,
  config
});
var abs = createAbs({
  typed
});
var acos = createAcos({
  Complex: Complex2,
  config,
  typed
});
var acot = createAcot({
  BigNumber,
  typed
});
var acsc = createAcsc({
  BigNumber,
  Complex: Complex2,
  config,
  typed
});
var addScalar = createAddScalar({
  typed
});
var arg = createArg({
  typed
});
var asech = createAsech({
  BigNumber,
  Complex: Complex2,
  config,
  typed
});
var asinh = createAsinh({
  typed
});
var atan = createAtan({
  typed
});
var atanh = createAtanh({
  Complex: Complex2,
  config,
  typed
});
var bigint = createBigint({
  typed
});
var bitNot = createBitNot({
  typed
});
var boolean = createBoolean({
  typed
});
var clone2 = createClone({
  typed
});
var combinations = createCombinations({
  typed
});
var complex = createComplex({
  Complex: Complex2,
  typed
});
var conj = createConj({
  typed
});
var cos = createCos({
  typed
});
var cot = createCot({
  BigNumber,
  typed
});
var csc = createCsc({
  BigNumber,
  typed
});
var cube = createCube({
  typed
});
var equalScalar = createEqualScalar({
  config,
  typed
});
var erf = createErf({
  typed
});
var exp = createExp({
  typed
});
var expm1 = createExpm1({
  Complex: Complex2,
  typed
});
var filter = createFilter({
  typed
});
var flatten2 = createFlatten({
  typed
});
var forEach = createForEach({
  typed
});
var format3 = createFormat({
  typed
});
var getMatrixDataType = createGetMatrixDataType({
  typed
});
var hex = createHex({
  format: format3,
  typed
});
var im = createIm({
  typed
});
var isInteger2 = createIsInteger({
  typed
});
var isNegative = createIsNegative({
  config,
  typed
});
var isPositive = createIsPositive({
  config,
  typed
});
var isZero = createIsZero({
  equalScalar,
  typed
});
var LOG2E = createLOG2E({
  BigNumber,
  config
});
var lgamma = createLgamma({
  Complex: Complex2,
  typed
});
var log10 = createLog10({
  Complex: Complex2,
  config,
  typed
});
var log2 = createLog2({
  Complex: Complex2,
  config,
  typed
});
var map = createMap({
  typed
});
var multiplyScalar = createMultiplyScalar({
  typed
});
var not = createNot({
  typed
});
var number = createNumber({
  typed
});
var oct = createOct({
  format: format3,
  typed
});
var pickRandom = createPickRandom({
  config,
  typed
});
var print = createPrint({
  typed
});
var random = createRandom({
  config,
  typed
});
var re = createRe({
  typed
});
var sec = createSec({
  BigNumber,
  typed
});
var sign = createSign({
  BigNumber,
  Fraction: Fraction2,
  complex,
  typed
});
var sin = createSin({
  typed
});
var SparseMatrix = createSparseMatrixClass({
  Matrix,
  equalScalar,
  typed
});
var splitUnit = createSplitUnit({
  typed
});
var square = createSquare({
  typed
});
var string = createString({
  typed
});
var subtractScalar = createSubtractScalar({
  typed
});
var tan = createTan({
  typed
});
var typeOf2 = createTypeOf({
  typed
});
var acosh = createAcosh({
  Complex: Complex2,
  config,
  typed
});
var acsch = createAcsch({
  BigNumber,
  typed
});
var asec = createAsec({
  BigNumber,
  Complex: Complex2,
  config,
  typed
});
var bignumber = createBignumber({
  BigNumber,
  typed
});
var combinationsWithRep = createCombinationsWithRep({
  typed
});
var cosh3 = createCosh({
  typed
});
var csch = createCsch({
  BigNumber,
  typed
});
var isNaN2 = createIsNaN({
  typed
});
var isPrime = createIsPrime({
  typed
});
var mapSlices = createMapSlices({
  isInteger: isInteger2,
  typed
});
var apply = mapSlices;
var matrix = createMatrix({
  DenseMatrix,
  Matrix,
  SparseMatrix,
  typed
});
var matrixFromFunction = createMatrixFromFunction({
  isZero,
  matrix,
  typed
});
var ones = createOnes({
  BigNumber,
  config,
  matrix,
  typed
});
var randomInt = createRandomInt({
  config,
  log2,
  typed
});
var reshape2 = createReshape({
  isInteger: isInteger2,
  matrix,
  typed
});
var sech = createSech({
  BigNumber,
  typed
});
var sinh2 = createSinh({
  typed
});
var sparse = createSparse({
  SparseMatrix,
  typed
});
var sqrt = createSqrt({
  Complex: Complex2,
  config,
  typed
});
var squeeze2 = createSqueeze({
  typed
});
var tanh2 = createTanh({
  typed
});
var transpose = createTranspose({
  matrix,
  typed
});
var xgcd = createXgcd({
  BigNumber,
  config,
  matrix,
  typed
});
var zeros = createZeros({
  BigNumber,
  config,
  matrix,
  typed
});
var acoth = createAcoth({
  BigNumber,
  Complex: Complex2,
  config,
  typed
});
var asin = createAsin({
  Complex: Complex2,
  config,
  typed
});
var bin = createBin({
  format: format3,
  typed
});
var concat2 = createConcat({
  isInteger: isInteger2,
  matrix,
  typed
});
var coth = createCoth({
  BigNumber,
  typed
});
var ctranspose = createCtranspose({
  conj,
  transpose,
  typed
});
var diag = createDiag({
  DenseMatrix,
  SparseMatrix,
  matrix,
  typed
});
var dotMultiply = createDotMultiply({
  concat: concat2,
  equalScalar,
  matrix,
  multiplyScalar,
  typed
});
var equal = createEqual({
  DenseMatrix,
  SparseMatrix,
  concat: concat2,
  equalScalar,
  matrix,
  typed
});
var fraction = createFraction({
  Fraction: Fraction2,
  typed
});
var identity = createIdentity({
  BigNumber,
  DenseMatrix,
  SparseMatrix,
  config,
  matrix,
  typed
});
var isNumeric = createIsNumeric({
  typed
});
var kron = createKron({
  matrix,
  multiplyScalar,
  typed
});
var largerEq = createLargerEq({
  DenseMatrix,
  SparseMatrix,
  concat: concat2,
  config,
  matrix,
  typed
});
var leftShift = createLeftShift({
  DenseMatrix,
  concat: concat2,
  equalScalar,
  matrix,
  typed,
  zeros
});
var mode = createMode({
  isNaN: isNaN2,
  isNumeric,
  typed
});
var nthRoot = createNthRoot({
  BigNumber,
  concat: concat2,
  equalScalar,
  matrix,
  typed
});
var numeric = createNumeric({
  bignumber,
  fraction,
  number
});
var prod = createProd({
  config,
  multiplyScalar,
  numeric,
  typed
});
var resize2 = createResize({
  config,
  matrix
});
var rightArithShift = createRightArithShift({
  DenseMatrix,
  concat: concat2,
  equalScalar,
  matrix,
  typed,
  zeros
});
var round = createRound({
  BigNumber,
  DenseMatrix,
  config,
  equalScalar,
  matrix,
  typed,
  zeros
});
var size = createSize({
  matrix,
  config,
  typed
});
var smaller = createSmaller({
  DenseMatrix,
  SparseMatrix,
  bignumber,
  concat: concat2,
  config,
  matrix,
  typed
});
var to = createTo({
  concat: concat2,
  matrix,
  typed
});
var unaryMinus = createUnaryMinus({
  typed
});
var unequal = createUnequal({
  DenseMatrix,
  SparseMatrix,
  concat: concat2,
  config,
  equalScalar,
  matrix,
  typed
});
var xor = createXor({
  DenseMatrix,
  SparseMatrix,
  concat: concat2,
  matrix,
  typed
});
var add = createAdd({
  DenseMatrix,
  SparseMatrix,
  addScalar,
  concat: concat2,
  equalScalar,
  matrix,
  typed
});
var atan2 = createAtan2({
  BigNumber,
  DenseMatrix,
  concat: concat2,
  equalScalar,
  matrix,
  typed
});
var bitAnd = createBitAnd({
  concat: concat2,
  equalScalar,
  matrix,
  typed
});
var bitOr = createBitOr({
  DenseMatrix,
  concat: concat2,
  equalScalar,
  matrix,
  typed
});
var bitXor2 = createBitXor({
  DenseMatrix,
  SparseMatrix,
  concat: concat2,
  matrix,
  typed
});
var cbrt = createCbrt({
  BigNumber,
  Complex: Complex2,
  Fraction: Fraction2,
  config,
  isNegative,
  matrix,
  typed,
  unaryMinus
});
var compare = createCompare({
  BigNumber,
  DenseMatrix,
  Fraction: Fraction2,
  concat: concat2,
  config,
  equalScalar,
  matrix,
  typed
});
var compareText = createCompareText({
  concat: concat2,
  matrix,
  typed
});
var count = createCount({
  prod,
  size,
  typed
});
var deepEqual = createDeepEqual({
  equal,
  typed
});
var divideScalar = createDivideScalar({
  numeric,
  typed
});
var dotDivide = createDotDivide({
  DenseMatrix,
  SparseMatrix,
  concat: concat2,
  divideScalar,
  equalScalar,
  matrix,
  typed
});
var equalText = createEqualText({
  compareText,
  isZero,
  typed
});
var floor = createFloor({
  DenseMatrix,
  config,
  equalScalar,
  matrix,
  round,
  typed,
  zeros
});
var gcd2 = createGcd({
  BigNumber,
  DenseMatrix,
  concat: concat2,
  config,
  equalScalar,
  matrix,
  round,
  typed,
  zeros
});
var hasNumericValue = createHasNumericValue({
  isNumeric,
  typed
});
var hypot2 = createHypot({
  abs,
  addScalar,
  divideScalar,
  isPositive,
  multiplyScalar,
  smaller,
  sqrt,
  typed
});
var ImmutableDenseMatrix = createImmutableDenseMatrixClass({
  DenseMatrix,
  smaller
});
var Index = createIndexClass({
  ImmutableDenseMatrix,
  getMatrixDataType
});
var larger = createLarger({
  DenseMatrix,
  SparseMatrix,
  bignumber,
  concat: concat2,
  config,
  matrix,
  typed
});
var log = createLog({
  Complex: Complex2,
  config,
  divideScalar,
  typeOf: typeOf2,
  typed
});
var lsolve = createLsolve({
  DenseMatrix,
  divideScalar,
  equalScalar,
  matrix,
  multiplyScalar,
  subtractScalar,
  typed
});
var matrixFromColumns = createMatrixFromColumns({
  flatten: flatten2,
  matrix,
  size,
  typed
});
var max = createMax({
  config,
  isNaN: isNaN2,
  larger,
  numeric,
  typed
});
var min = createMin({
  config,
  isNaN: isNaN2,
  numeric,
  smaller,
  typed
});
var mod = createMod({
  DenseMatrix,
  concat: concat2,
  config,
  equalScalar,
  matrix,
  round,
  typed,
  zeros
});
var nthRoots = createNthRoots({
  Complex: Complex2,
  config,
  divideScalar,
  typed
});
var or = createOr({
  DenseMatrix,
  concat: concat2,
  equalScalar,
  matrix,
  typed
});
var partitionSelect = createPartitionSelect({
  compare,
  isNaN: isNaN2,
  isNumeric,
  typed
});
var qr = createQr({
  addScalar,
  complex,
  conj,
  divideScalar,
  equal,
  identity,
  isZero,
  matrix,
  multiplyScalar,
  sign,
  sqrt,
  subtractScalar,
  typed,
  unaryMinus,
  zeros
});
var rightLogShift = createRightLogShift({
  DenseMatrix,
  concat: concat2,
  equalScalar,
  matrix,
  typed,
  zeros
});
var smallerEq = createSmallerEq({
  DenseMatrix,
  SparseMatrix,
  concat: concat2,
  config,
  matrix,
  typed
});
var subset = createSubset({
  add,
  matrix,
  typed,
  zeros
});
var subtract = createSubtract({
  DenseMatrix,
  concat: concat2,
  equalScalar,
  matrix,
  subtractScalar,
  typed,
  unaryMinus
});
var trace = createTrace({
  add,
  matrix,
  typed
});
var usolve = createUsolve({
  DenseMatrix,
  divideScalar,
  equalScalar,
  matrix,
  multiplyScalar,
  subtractScalar,
  typed
});
var catalan = createCatalan({
  addScalar,
  combinations,
  divideScalar,
  isInteger: isInteger2,
  isNegative,
  multiplyScalar,
  typed
});
var compareNatural = createCompareNatural({
  compare,
  typed
});
var composition = createComposition({
  addScalar,
  combinations,
  isInteger: isInteger2,
  isNegative,
  isPositive,
  larger,
  typed
});
var diff = createDiff({
  matrix,
  number,
  subtract,
  typed
});
var distance = createDistance({
  abs,
  addScalar,
  deepEqual,
  divideScalar,
  multiplyScalar,
  sqrt,
  subtractScalar,
  typed
});
var dot = createDot({
  addScalar,
  conj,
  multiplyScalar,
  size,
  typed
});
var FibonacciHeap = createFibonacciHeapClass({
  larger,
  smaller
});
var index = createIndex({
  Index,
  typed
});
var invmod = createInvmod({
  BigNumber,
  add,
  config,
  equal,
  isInteger: isInteger2,
  mod,
  smaller,
  typed,
  xgcd
});
var lcm = createLcm({
  concat: concat2,
  equalScalar,
  matrix,
  typed
});
var log1p2 = createLog1p({
  Complex: Complex2,
  config,
  divideScalar,
  log,
  typed
});
var lsolveAll = createLsolveAll({
  DenseMatrix,
  divideScalar,
  equalScalar,
  matrix,
  multiplyScalar,
  subtractScalar,
  typed
});
var matrixFromRows = createMatrixFromRows({
  flatten: flatten2,
  matrix,
  size,
  typed
});
var multiply = createMultiply({
  addScalar,
  dot,
  equalScalar,
  matrix,
  multiplyScalar,
  typed
});
var range = createRange({
  bignumber,
  matrix,
  add,
  config,
  isPositive,
  larger,
  largerEq,
  smaller,
  smallerEq,
  typed
});
var row = createRow({
  Index,
  matrix,
  range,
  typed
});
var setCartesian = createSetCartesian({
  DenseMatrix,
  Index,
  compareNatural,
  size,
  subset,
  typed
});
var setDistinct = createSetDistinct({
  DenseMatrix,
  Index,
  compareNatural,
  size,
  subset,
  typed
});
var setIsSubset = createSetIsSubset({
  Index,
  compareNatural,
  size,
  subset,
  typed
});
var setPowerset = createSetPowerset({
  Index,
  compareNatural,
  size,
  subset,
  typed
});
var slu = createSlu({
  SparseMatrix,
  abs,
  add,
  divideScalar,
  larger,
  largerEq,
  multiply,
  subtract,
  transpose,
  typed
});
var sort = createSort({
  compare,
  compareNatural,
  matrix,
  typed
});
var unaryPlus = createUnaryPlus({
  config,
  numeric,
  typed
});
var usolveAll = createUsolveAll({
  DenseMatrix,
  divideScalar,
  equalScalar,
  matrix,
  multiplyScalar,
  subtractScalar,
  typed
});
var zpk2tf = createZpk2tf({
  Complex: Complex2,
  add,
  multiply,
  number,
  typed
});
var and = createAnd({
  concat: concat2,
  equalScalar,
  matrix,
  not,
  typed,
  zeros
});
var ceil = createCeil({
  DenseMatrix,
  config,
  equalScalar,
  matrix,
  round,
  typed,
  zeros
});
var column = createColumn({
  Index,
  matrix,
  range,
  typed
});
var cross = createCross({
  matrix,
  multiply,
  subtract,
  typed
});
var det = createDet({
  divideScalar,
  isZero,
  matrix,
  multiply,
  subtractScalar,
  typed,
  unaryMinus
});
var fix = createFix({
  Complex: Complex2,
  DenseMatrix,
  ceil,
  equalScalar,
  floor,
  matrix,
  typed,
  zeros
});
var inv = createInv({
  abs,
  addScalar,
  det,
  divideScalar,
  identity,
  matrix,
  multiply,
  typed,
  unaryMinus
});
var pinv = createPinv({
  Complex: Complex2,
  add,
  ctranspose,
  deepEqual,
  divideScalar,
  dot,
  dotDivide,
  equal,
  inv,
  matrix,
  multiply,
  typed
});
var pow = createPow({
  Complex: Complex2,
  config,
  fraction,
  identity,
  inv,
  matrix,
  multiply,
  number,
  typed
});
var setDifference = createSetDifference({
  DenseMatrix,
  Index,
  compareNatural,
  size,
  subset,
  typed
});
var setMultiplicity = createSetMultiplicity({
  Index,
  compareNatural,
  size,
  subset,
  typed
});
var setSymDifference = createSetSymDifference({
  Index,
  concat: concat2,
  setDifference,
  size,
  subset,
  typed
});
var Spa = createSpaClass({
  FibonacciHeap,
  addScalar,
  equalScalar
});
var sqrtm = createSqrtm({
  abs,
  add,
  identity,
  inv,
  map,
  max,
  multiply,
  size,
  sqrt,
  subtract,
  typed
});
var sum = createSum({
  add,
  config,
  numeric,
  typed
});
var Unit = createUnitClass({
  BigNumber,
  Complex: Complex2,
  Fraction: Fraction2,
  abs,
  addScalar,
  config,
  divideScalar,
  equal,
  fix,
  format: format3,
  isNumeric,
  multiplyScalar,
  number,
  pow,
  round,
  subtractScalar
});
var vacuumImpedance = createVacuumImpedance({
  BigNumber,
  Unit,
  config
});
var wienDisplacement = createWienDisplacement({
  BigNumber,
  Unit,
  config
});
var atomicMass = createAtomicMass({
  BigNumber,
  Unit,
  config
});
var bohrMagneton = createBohrMagneton({
  BigNumber,
  Unit,
  config
});
var boltzmann = createBoltzmann({
  BigNumber,
  Unit,
  config
});
var conductanceQuantum = createConductanceQuantum({
  BigNumber,
  Unit,
  config
});
var coulomb = createCoulomb({
  BigNumber,
  Unit,
  config
});
var cumsum = createCumSum({
  add,
  typed,
  unaryPlus
});
var deuteronMass = createDeuteronMass({
  BigNumber,
  Unit,
  config
});
var dotPow = createDotPow({
  DenseMatrix,
  SparseMatrix,
  concat: concat2,
  equalScalar,
  matrix,
  pow,
  typed
});
var electricConstant = createElectricConstant({
  BigNumber,
  Unit,
  config
});
var elementaryCharge = createElementaryCharge({
  BigNumber,
  Unit,
  config
});
var expm = createExpm({
  abs,
  add,
  identity,
  inv,
  multiply,
  typed
});
var faraday = createFaraday({
  BigNumber,
  Unit,
  config
});
var fft = createFft({
  addScalar,
  ceil,
  conj,
  divideScalar,
  dotDivide,
  exp,
  i,
  log2,
  matrix,
  multiplyScalar,
  pow,
  tau,
  typed
});
var gamma = createGamma({
  BigNumber,
  Complex: Complex2,
  config,
  multiplyScalar,
  pow,
  typed
});
var gravitationConstant = createGravitationConstant({
  BigNumber,
  Unit,
  config
});
var hartreeEnergy = createHartreeEnergy({
  BigNumber,
  Unit,
  config
});
var ifft = createIfft({
  conj,
  dotDivide,
  fft,
  typed
});
var inverseConductanceQuantum = createInverseConductanceQuantum({
  BigNumber,
  Unit,
  config
});
var klitzing = createKlitzing({
  BigNumber,
  Unit,
  config
});
var loschmidt = createLoschmidt({
  BigNumber,
  Unit,
  config
});
var magneticConstant = createMagneticConstant({
  BigNumber,
  Unit,
  config
});
var molarMass = createMolarMass({
  BigNumber,
  Unit,
  config
});
var molarPlanckConstant = createMolarPlanckConstant({
  BigNumber,
  Unit,
  config
});
var neutronMass = createNeutronMass({
  BigNumber,
  Unit,
  config
});
var nuclearMagneton = createNuclearMagneton({
  BigNumber,
  Unit,
  config
});
var planckCharge = createPlanckCharge({
  BigNumber,
  Unit,
  config
});
var planckLength = createPlanckLength({
  BigNumber,
  Unit,
  config
});
var planckTemperature = createPlanckTemperature({
  BigNumber,
  Unit,
  config
});
var protonMass = createProtonMass({
  BigNumber,
  Unit,
  config
});
var quantumOfCirculation = createQuantumOfCirculation({
  BigNumber,
  Unit,
  config
});
var reducedPlanckConstant = createReducedPlanckConstant({
  BigNumber,
  Unit,
  config
});
var rydberg = createRydberg({
  BigNumber,
  Unit,
  config
});
var secondRadiation = createSecondRadiation({
  BigNumber,
  Unit,
  config
});
var setSize = createSetSize({
  compareNatural,
  typed
});
var speedOfLight = createSpeedOfLight({
  BigNumber,
  Unit,
  config
});
var stefanBoltzmann = createStefanBoltzmann({
  BigNumber,
  Unit,
  config
});
var thomsonCrossSection = createThomsonCrossSection({
  BigNumber,
  Unit,
  config
});
var avogadro = createAvogadro({
  BigNumber,
  Unit,
  config
});
var bohrRadius = createBohrRadius({
  BigNumber,
  Unit,
  config
});
var createUnit = createCreateUnit({
  Unit,
  typed
});
var divide = createDivide({
  divideScalar,
  equalScalar,
  inv,
  matrix,
  multiply,
  typed
});
var electronMass = createElectronMass({
  BigNumber,
  Unit,
  config
});
var factorial = createFactorial({
  gamma,
  typed
});
var firstRadiation = createFirstRadiation({
  BigNumber,
  Unit,
  config
});
var gravity = createGravity({
  BigNumber,
  Unit,
  config
});
var intersect = createIntersect({
  abs,
  add,
  addScalar,
  config,
  divideScalar,
  equalScalar,
  flatten: flatten2,
  isNumeric,
  isZero,
  matrix,
  multiply,
  multiplyScalar,
  smaller,
  subtract,
  typed
});
var lup = createLup({
  DenseMatrix,
  Spa,
  SparseMatrix,
  abs,
  addScalar,
  divideScalar,
  equalScalar,
  larger,
  matrix,
  multiplyScalar,
  subtractScalar,
  typed,
  unaryMinus
});
var magneticFluxQuantum = createMagneticFluxQuantum({
  BigNumber,
  Unit,
  config
});
var molarMassC12 = createMolarMassC12({
  BigNumber,
  Unit,
  config
});
var multinomial = createMultinomial({
  add,
  divide,
  factorial,
  isInteger: isInteger2,
  isPositive,
  multiply,
  typed
});
var permutations = createPermutations({
  factorial,
  typed
});
var planckMass = createPlanckMass({
  BigNumber,
  Unit,
  config
});
var polynomialRoot = createPolynomialRoot({
  add,
  cbrt,
  divide,
  equalScalar,
  im,
  isZero,
  multiply,
  re,
  sqrt,
  subtract,
  typeOf: typeOf2,
  typed,
  unaryMinus
});
var setIntersect = createSetIntersect({
  DenseMatrix,
  Index,
  compareNatural,
  size,
  subset,
  typed
});
var solveODE = createSolveODE({
  abs,
  add,
  bignumber,
  divide,
  isNegative,
  isPositive,
  larger,
  map,
  matrix,
  max,
  multiply,
  smaller,
  subtract,
  typed,
  unaryMinus
});
var stirlingS2 = createStirlingS2({
  bignumber,
  addScalar,
  combinations,
  divideScalar,
  factorial,
  isInteger: isInteger2,
  isNegative,
  larger,
  multiplyScalar,
  number,
  pow,
  subtractScalar,
  typed
});
var unit = createUnitFunction({
  Unit,
  typed
});
var bellNumbers = createBellNumbers({
  addScalar,
  isInteger: isInteger2,
  isNegative,
  stirlingS2,
  typed
});
var eigs = createEigs({
  abs,
  add,
  addScalar,
  atan,
  bignumber,
  column,
  complex,
  config,
  cos,
  diag,
  divideScalar,
  dot,
  equal,
  flatten: flatten2,
  im,
  inv,
  larger,
  matrix,
  matrixFromColumns,
  multiply,
  multiplyScalar,
  number,
  qr,
  re,
  reshape: reshape2,
  sin,
  size,
  smaller,
  sqrt,
  subtract,
  typed,
  usolve,
  usolveAll
});
var fermiCoupling = createFermiCoupling({
  BigNumber,
  Unit,
  config
});
var gasConstant = createGasConstant({
  BigNumber,
  Unit,
  config
});
var kldivergence = createKldivergence({
  divide,
  dotDivide,
  isNumeric,
  log,
  map,
  matrix,
  multiply,
  sum,
  typed
});
var lusolve = createLusolve({
  DenseMatrix,
  lsolve,
  lup,
  matrix,
  slu,
  typed,
  usolve
});
var mean = createMean({
  add,
  divide,
  typed
});
var molarVolume = createMolarVolume({
  BigNumber,
  Unit,
  config
});
var planckConstant = createPlanckConstant({
  BigNumber,
  Unit,
  config
});
var quantileSeq = createQuantileSeq({
  bignumber,
  add,
  compare,
  divide,
  isInteger: isInteger2,
  larger,
  mapSlices,
  multiply,
  partitionSelect,
  smaller,
  smallerEq,
  subtract,
  typed
});
var setUnion = createSetUnion({
  Index,
  concat: concat2,
  setIntersect,
  setSymDifference,
  size,
  subset,
  typed
});
var variance = createVariance({
  add,
  divide,
  isNaN: isNaN2,
  mapSlices,
  multiply,
  subtract,
  typed
});
var classicalElectronRadius = createClassicalElectronRadius({
  BigNumber,
  Unit,
  config
});
var median = createMedian({
  add,
  compare,
  divide,
  partitionSelect,
  typed
});
var corr = createCorr({
  add,
  divide,
  matrix,
  mean,
  multiply,
  pow,
  sqrt,
  subtract,
  sum,
  typed
});
var freqz = createFreqz({
  Complex: Complex2,
  add,
  divide,
  matrix,
  multiply,
  typed
});
var mad = createMad({
  abs,
  map,
  median,
  subtract,
  typed
});
var std = createStd({
  map,
  sqrt,
  typed,
  variance
});
var zeta = createZeta({
  BigNumber,
  Complex: Complex2,
  add,
  config,
  divide,
  equal,
  factorial,
  gamma,
  isNegative,
  multiply,
  pi,
  pow,
  sin,
  smallerEq,
  subtract,
  typed
});
var norm = createNorm({
  abs,
  add,
  conj,
  ctranspose,
  eigs,
  equalScalar,
  larger,
  matrix,
  multiply,
  pow,
  smaller,
  sqrt,
  typed
});
var rotationMatrix = createRotationMatrix({
  BigNumber,
  DenseMatrix,
  SparseMatrix,
  addScalar,
  config,
  cos,
  matrix,
  multiplyScalar,
  norm,
  sin,
  typed,
  unaryMinus
});
var planckTime = createPlanckTime({
  BigNumber,
  Unit,
  config
});
var schur = createSchur({
  identity,
  matrix,
  multiply,
  norm,
  qr,
  subtract,
  typed
});
var rotate = createRotate({
  multiply,
  rotationMatrix,
  typed
});
var sylvester = createSylvester({
  abs,
  add,
  concat: concat2,
  identity,
  index,
  lusolve,
  matrix,
  matrixFromColumns,
  multiply,
  range,
  schur,
  subset,
  subtract,
  transpose,
  typed
});
var lyap = createLyap({
  matrix,
  multiply,
  sylvester,
  transpose,
  typed
});

// node_modules/mathjs/lib/esm/entry/impureFunctionsAny.generated.js
var math = {};
var mathWithTransform = {};
var classes = {};
var Node = createNode({
  mathWithTransform
});
var ObjectNode = createObjectNode({
  Node
});
var OperatorNode = createOperatorNode({
  Node
});
var ParenthesisNode = createParenthesisNode({
  Node
});
var RelationalNode = createRelationalNode({
  Node
});
var ArrayNode = createArrayNode({
  Node
});
var BlockNode = createBlockNode({
  Node,
  ResultSet
});
var ConditionalNode = createConditionalNode({
  Node
});
var ConstantNode = createConstantNode({
  Node
});
var RangeNode = createRangeNode({
  Node
});
var reviver = createReviver({
  classes
});
var Chain = createChainClass({
  math,
  typed
});
var FunctionAssignmentNode = createFunctionAssignmentNode({
  Node,
  typed
});
var chain = createChain({
  Chain,
  typed
});
var AccessorNode = createAccessorNode({
  Node,
  subset
});
var AssignmentNode = createAssignmentNode({
  matrix,
  Node,
  subset
});
var IndexNode = createIndexNode({
  Node,
  size
});
var SymbolNode = createSymbolNode({
  Unit,
  Node,
  math
});
var FunctionNode = createFunctionNode({
  Node,
  SymbolNode,
  math
});
var parse3 = createParse({
  AccessorNode,
  ArrayNode,
  AssignmentNode,
  BlockNode,
  ConditionalNode,
  ConstantNode,
  FunctionAssignmentNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  RangeNode,
  RelationalNode,
  SymbolNode,
  config,
  numeric,
  typed
});
var resolve = createResolve({
  ConstantNode,
  FunctionNode,
  OperatorNode,
  ParenthesisNode,
  parse: parse3,
  typed
});
var simplifyConstant = createSimplifyConstant({
  bignumber,
  fraction,
  AccessorNode,
  ArrayNode,
  ConstantNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  SymbolNode,
  config,
  mathWithTransform,
  matrix,
  typed
});
var compile = createCompile({
  parse: parse3,
  typed
});
var simplifyCore = createSimplifyCore({
  AccessorNode,
  ArrayNode,
  ConstantNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode,
  add,
  divide,
  equal,
  isZero,
  multiply,
  parse: parse3,
  pow,
  subtract,
  typed
});
var evaluate = createEvaluate({
  parse: parse3,
  typed
});
var Help = createHelpClass({
  evaluate
});
var Parser = createParserClass({
  evaluate,
  parse: parse3
});
var simplify = createSimplify({
  AccessorNode,
  ArrayNode,
  ConstantNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode,
  equal,
  parse: parse3,
  replacer,
  resolve,
  simplifyConstant,
  simplifyCore,
  typed
});
var symbolicEqual = createSymbolicEqual({
  OperatorNode,
  parse: parse3,
  simplify,
  typed
});
var leafCount = createLeafCount({
  parse: parse3,
  typed
});
var parser = createParser({
  Parser,
  typed
});
var rationalize = createRationalize({
  bignumber,
  fraction,
  AccessorNode,
  ArrayNode,
  ConstantNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode,
  add,
  config,
  divide,
  equal,
  isZero,
  mathWithTransform,
  matrix,
  multiply,
  parse: parse3,
  pow,
  simplify,
  simplifyConstant,
  simplifyCore,
  subtract,
  typed
});
var derivative = createDerivative({
  ConstantNode,
  FunctionNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode,
  config,
  equal,
  isZero,
  numeric,
  parse: parse3,
  simplify,
  typed
});
var help = createHelp({
  Help,
  mathWithTransform,
  typed
});
_extends(math, {
  e,
  false: _false,
  fineStructure,
  i,
  Infinity: _Infinity,
  LN10,
  LOG10E,
  NaN: _NaN,
  null: _null,
  phi,
  SQRT1_2,
  sackurTetrode,
  tau,
  true: _true,
  "E": e,
  version,
  efimovFactor,
  LN2,
  pi,
  replacer,
  reviver,
  SQRT2,
  typed,
  "PI": pi,
  weakMixingAngle,
  abs,
  acos,
  acot,
  acsc,
  addScalar,
  arg,
  asech,
  asinh,
  atan,
  atanh,
  bigint,
  bitNot,
  boolean,
  clone: clone2,
  combinations,
  complex,
  conj,
  cos,
  cot,
  csc,
  cube,
  equalScalar,
  erf,
  exp,
  expm1,
  filter,
  flatten: flatten2,
  forEach,
  format: format3,
  getMatrixDataType,
  hex,
  im,
  isInteger: isInteger2,
  isNegative,
  isPositive,
  isZero,
  LOG2E,
  lgamma,
  log10,
  log2,
  map,
  multiplyScalar,
  not,
  number,
  oct,
  pickRandom,
  print,
  random,
  re,
  sec,
  sign,
  sin,
  splitUnit,
  square,
  string,
  subtractScalar,
  tan,
  typeOf: typeOf2,
  acosh,
  acsch,
  asec,
  bignumber,
  chain,
  combinationsWithRep,
  cosh: cosh3,
  csch,
  isNaN: isNaN2,
  isPrime,
  mapSlices,
  matrix,
  matrixFromFunction,
  ones,
  randomInt,
  reshape: reshape2,
  sech,
  sinh: sinh2,
  sparse,
  sqrt,
  squeeze: squeeze2,
  tanh: tanh2,
  transpose,
  xgcd,
  zeros,
  acoth,
  asin,
  bin,
  concat: concat2,
  coth,
  ctranspose,
  diag,
  dotMultiply,
  equal,
  fraction,
  identity,
  isNumeric,
  kron,
  largerEq,
  leftShift,
  mode,
  nthRoot,
  numeric,
  prod,
  resize: resize2,
  rightArithShift,
  round,
  size,
  smaller,
  to,
  unaryMinus,
  unequal,
  xor,
  add,
  atan2,
  bitAnd,
  bitOr,
  bitXor: bitXor2,
  cbrt,
  compare,
  compareText,
  count,
  deepEqual,
  divideScalar,
  dotDivide,
  equalText,
  floor,
  gcd: gcd2,
  hasNumericValue,
  hypot: hypot2,
  larger,
  log,
  lsolve,
  matrixFromColumns,
  max,
  min,
  mod,
  nthRoots,
  or,
  partitionSelect,
  qr,
  rightLogShift,
  smallerEq,
  subset,
  subtract,
  trace,
  usolve,
  catalan,
  compareNatural,
  composition,
  diff,
  distance,
  dot,
  index,
  invmod,
  lcm,
  log1p: log1p2,
  lsolveAll,
  matrixFromRows,
  multiply,
  range,
  row,
  setCartesian,
  setDistinct,
  setIsSubset,
  setPowerset,
  slu,
  sort,
  unaryPlus,
  usolveAll,
  zpk2tf,
  and,
  ceil,
  column,
  cross,
  det,
  fix,
  inv,
  pinv,
  pow,
  setDifference,
  setMultiplicity,
  setSymDifference,
  sqrtm,
  sum,
  vacuumImpedance,
  wienDisplacement,
  atomicMass,
  bohrMagneton,
  boltzmann,
  conductanceQuantum,
  coulomb,
  cumsum,
  deuteronMass,
  dotPow,
  electricConstant,
  elementaryCharge,
  expm,
  faraday,
  fft,
  gamma,
  gravitationConstant,
  hartreeEnergy,
  ifft,
  inverseConductanceQuantum,
  klitzing,
  loschmidt,
  magneticConstant,
  molarMass,
  molarPlanckConstant,
  neutronMass,
  nuclearMagneton,
  planckCharge,
  planckLength,
  planckTemperature,
  protonMass,
  quantumOfCirculation,
  reducedPlanckConstant,
  rydberg,
  secondRadiation,
  setSize,
  speedOfLight,
  stefanBoltzmann,
  thomsonCrossSection,
  avogadro,
  bohrRadius,
  createUnit,
  divide,
  electronMass,
  factorial,
  firstRadiation,
  gravity,
  intersect,
  lup,
  magneticFluxQuantum,
  molarMassC12,
  multinomial,
  parse: parse3,
  permutations,
  planckMass,
  polynomialRoot,
  resolve,
  setIntersect,
  simplifyConstant,
  solveODE,
  stirlingS2,
  unit,
  bellNumbers,
  compile,
  eigs,
  fermiCoupling,
  gasConstant,
  kldivergence,
  lusolve,
  mean,
  molarVolume,
  planckConstant,
  quantileSeq,
  setUnion,
  simplifyCore,
  variance,
  classicalElectronRadius,
  evaluate,
  median,
  simplify,
  symbolicEqual,
  corr,
  freqz,
  leafCount,
  mad,
  parser,
  rationalize,
  std,
  zeta,
  derivative,
  norm,
  rotationMatrix,
  help,
  planckTime,
  schur,
  rotate,
  sylvester,
  lyap,
  config
});
_extends(mathWithTransform, math, {
  mapSlices: createMapSlicesTransform({
    isInteger: isInteger2,
    typed
  }),
  filter: createFilterTransform({
    typed
  }),
  forEach: createForEachTransform({
    typed
  }),
  map: createMapTransform({
    typed
  }),
  or: createOrTransform({
    DenseMatrix,
    concat: concat2,
    equalScalar,
    matrix,
    typed
  }),
  and: createAndTransform({
    add,
    concat: concat2,
    equalScalar,
    matrix,
    not,
    typed,
    zeros
  }),
  concat: createConcatTransform({
    isInteger: isInteger2,
    matrix,
    typed
  }),
  index: createIndexTransform({
    Index,
    getMatrixDataType
  }),
  print: createPrintTransform({
    add,
    matrix,
    typed,
    zeros
  }),
  sum: createSumTransform({
    add,
    config,
    numeric,
    typed
  }),
  bitAnd: createBitAndTransform({
    add,
    concat: concat2,
    equalScalar,
    matrix,
    not,
    typed,
    zeros
  }),
  min: createMinTransform({
    config,
    isNaN: isNaN2,
    numeric,
    smaller,
    typed
  }),
  subset: createSubsetTransform({
    add,
    matrix,
    typed,
    zeros
  }),
  bitOr: createBitOrTransform({
    DenseMatrix,
    concat: concat2,
    equalScalar,
    matrix,
    typed
  }),
  cumsum: createCumSumTransform({
    add,
    typed,
    unaryPlus
  }),
  diff: createDiffTransform({
    bignumber,
    matrix,
    number,
    subtract,
    typed
  }),
  max: createMaxTransform({
    config,
    isNaN: isNaN2,
    larger,
    numeric,
    typed
  }),
  range: createRangeTransform({
    bignumber,
    matrix,
    add,
    config,
    isPositive,
    larger,
    largerEq,
    smaller,
    smallerEq,
    typed
  }),
  row: createRowTransform({
    Index,
    matrix,
    range,
    typed
  }),
  column: createColumnTransform({
    Index,
    matrix,
    range,
    typed
  }),
  mean: createMeanTransform({
    add,
    divide,
    typed
  }),
  quantileSeq: createQuantileSeqTransform({
    add,
    bignumber,
    compare,
    divide,
    isInteger: isInteger2,
    larger,
    mapSlices,
    multiply,
    partitionSelect,
    smaller,
    smallerEq,
    subtract,
    typed
  }),
  variance: createVarianceTransform({
    add,
    divide,
    isNaN: isNaN2,
    mapSlices,
    multiply,
    subtract,
    typed
  }),
  std: createStdTransform({
    map,
    sqrt,
    typed,
    variance
  })
});
_extends(classes, {
  BigNumber,
  Complex: Complex2,
  Fraction: Fraction2,
  Matrix,
  Node,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  Range,
  RelationalNode,
  ResultSet,
  ArrayNode,
  BlockNode,
  ConditionalNode,
  ConstantNode,
  DenseMatrix,
  RangeNode,
  Chain,
  FunctionAssignmentNode,
  SparseMatrix,
  ImmutableDenseMatrix,
  Index,
  AccessorNode,
  AssignmentNode,
  FibonacciHeap,
  IndexNode,
  Spa,
  Unit,
  SymbolNode,
  FunctionNode,
  Help,
  Parser
});
Chain.createProxy(math);

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesBigNumberClass.generated.js
var BigNumberDependencies = {
  createBigNumberClass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesComplexClass.generated.js
var ComplexDependencies = {
  createComplexClass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMatrixClass.generated.js
var MatrixDependencies = {
  createMatrixClass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesDenseMatrixClass.generated.js
var DenseMatrixDependencies = {
  MatrixDependencies,
  createDenseMatrixClass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFractionClass.generated.js
var FractionDependencies = {
  createFractionClass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesTyped.generated.js
var typedDependencies = {
  BigNumberDependencies,
  ComplexDependencies,
  DenseMatrixDependencies,
  FractionDependencies,
  createTyped
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAbs.generated.js
var absDependencies = {
  typedDependencies,
  createAbs
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesNode.generated.js
var NodeDependencies = {
  createNode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesEqualScalar.generated.js
var equalScalarDependencies = {
  typedDependencies,
  createEqualScalar
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSparseMatrixClass.generated.js
var SparseMatrixDependencies = {
  MatrixDependencies,
  equalScalarDependencies,
  typedDependencies,
  createSparseMatrixClass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAddScalar.generated.js
var addScalarDependencies = {
  typedDependencies,
  createAddScalar
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesIsInteger.generated.js
var isIntegerDependencies = {
  typedDependencies,
  createIsInteger
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMatrix.generated.js
var matrixDependencies = {
  DenseMatrixDependencies,
  MatrixDependencies,
  SparseMatrixDependencies,
  typedDependencies,
  createMatrix
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesConcat.generated.js
var concatDependencies = {
  isIntegerDependencies,
  matrixDependencies,
  typedDependencies,
  createConcat
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAdd.generated.js
var addDependencies = {
  DenseMatrixDependencies,
  SparseMatrixDependencies,
  addScalarDependencies,
  concatDependencies,
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  createAdd
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesZeros.generated.js
var zerosDependencies = {
  BigNumberDependencies,
  matrixDependencies,
  typedDependencies,
  createZeros
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSubset.generated.js
var subsetDependencies = {
  addDependencies,
  matrixDependencies,
  typedDependencies,
  zerosDependencies,
  createSubset
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAccessorNode.generated.js
var AccessorNodeDependencies = {
  NodeDependencies,
  subsetDependencies,
  createAccessorNode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAcos.generated.js
var acosDependencies = {
  ComplexDependencies,
  typedDependencies,
  createAcos
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAcosh.generated.js
var acoshDependencies = {
  ComplexDependencies,
  typedDependencies,
  createAcosh
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAcot.generated.js
var acotDependencies = {
  BigNumberDependencies,
  typedDependencies,
  createAcot
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAcoth.generated.js
var acothDependencies = {
  BigNumberDependencies,
  ComplexDependencies,
  typedDependencies,
  createAcoth
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAcsc.generated.js
var acscDependencies = {
  BigNumberDependencies,
  ComplexDependencies,
  typedDependencies,
  createAcsc
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAcsch.generated.js
var acschDependencies = {
  BigNumberDependencies,
  typedDependencies,
  createAcsch
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesNot.generated.js
var notDependencies = {
  typedDependencies,
  createNot
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAnd.generated.js
var andDependencies = {
  concatDependencies,
  equalScalarDependencies,
  matrixDependencies,
  notDependencies,
  typedDependencies,
  zerosDependencies,
  createAnd
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAndTransform.generated.js
var andTransformDependencies = {
  addDependencies,
  concatDependencies,
  equalScalarDependencies,
  matrixDependencies,
  notDependencies,
  typedDependencies,
  zerosDependencies,
  createAndTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesArg.generated.js
var argDependencies = {
  typedDependencies,
  createArg
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesArrayNode.generated.js
var ArrayNodeDependencies = {
  NodeDependencies,
  createArrayNode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAsec.generated.js
var asecDependencies = {
  BigNumberDependencies,
  ComplexDependencies,
  typedDependencies,
  createAsec
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAsech.generated.js
var asechDependencies = {
  BigNumberDependencies,
  ComplexDependencies,
  typedDependencies,
  createAsech
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAsin.generated.js
var asinDependencies = {
  ComplexDependencies,
  typedDependencies,
  createAsin
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAsinh.generated.js
var asinhDependencies = {
  typedDependencies,
  createAsinh
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAssignmentNode.generated.js
var AssignmentNodeDependencies = {
  matrixDependencies,
  NodeDependencies,
  subsetDependencies,
  createAssignmentNode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAtan.generated.js
var atanDependencies = {
  typedDependencies,
  createAtan
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAtan2.generated.js
var atan2Dependencies = {
  BigNumberDependencies,
  DenseMatrixDependencies,
  concatDependencies,
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  createAtan2
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAtanh.generated.js
var atanhDependencies = {
  ComplexDependencies,
  typedDependencies,
  createAtanh
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesBignumber.generated.js
var bignumberDependencies = {
  BigNumberDependencies,
  typedDependencies,
  createBignumber
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFraction.generated.js
var fractionDependencies = {
  FractionDependencies,
  typedDependencies,
  createFraction
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesNumber.generated.js
var numberDependencies = {
  typedDependencies,
  createNumber
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesNumeric.generated.js
var numericDependencies = {
  bignumberDependencies,
  fractionDependencies,
  numberDependencies,
  createNumeric
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesDivideScalar.generated.js
var divideScalarDependencies = {
  numericDependencies,
  typedDependencies,
  createDivideScalar
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesEqual.generated.js
var equalDependencies = {
  DenseMatrixDependencies,
  SparseMatrixDependencies,
  concatDependencies,
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  createEqual
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRound.generated.js
var roundDependencies = {
  BigNumberDependencies,
  DenseMatrixDependencies,
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  zerosDependencies,
  createRound
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCeil.generated.js
var ceilDependencies = {
  DenseMatrixDependencies,
  equalScalarDependencies,
  matrixDependencies,
  roundDependencies,
  typedDependencies,
  zerosDependencies,
  createCeil
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFloor.generated.js
var floorDependencies = {
  DenseMatrixDependencies,
  equalScalarDependencies,
  matrixDependencies,
  roundDependencies,
  typedDependencies,
  zerosDependencies,
  createFloor
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFix.generated.js
var fixDependencies = {
  ComplexDependencies,
  DenseMatrixDependencies,
  ceilDependencies,
  equalScalarDependencies,
  floorDependencies,
  matrixDependencies,
  typedDependencies,
  zerosDependencies,
  createFix
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFormat.generated.js
var formatDependencies = {
  typedDependencies,
  createFormat
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesIsNumeric.generated.js
var isNumericDependencies = {
  typedDependencies,
  createIsNumeric
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMultiplyScalar.generated.js
var multiplyScalarDependencies = {
  typedDependencies,
  createMultiplyScalar
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesIdentity.generated.js
var identityDependencies = {
  BigNumberDependencies,
  DenseMatrixDependencies,
  SparseMatrixDependencies,
  matrixDependencies,
  typedDependencies,
  createIdentity
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesIsZero.generated.js
var isZeroDependencies = {
  equalScalarDependencies,
  typedDependencies,
  createIsZero
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesConj.generated.js
var conjDependencies = {
  typedDependencies,
  createConj
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSize.generated.js
var sizeDependencies = {
  matrixDependencies,
  typedDependencies,
  createSize
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesDot.generated.js
var dotDependencies = {
  addScalarDependencies,
  conjDependencies,
  multiplyScalarDependencies,
  sizeDependencies,
  typedDependencies,
  createDot
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMultiply.generated.js
var multiplyDependencies = {
  addScalarDependencies,
  dotDependencies,
  equalScalarDependencies,
  matrixDependencies,
  multiplyScalarDependencies,
  typedDependencies,
  createMultiply
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSubtractScalar.generated.js
var subtractScalarDependencies = {
  typedDependencies,
  createSubtractScalar
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesUnaryMinus.generated.js
var unaryMinusDependencies = {
  typedDependencies,
  createUnaryMinus
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesDet.generated.js
var detDependencies = {
  divideScalarDependencies,
  isZeroDependencies,
  matrixDependencies,
  multiplyDependencies,
  subtractScalarDependencies,
  typedDependencies,
  unaryMinusDependencies,
  createDet
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesInv.generated.js
var invDependencies = {
  absDependencies,
  addScalarDependencies,
  detDependencies,
  divideScalarDependencies,
  identityDependencies,
  matrixDependencies,
  multiplyDependencies,
  typedDependencies,
  unaryMinusDependencies,
  createInv
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesPow.generated.js
var powDependencies = {
  ComplexDependencies,
  fractionDependencies,
  identityDependencies,
  invDependencies,
  matrixDependencies,
  multiplyDependencies,
  numberDependencies,
  typedDependencies,
  createPow
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesUnitClass.generated.js
var UnitDependencies = {
  BigNumberDependencies,
  ComplexDependencies,
  FractionDependencies,
  absDependencies,
  addScalarDependencies,
  divideScalarDependencies,
  equalDependencies,
  fixDependencies,
  formatDependencies,
  isNumericDependencies,
  multiplyScalarDependencies,
  numberDependencies,
  powDependencies,
  roundDependencies,
  subtractScalarDependencies,
  createUnitClass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAtomicMass.generated.js
var atomicMassDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createAtomicMass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesAvogadro.generated.js
var avogadroDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createAvogadro
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesIsNegative.generated.js
var isNegativeDependencies = {
  typedDependencies,
  createIsNegative
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCombinations.generated.js
var combinationsDependencies = {
  typedDependencies,
  createCombinations
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesGamma.generated.js
var gammaDependencies = {
  BigNumberDependencies,
  ComplexDependencies,
  multiplyScalarDependencies,
  powDependencies,
  typedDependencies,
  createGamma
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFactorial.generated.js
var factorialDependencies = {
  gammaDependencies,
  typedDependencies,
  createFactorial
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLarger.generated.js
var largerDependencies = {
  DenseMatrixDependencies,
  SparseMatrixDependencies,
  bignumberDependencies,
  concatDependencies,
  matrixDependencies,
  typedDependencies,
  createLarger
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesStirlingS2.generated.js
var stirlingS2Dependencies = {
  bignumberDependencies,
  addScalarDependencies,
  combinationsDependencies,
  divideScalarDependencies,
  factorialDependencies,
  isIntegerDependencies,
  isNegativeDependencies,
  largerDependencies,
  multiplyScalarDependencies,
  numberDependencies,
  powDependencies,
  subtractScalarDependencies,
  typedDependencies,
  createStirlingS2
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesBellNumbers.generated.js
var bellNumbersDependencies = {
  addScalarDependencies,
  isIntegerDependencies,
  isNegativeDependencies,
  stirlingS2Dependencies,
  typedDependencies,
  createBellNumbers
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesBigint.generated.js
var bigintDependencies = {
  typedDependencies,
  createBigint
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesBin.generated.js
var binDependencies = {
  formatDependencies,
  typedDependencies,
  createBin
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesBitAnd.generated.js
var bitAndDependencies = {
  concatDependencies,
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  createBitAnd
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesBitAndTransform.generated.js
var bitAndTransformDependencies = {
  addDependencies,
  concatDependencies,
  equalScalarDependencies,
  matrixDependencies,
  notDependencies,
  typedDependencies,
  zerosDependencies,
  createBitAndTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesBitNot.generated.js
var bitNotDependencies = {
  typedDependencies,
  createBitNot
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesBitOr.generated.js
var bitOrDependencies = {
  DenseMatrixDependencies,
  concatDependencies,
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  createBitOr
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesBitOrTransform.generated.js
var bitOrTransformDependencies = {
  DenseMatrixDependencies,
  concatDependencies,
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  createBitOrTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesBitXor.generated.js
var bitXorDependencies = {
  DenseMatrixDependencies,
  SparseMatrixDependencies,
  concatDependencies,
  matrixDependencies,
  typedDependencies,
  createBitXor
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesResultSet.generated.js
var ResultSetDependencies = {
  createResultSet
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesBlockNode.generated.js
var BlockNodeDependencies = {
  NodeDependencies,
  ResultSetDependencies,
  createBlockNode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesBohrMagneton.generated.js
var bohrMagnetonDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createBohrMagneton
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesBohrRadius.generated.js
var bohrRadiusDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createBohrRadius
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesBoltzmann.generated.js
var boltzmannDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createBoltzmann
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesBoolean.generated.js
var booleanDependencies = {
  typedDependencies,
  createBoolean
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCatalan.generated.js
var catalanDependencies = {
  addScalarDependencies,
  combinationsDependencies,
  divideScalarDependencies,
  isIntegerDependencies,
  isNegativeDependencies,
  multiplyScalarDependencies,
  typedDependencies,
  createCatalan
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCbrt.generated.js
var cbrtDependencies = {
  BigNumberDependencies,
  ComplexDependencies,
  FractionDependencies,
  isNegativeDependencies,
  matrixDependencies,
  typedDependencies,
  unaryMinusDependencies,
  createCbrt
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesChainClass.generated.js
var ChainDependencies = {
  typedDependencies,
  createChainClass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesChain.generated.js
var chainDependencies = {
  ChainDependencies,
  typedDependencies,
  createChain
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesClassicalElectronRadius.generated.js
var classicalElectronRadiusDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createClassicalElectronRadius
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesClone.generated.js
var cloneDependencies = {
  typedDependencies,
  createClone
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSmaller.generated.js
var smallerDependencies = {
  DenseMatrixDependencies,
  SparseMatrixDependencies,
  bignumberDependencies,
  concatDependencies,
  matrixDependencies,
  typedDependencies,
  createSmaller
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesImmutableDenseMatrixClass.generated.js
var ImmutableDenseMatrixDependencies = {
  DenseMatrixDependencies,
  smallerDependencies,
  createImmutableDenseMatrixClass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesGetMatrixDataType.generated.js
var getMatrixDataTypeDependencies = {
  typedDependencies,
  createGetMatrixDataType
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesIndexClass.generated.js
var IndexDependencies = {
  ImmutableDenseMatrixDependencies,
  getMatrixDataTypeDependencies,
  createIndexClass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesIsPositive.generated.js
var isPositiveDependencies = {
  typedDependencies,
  createIsPositive
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLargerEq.generated.js
var largerEqDependencies = {
  DenseMatrixDependencies,
  SparseMatrixDependencies,
  concatDependencies,
  matrixDependencies,
  typedDependencies,
  createLargerEq
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSmallerEq.generated.js
var smallerEqDependencies = {
  DenseMatrixDependencies,
  SparseMatrixDependencies,
  concatDependencies,
  matrixDependencies,
  typedDependencies,
  createSmallerEq
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRange.generated.js
var rangeDependencies = {
  bignumberDependencies,
  matrixDependencies,
  addDependencies,
  isPositiveDependencies,
  largerDependencies,
  largerEqDependencies,
  smallerDependencies,
  smallerEqDependencies,
  typedDependencies,
  createRange
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesColumn.generated.js
var columnDependencies = {
  IndexDependencies,
  matrixDependencies,
  rangeDependencies,
  typedDependencies,
  createColumn
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesColumnTransform.generated.js
var columnTransformDependencies = {
  IndexDependencies,
  matrixDependencies,
  rangeDependencies,
  typedDependencies,
  createColumnTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCombinationsWithRep.generated.js
var combinationsWithRepDependencies = {
  typedDependencies,
  createCombinationsWithRep
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCompare.generated.js
var compareDependencies = {
  BigNumberDependencies,
  DenseMatrixDependencies,
  FractionDependencies,
  concatDependencies,
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  createCompare
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCompareNatural.generated.js
var compareNaturalDependencies = {
  compareDependencies,
  typedDependencies,
  createCompareNatural
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCompareText.generated.js
var compareTextDependencies = {
  concatDependencies,
  matrixDependencies,
  typedDependencies,
  createCompareText
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesConditionalNode.generated.js
var ConditionalNodeDependencies = {
  NodeDependencies,
  createConditionalNode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesConstantNode.generated.js
var ConstantNodeDependencies = {
  NodeDependencies,
  createConstantNode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFunctionAssignmentNode.generated.js
var FunctionAssignmentNodeDependencies = {
  NodeDependencies,
  typedDependencies,
  createFunctionAssignmentNode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSymbolNode.generated.js
var SymbolNodeDependencies = {
  UnitDependencies,
  NodeDependencies,
  createSymbolNode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFunctionNode.generated.js
var FunctionNodeDependencies = {
  NodeDependencies,
  SymbolNodeDependencies,
  createFunctionNode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesIndexNode.generated.js
var IndexNodeDependencies = {
  NodeDependencies,
  sizeDependencies,
  createIndexNode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesObjectNode.generated.js
var ObjectNodeDependencies = {
  NodeDependencies,
  createObjectNode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesOperatorNode.generated.js
var OperatorNodeDependencies = {
  NodeDependencies,
  createOperatorNode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesParenthesisNode.generated.js
var ParenthesisNodeDependencies = {
  NodeDependencies,
  createParenthesisNode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRangeNode.generated.js
var RangeNodeDependencies = {
  NodeDependencies,
  createRangeNode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRelationalNode.generated.js
var RelationalNodeDependencies = {
  NodeDependencies,
  createRelationalNode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesParse.generated.js
var parseDependencies = {
  AccessorNodeDependencies,
  ArrayNodeDependencies,
  AssignmentNodeDependencies,
  BlockNodeDependencies,
  ConditionalNodeDependencies,
  ConstantNodeDependencies,
  FunctionAssignmentNodeDependencies,
  FunctionNodeDependencies,
  IndexNodeDependencies,
  ObjectNodeDependencies,
  OperatorNodeDependencies,
  ParenthesisNodeDependencies,
  RangeNodeDependencies,
  RelationalNodeDependencies,
  SymbolNodeDependencies,
  numericDependencies,
  typedDependencies,
  createParse
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCompile.generated.js
var compileDependencies = {
  parseDependencies,
  typedDependencies,
  createCompile
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesComplex.generated.js
var complexDependencies = {
  ComplexDependencies,
  typedDependencies,
  createComplex
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesComposition.generated.js
var compositionDependencies = {
  addScalarDependencies,
  combinationsDependencies,
  isIntegerDependencies,
  isNegativeDependencies,
  isPositiveDependencies,
  largerDependencies,
  typedDependencies,
  createComposition
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesConcatTransform.generated.js
var concatTransformDependencies = {
  isIntegerDependencies,
  matrixDependencies,
  typedDependencies,
  createConcatTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesConductanceQuantum.generated.js
var conductanceQuantumDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createConductanceQuantum
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesDivide.generated.js
var divideDependencies = {
  divideScalarDependencies,
  equalScalarDependencies,
  invDependencies,
  matrixDependencies,
  multiplyDependencies,
  typedDependencies,
  createDivide
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMean.generated.js
var meanDependencies = {
  addDependencies,
  divideDependencies,
  typedDependencies,
  createMean
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSqrt.generated.js
var sqrtDependencies = {
  ComplexDependencies,
  typedDependencies,
  createSqrt
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSubtract.generated.js
var subtractDependencies = {
  DenseMatrixDependencies,
  concatDependencies,
  equalScalarDependencies,
  matrixDependencies,
  subtractScalarDependencies,
  typedDependencies,
  unaryMinusDependencies,
  createSubtract
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSum.generated.js
var sumDependencies = {
  addDependencies,
  numericDependencies,
  typedDependencies,
  createSum
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCorr.generated.js
var corrDependencies = {
  addDependencies,
  divideDependencies,
  matrixDependencies,
  meanDependencies,
  multiplyDependencies,
  powDependencies,
  sqrtDependencies,
  subtractDependencies,
  sumDependencies,
  typedDependencies,
  createCorr
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCos.generated.js
var cosDependencies = {
  typedDependencies,
  createCos
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCosh.generated.js
var coshDependencies = {
  typedDependencies,
  createCosh
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCot.generated.js
var cotDependencies = {
  BigNumberDependencies,
  typedDependencies,
  createCot
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCoth.generated.js
var cothDependencies = {
  BigNumberDependencies,
  typedDependencies,
  createCoth
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCoulomb.generated.js
var coulombDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createCoulomb
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesProd.generated.js
var prodDependencies = {
  multiplyScalarDependencies,
  numericDependencies,
  typedDependencies,
  createProd
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCount.generated.js
var countDependencies = {
  prodDependencies,
  sizeDependencies,
  typedDependencies,
  createCount
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCreateUnit.generated.js
var createUnitDependencies = {
  UnitDependencies,
  typedDependencies,
  createCreateUnit
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCross.generated.js
var crossDependencies = {
  matrixDependencies,
  multiplyDependencies,
  subtractDependencies,
  typedDependencies,
  createCross
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCsc.generated.js
var cscDependencies = {
  BigNumberDependencies,
  typedDependencies,
  createCsc
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCsch.generated.js
var cschDependencies = {
  BigNumberDependencies,
  typedDependencies,
  createCsch
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesTranspose.generated.js
var transposeDependencies = {
  matrixDependencies,
  typedDependencies,
  createTranspose
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCtranspose.generated.js
var ctransposeDependencies = {
  conjDependencies,
  transposeDependencies,
  typedDependencies,
  createCtranspose
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCube.generated.js
var cubeDependencies = {
  typedDependencies,
  createCube
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesUnaryPlus.generated.js
var unaryPlusDependencies = {
  numericDependencies,
  typedDependencies,
  createUnaryPlus
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCumSum.generated.js
var cumsumDependencies = {
  addDependencies,
  typedDependencies,
  unaryPlusDependencies,
  createCumSum
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesCumSumTransform.generated.js
var cumsumTransformDependencies = {
  addDependencies,
  typedDependencies,
  unaryPlusDependencies,
  createCumSumTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesDeepEqual.generated.js
var deepEqualDependencies = {
  equalDependencies,
  typedDependencies,
  createDeepEqual
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesReplacer.generated.js
var replacerDependencies = {
  createReplacer
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesResolve.generated.js
var resolveDependencies = {
  ConstantNodeDependencies,
  FunctionNodeDependencies,
  OperatorNodeDependencies,
  ParenthesisNodeDependencies,
  parseDependencies,
  typedDependencies,
  createResolve
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSimplifyConstant.generated.js
var simplifyConstantDependencies = {
  bignumberDependencies,
  fractionDependencies,
  AccessorNodeDependencies,
  ArrayNodeDependencies,
  ConstantNodeDependencies,
  FunctionNodeDependencies,
  IndexNodeDependencies,
  ObjectNodeDependencies,
  OperatorNodeDependencies,
  SymbolNodeDependencies,
  matrixDependencies,
  typedDependencies,
  createSimplifyConstant
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSimplifyCore.generated.js
var simplifyCoreDependencies = {
  AccessorNodeDependencies,
  ArrayNodeDependencies,
  ConstantNodeDependencies,
  FunctionNodeDependencies,
  IndexNodeDependencies,
  ObjectNodeDependencies,
  OperatorNodeDependencies,
  ParenthesisNodeDependencies,
  SymbolNodeDependencies,
  addDependencies,
  divideDependencies,
  equalDependencies,
  isZeroDependencies,
  multiplyDependencies,
  parseDependencies,
  powDependencies,
  subtractDependencies,
  typedDependencies,
  createSimplifyCore
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSimplify.generated.js
var simplifyDependencies = {
  AccessorNodeDependencies,
  ArrayNodeDependencies,
  ConstantNodeDependencies,
  FunctionNodeDependencies,
  IndexNodeDependencies,
  ObjectNodeDependencies,
  OperatorNodeDependencies,
  ParenthesisNodeDependencies,
  SymbolNodeDependencies,
  equalDependencies,
  parseDependencies,
  replacerDependencies,
  resolveDependencies,
  simplifyConstantDependencies,
  simplifyCoreDependencies,
  typedDependencies,
  createSimplify
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesDerivative.generated.js
var derivativeDependencies = {
  ConstantNodeDependencies,
  FunctionNodeDependencies,
  OperatorNodeDependencies,
  ParenthesisNodeDependencies,
  SymbolNodeDependencies,
  equalDependencies,
  isZeroDependencies,
  numericDependencies,
  parseDependencies,
  simplifyDependencies,
  typedDependencies,
  createDerivative
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesDeuteronMass.generated.js
var deuteronMassDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createDeuteronMass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesDiag.generated.js
var diagDependencies = {
  DenseMatrixDependencies,
  SparseMatrixDependencies,
  matrixDependencies,
  typedDependencies,
  createDiag
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesDiff.generated.js
var diffDependencies = {
  matrixDependencies,
  numberDependencies,
  subtractDependencies,
  typedDependencies,
  createDiff
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesDiffTransform.generated.js
var diffTransformDependencies = {
  bignumberDependencies,
  matrixDependencies,
  numberDependencies,
  subtractDependencies,
  typedDependencies,
  createDiffTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesDistance.generated.js
var distanceDependencies = {
  absDependencies,
  addScalarDependencies,
  deepEqualDependencies,
  divideScalarDependencies,
  multiplyScalarDependencies,
  sqrtDependencies,
  subtractScalarDependencies,
  typedDependencies,
  createDistance
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesDotDivide.generated.js
var dotDivideDependencies = {
  DenseMatrixDependencies,
  SparseMatrixDependencies,
  concatDependencies,
  divideScalarDependencies,
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  createDotDivide
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesDotMultiply.generated.js
var dotMultiplyDependencies = {
  concatDependencies,
  equalScalarDependencies,
  matrixDependencies,
  multiplyScalarDependencies,
  typedDependencies,
  createDotMultiply
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesDotPow.generated.js
var dotPowDependencies = {
  DenseMatrixDependencies,
  SparseMatrixDependencies,
  concatDependencies,
  equalScalarDependencies,
  matrixDependencies,
  powDependencies,
  typedDependencies,
  createDotPow
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesE.generated.js
var eDependencies = {
  BigNumberDependencies,
  createE
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesEfimovFactor.generated.js
var efimovFactorDependencies = {
  BigNumberDependencies,
  createEfimovFactor
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFlatten.generated.js
var flattenDependencies = {
  typedDependencies,
  createFlatten
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesIm.generated.js
var imDependencies = {
  typedDependencies,
  createIm
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMatrixFromColumns.generated.js
var matrixFromColumnsDependencies = {
  flattenDependencies,
  matrixDependencies,
  sizeDependencies,
  typedDependencies,
  createMatrixFromColumns
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSign.generated.js
var signDependencies = {
  BigNumberDependencies,
  FractionDependencies,
  complexDependencies,
  typedDependencies,
  createSign
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesQr.generated.js
var qrDependencies = {
  addScalarDependencies,
  complexDependencies,
  conjDependencies,
  divideScalarDependencies,
  equalDependencies,
  identityDependencies,
  isZeroDependencies,
  matrixDependencies,
  multiplyScalarDependencies,
  signDependencies,
  sqrtDependencies,
  subtractScalarDependencies,
  typedDependencies,
  unaryMinusDependencies,
  zerosDependencies,
  createQr
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRe.generated.js
var reDependencies = {
  typedDependencies,
  createRe
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesReshape.generated.js
var reshapeDependencies = {
  isIntegerDependencies,
  matrixDependencies,
  typedDependencies,
  createReshape
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSin.generated.js
var sinDependencies = {
  typedDependencies,
  createSin
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesUsolve.generated.js
var usolveDependencies = {
  DenseMatrixDependencies,
  divideScalarDependencies,
  equalScalarDependencies,
  matrixDependencies,
  multiplyScalarDependencies,
  subtractScalarDependencies,
  typedDependencies,
  createUsolve
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesUsolveAll.generated.js
var usolveAllDependencies = {
  DenseMatrixDependencies,
  divideScalarDependencies,
  equalScalarDependencies,
  matrixDependencies,
  multiplyScalarDependencies,
  subtractScalarDependencies,
  typedDependencies,
  createUsolveAll
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesEigs.generated.js
var eigsDependencies = {
  absDependencies,
  addDependencies,
  addScalarDependencies,
  atanDependencies,
  bignumberDependencies,
  columnDependencies,
  complexDependencies,
  cosDependencies,
  diagDependencies,
  divideScalarDependencies,
  dotDependencies,
  equalDependencies,
  flattenDependencies,
  imDependencies,
  invDependencies,
  largerDependencies,
  matrixDependencies,
  matrixFromColumnsDependencies,
  multiplyDependencies,
  multiplyScalarDependencies,
  numberDependencies,
  qrDependencies,
  reDependencies,
  reshapeDependencies,
  sinDependencies,
  sizeDependencies,
  smallerDependencies,
  sqrtDependencies,
  subtractDependencies,
  typedDependencies,
  usolveDependencies,
  usolveAllDependencies,
  createEigs
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesElectricConstant.generated.js
var electricConstantDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createElectricConstant
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesElectronMass.generated.js
var electronMassDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createElectronMass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesElementaryCharge.generated.js
var elementaryChargeDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createElementaryCharge
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesEqualText.generated.js
var equalTextDependencies = {
  compareTextDependencies,
  isZeroDependencies,
  typedDependencies,
  createEqualText
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesErf.generated.js
var erfDependencies = {
  typedDependencies,
  createErf
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesEvaluate.generated.js
var evaluateDependencies = {
  parseDependencies,
  typedDependencies,
  createEvaluate
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesExp.generated.js
var expDependencies = {
  typedDependencies,
  createExp
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesExpm.generated.js
var expmDependencies = {
  absDependencies,
  addDependencies,
  identityDependencies,
  invDependencies,
  multiplyDependencies,
  typedDependencies,
  createExpm
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesExpm1.generated.js
var expm1Dependencies = {
  ComplexDependencies,
  typedDependencies,
  createExpm1
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFalse.generated.js
var falseDependencies = {
  createFalse
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFaraday.generated.js
var faradayDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createFaraday
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFermiCoupling.generated.js
var fermiCouplingDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createFermiCoupling
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesI.generated.js
var iDependencies = {
  ComplexDependencies,
  createI
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLog2.generated.js
var log2Dependencies = {
  ComplexDependencies,
  typedDependencies,
  createLog2
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesTau.generated.js
var tauDependencies = {
  BigNumberDependencies,
  createTau
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFft.generated.js
var fftDependencies = {
  addScalarDependencies,
  ceilDependencies,
  conjDependencies,
  divideScalarDependencies,
  dotDivideDependencies,
  expDependencies,
  iDependencies,
  log2Dependencies,
  matrixDependencies,
  multiplyScalarDependencies,
  powDependencies,
  tauDependencies,
  typedDependencies,
  createFft
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFibonacciHeapClass.generated.js
var FibonacciHeapDependencies = {
  largerDependencies,
  smallerDependencies,
  createFibonacciHeapClass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFilter.generated.js
var filterDependencies = {
  typedDependencies,
  createFilter
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFilterTransform.generated.js
var filterTransformDependencies = {
  typedDependencies,
  createFilterTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFineStructure.generated.js
var fineStructureDependencies = {
  BigNumberDependencies,
  createFineStructure
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFirstRadiation.generated.js
var firstRadiationDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createFirstRadiation
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesForEach.generated.js
var forEachDependencies = {
  typedDependencies,
  createForEach
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesForEachTransform.generated.js
var forEachTransformDependencies = {
  typedDependencies,
  createForEachTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesFreqz.generated.js
var freqzDependencies = {
  ComplexDependencies,
  addDependencies,
  divideDependencies,
  matrixDependencies,
  multiplyDependencies,
  typedDependencies,
  createFreqz
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesGasConstant.generated.js
var gasConstantDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createGasConstant
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesGcd.generated.js
var gcdDependencies = {
  BigNumberDependencies,
  DenseMatrixDependencies,
  concatDependencies,
  equalScalarDependencies,
  matrixDependencies,
  roundDependencies,
  typedDependencies,
  zerosDependencies,
  createGcd
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesGravitationConstant.generated.js
var gravitationConstantDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createGravitationConstant
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesGravity.generated.js
var gravityDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createGravity
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesHartreeEnergy.generated.js
var hartreeEnergyDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createHartreeEnergy
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesHasNumericValue.generated.js
var hasNumericValueDependencies = {
  isNumericDependencies,
  typedDependencies,
  createHasNumericValue
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesHelpClass.generated.js
var HelpDependencies = {
  evaluateDependencies,
  createHelpClass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesHelp.generated.js
var helpDependencies = {
  HelpDependencies,
  typedDependencies,
  createHelp
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesHex.generated.js
var hexDependencies = {
  formatDependencies,
  typedDependencies,
  createHex
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesHypot.generated.js
var hypotDependencies = {
  absDependencies,
  addScalarDependencies,
  divideScalarDependencies,
  isPositiveDependencies,
  multiplyScalarDependencies,
  smallerDependencies,
  sqrtDependencies,
  typedDependencies,
  createHypot
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesIfft.generated.js
var ifftDependencies = {
  conjDependencies,
  dotDivideDependencies,
  fftDependencies,
  typedDependencies,
  createIfft
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesIndex.generated.js
var indexDependencies = {
  IndexDependencies,
  typedDependencies,
  createIndex
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesIndexTransform.generated.js
var indexTransformDependencies = {
  IndexDependencies,
  getMatrixDataTypeDependencies,
  createIndexTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesInfinity.generated.js
var InfinityDependencies = {
  BigNumberDependencies,
  createInfinity
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesIntersect.generated.js
var intersectDependencies = {
  absDependencies,
  addDependencies,
  addScalarDependencies,
  divideScalarDependencies,
  equalScalarDependencies,
  flattenDependencies,
  isNumericDependencies,
  isZeroDependencies,
  matrixDependencies,
  multiplyDependencies,
  multiplyScalarDependencies,
  smallerDependencies,
  subtractDependencies,
  typedDependencies,
  createIntersect
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesInverseConductanceQuantum.generated.js
var inverseConductanceQuantumDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createInverseConductanceQuantum
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMod.generated.js
var modDependencies = {
  DenseMatrixDependencies,
  concatDependencies,
  equalScalarDependencies,
  matrixDependencies,
  roundDependencies,
  typedDependencies,
  zerosDependencies,
  createMod
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesXgcd.generated.js
var xgcdDependencies = {
  BigNumberDependencies,
  matrixDependencies,
  typedDependencies,
  createXgcd
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesInvmod.generated.js
var invmodDependencies = {
  BigNumberDependencies,
  addDependencies,
  equalDependencies,
  isIntegerDependencies,
  modDependencies,
  smallerDependencies,
  typedDependencies,
  xgcdDependencies,
  createInvmod
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesIsNaN.generated.js
var isNaNDependencies = {
  typedDependencies,
  createIsNaN
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesIsPrime.generated.js
var isPrimeDependencies = {
  typedDependencies,
  createIsPrime
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesTypeOf.generated.js
var typeOfDependencies = {
  typedDependencies,
  createTypeOf
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLog.generated.js
var logDependencies = {
  ComplexDependencies,
  divideScalarDependencies,
  typeOfDependencies,
  typedDependencies,
  createLog
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMap.generated.js
var mapDependencies = {
  typedDependencies,
  createMap
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesKldivergence.generated.js
var kldivergenceDependencies = {
  divideDependencies,
  dotDivideDependencies,
  isNumericDependencies,
  logDependencies,
  mapDependencies,
  matrixDependencies,
  multiplyDependencies,
  sumDependencies,
  typedDependencies,
  createKldivergence
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesKlitzing.generated.js
var klitzingDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createKlitzing
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesKron.generated.js
var kronDependencies = {
  matrixDependencies,
  multiplyScalarDependencies,
  typedDependencies,
  createKron
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLN10.generated.js
var LN10Dependencies = {
  BigNumberDependencies,
  createLN10
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLN2.generated.js
var LN2Dependencies = {
  BigNumberDependencies,
  createLN2
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLOG10E.generated.js
var LOG10EDependencies = {
  BigNumberDependencies,
  createLOG10E
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLOG2E.generated.js
var LOG2EDependencies = {
  BigNumberDependencies,
  createLOG2E
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLcm.generated.js
var lcmDependencies = {
  concatDependencies,
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  createLcm
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLeafCount.generated.js
var leafCountDependencies = {
  parseDependencies,
  typedDependencies,
  createLeafCount
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLeftShift.generated.js
var leftShiftDependencies = {
  DenseMatrixDependencies,
  concatDependencies,
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  zerosDependencies,
  createLeftShift
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLgamma.generated.js
var lgammaDependencies = {
  ComplexDependencies,
  typedDependencies,
  createLgamma
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLog10.generated.js
var log10Dependencies = {
  ComplexDependencies,
  typedDependencies,
  createLog10
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLog1p.generated.js
var log1pDependencies = {
  ComplexDependencies,
  divideScalarDependencies,
  logDependencies,
  typedDependencies,
  createLog1p
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLoschmidt.generated.js
var loschmidtDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createLoschmidt
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLsolve.generated.js
var lsolveDependencies = {
  DenseMatrixDependencies,
  divideScalarDependencies,
  equalScalarDependencies,
  matrixDependencies,
  multiplyScalarDependencies,
  subtractScalarDependencies,
  typedDependencies,
  createLsolve
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLsolveAll.generated.js
var lsolveAllDependencies = {
  DenseMatrixDependencies,
  divideScalarDependencies,
  equalScalarDependencies,
  matrixDependencies,
  multiplyScalarDependencies,
  subtractScalarDependencies,
  typedDependencies,
  createLsolveAll
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSpaClass.generated.js
var SpaDependencies = {
  FibonacciHeapDependencies,
  addScalarDependencies,
  equalScalarDependencies,
  createSpaClass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLup.generated.js
var lupDependencies = {
  DenseMatrixDependencies,
  SpaDependencies,
  SparseMatrixDependencies,
  absDependencies,
  addScalarDependencies,
  divideScalarDependencies,
  equalScalarDependencies,
  largerDependencies,
  matrixDependencies,
  multiplyScalarDependencies,
  subtractScalarDependencies,
  typedDependencies,
  unaryMinusDependencies,
  createLup
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSlu.generated.js
var sluDependencies = {
  SparseMatrixDependencies,
  absDependencies,
  addDependencies,
  divideScalarDependencies,
  largerDependencies,
  largerEqDependencies,
  multiplyDependencies,
  subtractDependencies,
  transposeDependencies,
  typedDependencies,
  createSlu
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLusolve.generated.js
var lusolveDependencies = {
  DenseMatrixDependencies,
  lsolveDependencies,
  lupDependencies,
  matrixDependencies,
  sluDependencies,
  typedDependencies,
  usolveDependencies,
  createLusolve
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesNorm.generated.js
var normDependencies = {
  absDependencies,
  addDependencies,
  conjDependencies,
  ctransposeDependencies,
  eigsDependencies,
  equalScalarDependencies,
  largerDependencies,
  matrixDependencies,
  multiplyDependencies,
  powDependencies,
  smallerDependencies,
  sqrtDependencies,
  typedDependencies,
  createNorm
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSchur.generated.js
var schurDependencies = {
  identityDependencies,
  matrixDependencies,
  multiplyDependencies,
  normDependencies,
  qrDependencies,
  subtractDependencies,
  typedDependencies,
  createSchur
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSylvester.generated.js
var sylvesterDependencies = {
  absDependencies,
  addDependencies,
  concatDependencies,
  identityDependencies,
  indexDependencies,
  lusolveDependencies,
  matrixDependencies,
  matrixFromColumnsDependencies,
  multiplyDependencies,
  rangeDependencies,
  schurDependencies,
  subsetDependencies,
  subtractDependencies,
  transposeDependencies,
  typedDependencies,
  createSylvester
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesLyap.generated.js
var lyapDependencies = {
  matrixDependencies,
  multiplyDependencies,
  sylvesterDependencies,
  transposeDependencies,
  typedDependencies,
  createLyap
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesPartitionSelect.generated.js
var partitionSelectDependencies = {
  compareDependencies,
  isNaNDependencies,
  isNumericDependencies,
  typedDependencies,
  createPartitionSelect
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMedian.generated.js
var medianDependencies = {
  addDependencies,
  compareDependencies,
  divideDependencies,
  partitionSelectDependencies,
  typedDependencies,
  createMedian
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMad.generated.js
var madDependencies = {
  absDependencies,
  mapDependencies,
  medianDependencies,
  subtractDependencies,
  typedDependencies,
  createMad
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMagneticConstant.generated.js
var magneticConstantDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createMagneticConstant
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMagneticFluxQuantum.generated.js
var magneticFluxQuantumDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createMagneticFluxQuantum
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMapSlices.generated.js
var mapSlicesDependencies = {
  isIntegerDependencies,
  typedDependencies,
  createMapSlices
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMapSlicesTransform.generated.js
var mapSlicesTransformDependencies = {
  isIntegerDependencies,
  typedDependencies,
  createMapSlicesTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMapTransform.generated.js
var mapTransformDependencies = {
  typedDependencies,
  createMapTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMatrixFromFunction.generated.js
var matrixFromFunctionDependencies = {
  isZeroDependencies,
  matrixDependencies,
  typedDependencies,
  createMatrixFromFunction
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMatrixFromRows.generated.js
var matrixFromRowsDependencies = {
  flattenDependencies,
  matrixDependencies,
  sizeDependencies,
  typedDependencies,
  createMatrixFromRows
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMax.generated.js
var maxDependencies = {
  isNaNDependencies,
  largerDependencies,
  numericDependencies,
  typedDependencies,
  createMax
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMaxTransform.generated.js
var maxTransformDependencies = {
  isNaNDependencies,
  largerDependencies,
  numericDependencies,
  typedDependencies,
  createMaxTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMeanTransform.generated.js
var meanTransformDependencies = {
  addDependencies,
  divideDependencies,
  typedDependencies,
  createMeanTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMin.generated.js
var minDependencies = {
  isNaNDependencies,
  numericDependencies,
  smallerDependencies,
  typedDependencies,
  createMin
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMinTransform.generated.js
var minTransformDependencies = {
  isNaNDependencies,
  numericDependencies,
  smallerDependencies,
  typedDependencies,
  createMinTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMode.generated.js
var modeDependencies = {
  isNaNDependencies,
  isNumericDependencies,
  typedDependencies,
  createMode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMolarMass.generated.js
var molarMassDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createMolarMass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMolarMassC12.generated.js
var molarMassC12Dependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createMolarMassC12
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMolarPlanckConstant.generated.js
var molarPlanckConstantDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createMolarPlanckConstant
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMolarVolume.generated.js
var molarVolumeDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createMolarVolume
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesMultinomial.generated.js
var multinomialDependencies = {
  addDependencies,
  divideDependencies,
  factorialDependencies,
  isIntegerDependencies,
  isPositiveDependencies,
  multiplyDependencies,
  typedDependencies,
  createMultinomial
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesNaN.generated.js
var NaNDependencies = {
  BigNumberDependencies,
  createNaN
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesNeutronMass.generated.js
var neutronMassDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createNeutronMass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesNthRoot.generated.js
var nthRootDependencies = {
  BigNumberDependencies,
  concatDependencies,
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  createNthRoot
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesNthRoots.generated.js
var nthRootsDependencies = {
  ComplexDependencies,
  divideScalarDependencies,
  typedDependencies,
  createNthRoots
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesNuclearMagneton.generated.js
var nuclearMagnetonDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createNuclearMagneton
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesNull.generated.js
var nullDependencies = {
  createNull
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesOct.generated.js
var octDependencies = {
  formatDependencies,
  typedDependencies,
  createOct
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesOnes.generated.js
var onesDependencies = {
  BigNumberDependencies,
  matrixDependencies,
  typedDependencies,
  createOnes
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesOr.generated.js
var orDependencies = {
  DenseMatrixDependencies,
  concatDependencies,
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  createOr
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesOrTransform.generated.js
var orTransformDependencies = {
  DenseMatrixDependencies,
  concatDependencies,
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  createOrTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesParserClass.generated.js
var ParserDependencies = {
  evaluateDependencies,
  parseDependencies,
  createParserClass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesParser.generated.js
var parserDependencies = {
  ParserDependencies,
  typedDependencies,
  createParser
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesPermutations.generated.js
var permutationsDependencies = {
  factorialDependencies,
  typedDependencies,
  createPermutations
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesPhi.generated.js
var phiDependencies = {
  BigNumberDependencies,
  createPhi
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesPi.generated.js
var piDependencies = {
  BigNumberDependencies,
  createPi
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesPickRandom.generated.js
var pickRandomDependencies = {
  typedDependencies,
  createPickRandom
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesPinv.generated.js
var pinvDependencies = {
  ComplexDependencies,
  addDependencies,
  ctransposeDependencies,
  deepEqualDependencies,
  divideScalarDependencies,
  dotDependencies,
  dotDivideDependencies,
  equalDependencies,
  invDependencies,
  matrixDependencies,
  multiplyDependencies,
  typedDependencies,
  createPinv
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesPlanckCharge.generated.js
var planckChargeDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createPlanckCharge
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesPlanckConstant.generated.js
var planckConstantDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createPlanckConstant
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesPlanckLength.generated.js
var planckLengthDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createPlanckLength
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesPlanckMass.generated.js
var planckMassDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createPlanckMass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesPlanckTemperature.generated.js
var planckTemperatureDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createPlanckTemperature
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesPlanckTime.generated.js
var planckTimeDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createPlanckTime
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesPolynomialRoot.generated.js
var polynomialRootDependencies = {
  addDependencies,
  cbrtDependencies,
  divideDependencies,
  equalScalarDependencies,
  imDependencies,
  isZeroDependencies,
  multiplyDependencies,
  reDependencies,
  sqrtDependencies,
  subtractDependencies,
  typeOfDependencies,
  typedDependencies,
  unaryMinusDependencies,
  createPolynomialRoot
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesPrint.generated.js
var printDependencies = {
  typedDependencies,
  createPrint
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesPrintTransform.generated.js
var printTransformDependencies = {
  addDependencies,
  matrixDependencies,
  typedDependencies,
  zerosDependencies,
  createPrintTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesProtonMass.generated.js
var protonMassDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createProtonMass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesQuantileSeq.generated.js
var quantileSeqDependencies = {
  bignumberDependencies,
  addDependencies,
  compareDependencies,
  divideDependencies,
  isIntegerDependencies,
  largerDependencies,
  mapSlicesDependencies,
  multiplyDependencies,
  partitionSelectDependencies,
  smallerDependencies,
  smallerEqDependencies,
  subtractDependencies,
  typedDependencies,
  createQuantileSeq
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesQuantileSeqTransform.generated.js
var quantileSeqTransformDependencies = {
  addDependencies,
  bignumberDependencies,
  compareDependencies,
  divideDependencies,
  isIntegerDependencies,
  largerDependencies,
  mapSlicesDependencies,
  multiplyDependencies,
  partitionSelectDependencies,
  smallerDependencies,
  smallerEqDependencies,
  subtractDependencies,
  typedDependencies,
  createQuantileSeqTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesQuantumOfCirculation.generated.js
var quantumOfCirculationDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createQuantumOfCirculation
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRandom.generated.js
var randomDependencies = {
  typedDependencies,
  createRandom
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRandomInt.generated.js
var randomIntDependencies = {
  log2Dependencies,
  typedDependencies,
  createRandomInt
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRangeClass.generated.js
var RangeDependencies = {
  createRangeClass
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRangeTransform.generated.js
var rangeTransformDependencies = {
  bignumberDependencies,
  matrixDependencies,
  addDependencies,
  isPositiveDependencies,
  largerDependencies,
  largerEqDependencies,
  smallerDependencies,
  smallerEqDependencies,
  typedDependencies,
  createRangeTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRationalize.generated.js
var rationalizeDependencies = {
  bignumberDependencies,
  fractionDependencies,
  AccessorNodeDependencies,
  ArrayNodeDependencies,
  ConstantNodeDependencies,
  FunctionNodeDependencies,
  IndexNodeDependencies,
  ObjectNodeDependencies,
  OperatorNodeDependencies,
  ParenthesisNodeDependencies,
  SymbolNodeDependencies,
  addDependencies,
  divideDependencies,
  equalDependencies,
  isZeroDependencies,
  matrixDependencies,
  multiplyDependencies,
  parseDependencies,
  powDependencies,
  simplifyDependencies,
  simplifyConstantDependencies,
  simplifyCoreDependencies,
  subtractDependencies,
  typedDependencies,
  createRationalize
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesReducedPlanckConstant.generated.js
var reducedPlanckConstantDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createReducedPlanckConstant
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesResize.generated.js
var resizeDependencies = {
  matrixDependencies,
  createResize
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesReviver.generated.js
var reviverDependencies = {
  createReviver
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRightArithShift.generated.js
var rightArithShiftDependencies = {
  DenseMatrixDependencies,
  concatDependencies,
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  zerosDependencies,
  createRightArithShift
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRightLogShift.generated.js
var rightLogShiftDependencies = {
  DenseMatrixDependencies,
  concatDependencies,
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  zerosDependencies,
  createRightLogShift
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRotationMatrix.generated.js
var rotationMatrixDependencies = {
  BigNumberDependencies,
  DenseMatrixDependencies,
  SparseMatrixDependencies,
  addScalarDependencies,
  cosDependencies,
  matrixDependencies,
  multiplyScalarDependencies,
  normDependencies,
  sinDependencies,
  typedDependencies,
  unaryMinusDependencies,
  createRotationMatrix
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRotate.generated.js
var rotateDependencies = {
  multiplyDependencies,
  rotationMatrixDependencies,
  typedDependencies,
  createRotate
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRow.generated.js
var rowDependencies = {
  IndexDependencies,
  matrixDependencies,
  rangeDependencies,
  typedDependencies,
  createRow
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRowTransform.generated.js
var rowTransformDependencies = {
  IndexDependencies,
  matrixDependencies,
  rangeDependencies,
  typedDependencies,
  createRowTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesRydberg.generated.js
var rydbergDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createRydberg
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSQRT1_2.generated.js
var SQRT1_2Dependencies = {
  // eslint-disable-line camelcase
  BigNumberDependencies,
  createSQRT1_2
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSQRT2.generated.js
var SQRT2Dependencies = {
  BigNumberDependencies,
  createSQRT2
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSackurTetrode.generated.js
var sackurTetrodeDependencies = {
  BigNumberDependencies,
  createSackurTetrode
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSec.generated.js
var secDependencies = {
  BigNumberDependencies,
  typedDependencies,
  createSec
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSech.generated.js
var sechDependencies = {
  BigNumberDependencies,
  typedDependencies,
  createSech
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSecondRadiation.generated.js
var secondRadiationDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createSecondRadiation
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSetCartesian.generated.js
var setCartesianDependencies = {
  DenseMatrixDependencies,
  IndexDependencies,
  compareNaturalDependencies,
  sizeDependencies,
  subsetDependencies,
  typedDependencies,
  createSetCartesian
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSetDifference.generated.js
var setDifferenceDependencies = {
  DenseMatrixDependencies,
  IndexDependencies,
  compareNaturalDependencies,
  sizeDependencies,
  subsetDependencies,
  typedDependencies,
  createSetDifference
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSetDistinct.generated.js
var setDistinctDependencies = {
  DenseMatrixDependencies,
  IndexDependencies,
  compareNaturalDependencies,
  sizeDependencies,
  subsetDependencies,
  typedDependencies,
  createSetDistinct
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSetIntersect.generated.js
var setIntersectDependencies = {
  DenseMatrixDependencies,
  IndexDependencies,
  compareNaturalDependencies,
  sizeDependencies,
  subsetDependencies,
  typedDependencies,
  createSetIntersect
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSetIsSubset.generated.js
var setIsSubsetDependencies = {
  IndexDependencies,
  compareNaturalDependencies,
  sizeDependencies,
  subsetDependencies,
  typedDependencies,
  createSetIsSubset
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSetMultiplicity.generated.js
var setMultiplicityDependencies = {
  IndexDependencies,
  compareNaturalDependencies,
  sizeDependencies,
  subsetDependencies,
  typedDependencies,
  createSetMultiplicity
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSetPowerset.generated.js
var setPowersetDependencies = {
  IndexDependencies,
  compareNaturalDependencies,
  sizeDependencies,
  subsetDependencies,
  typedDependencies,
  createSetPowerset
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSetSize.generated.js
var setSizeDependencies = {
  compareNaturalDependencies,
  typedDependencies,
  createSetSize
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSetSymDifference.generated.js
var setSymDifferenceDependencies = {
  IndexDependencies,
  concatDependencies,
  setDifferenceDependencies,
  sizeDependencies,
  subsetDependencies,
  typedDependencies,
  createSetSymDifference
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSetUnion.generated.js
var setUnionDependencies = {
  IndexDependencies,
  concatDependencies,
  setIntersectDependencies,
  setSymDifferenceDependencies,
  sizeDependencies,
  subsetDependencies,
  typedDependencies,
  createSetUnion
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSinh.generated.js
var sinhDependencies = {
  typedDependencies,
  createSinh
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSolveODE.generated.js
var solveODEDependencies = {
  absDependencies,
  addDependencies,
  bignumberDependencies,
  divideDependencies,
  isNegativeDependencies,
  isPositiveDependencies,
  largerDependencies,
  mapDependencies,
  matrixDependencies,
  maxDependencies,
  multiplyDependencies,
  smallerDependencies,
  subtractDependencies,
  typedDependencies,
  unaryMinusDependencies,
  createSolveODE
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSort.generated.js
var sortDependencies = {
  compareDependencies,
  compareNaturalDependencies,
  matrixDependencies,
  typedDependencies,
  createSort
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSparse.generated.js
var sparseDependencies = {
  SparseMatrixDependencies,
  typedDependencies,
  createSparse
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSpeedOfLight.generated.js
var speedOfLightDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createSpeedOfLight
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSplitUnit.generated.js
var splitUnitDependencies = {
  typedDependencies,
  createSplitUnit
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSqrtm.generated.js
var sqrtmDependencies = {
  absDependencies,
  addDependencies,
  identityDependencies,
  invDependencies,
  mapDependencies,
  maxDependencies,
  multiplyDependencies,
  sizeDependencies,
  sqrtDependencies,
  subtractDependencies,
  typedDependencies,
  createSqrtm
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSquare.generated.js
var squareDependencies = {
  typedDependencies,
  createSquare
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSqueeze.generated.js
var squeezeDependencies = {
  typedDependencies,
  createSqueeze
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesVariance.generated.js
var varianceDependencies = {
  addDependencies,
  divideDependencies,
  isNaNDependencies,
  mapSlicesDependencies,
  multiplyDependencies,
  subtractDependencies,
  typedDependencies,
  createVariance
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesStd.generated.js
var stdDependencies = {
  mapDependencies,
  sqrtDependencies,
  typedDependencies,
  varianceDependencies,
  createStd
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesStdTransform.generated.js
var stdTransformDependencies = {
  mapDependencies,
  sqrtDependencies,
  typedDependencies,
  varianceDependencies,
  createStdTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesStefanBoltzmann.generated.js
var stefanBoltzmannDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createStefanBoltzmann
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesString.generated.js
var stringDependencies = {
  typedDependencies,
  createString
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSubsetTransform.generated.js
var subsetTransformDependencies = {
  addDependencies,
  matrixDependencies,
  typedDependencies,
  zerosDependencies,
  createSubsetTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSumTransform.generated.js
var sumTransformDependencies = {
  addDependencies,
  numericDependencies,
  typedDependencies,
  createSumTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesSymbolicEqual.generated.js
var symbolicEqualDependencies = {
  OperatorNodeDependencies,
  parseDependencies,
  simplifyDependencies,
  typedDependencies,
  createSymbolicEqual
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesTan.generated.js
var tanDependencies = {
  typedDependencies,
  createTan
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesTanh.generated.js
var tanhDependencies = {
  typedDependencies,
  createTanh
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesThomsonCrossSection.generated.js
var thomsonCrossSectionDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createThomsonCrossSection
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesTo.generated.js
var toDependencies = {
  concatDependencies,
  matrixDependencies,
  typedDependencies,
  createTo
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesTrace.generated.js
var traceDependencies = {
  addDependencies,
  matrixDependencies,
  typedDependencies,
  createTrace
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesTrue.generated.js
var trueDependencies = {
  createTrue
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesUnequal.generated.js
var unequalDependencies = {
  DenseMatrixDependencies,
  SparseMatrixDependencies,
  concatDependencies,
  equalScalarDependencies,
  matrixDependencies,
  typedDependencies,
  createUnequal
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesUnitFunction.generated.js
var unitDependencies = {
  UnitDependencies,
  typedDependencies,
  createUnitFunction
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesUppercaseE.generated.js
var EDependencies = {
  eDependencies,
  createUppercaseE
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesUppercasePi.generated.js
var PIDependencies = {
  piDependencies,
  createUppercasePi
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesVacuumImpedance.generated.js
var vacuumImpedanceDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createVacuumImpedance
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesVarianceTransform.generated.js
var varianceTransformDependencies = {
  addDependencies,
  divideDependencies,
  isNaNDependencies,
  mapSlicesDependencies,
  multiplyDependencies,
  subtractDependencies,
  typedDependencies,
  createVarianceTransform
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesVersion.generated.js
var versionDependencies = {
  createVersion
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesWeakMixingAngle.generated.js
var weakMixingAngleDependencies = {
  BigNumberDependencies,
  createWeakMixingAngle
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesWienDisplacement.generated.js
var wienDisplacementDependencies = {
  BigNumberDependencies,
  UnitDependencies,
  createWienDisplacement
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesXor.generated.js
var xorDependencies = {
  DenseMatrixDependencies,
  SparseMatrixDependencies,
  concatDependencies,
  matrixDependencies,
  typedDependencies,
  createXor
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesZeta.generated.js
var zetaDependencies = {
  BigNumberDependencies,
  ComplexDependencies,
  addDependencies,
  divideDependencies,
  equalDependencies,
  factorialDependencies,
  gammaDependencies,
  isNegativeDependencies,
  multiplyDependencies,
  piDependencies,
  powDependencies,
  sinDependencies,
  smallerEqDependencies,
  subtractDependencies,
  typedDependencies,
  createZeta
};

// node_modules/mathjs/lib/esm/entry/dependenciesAny/dependenciesZpk2tf.generated.js
var zpk2tfDependencies = {
  ComplexDependencies,
  addDependencies,
  multiplyDependencies,
  numberDependencies,
  typedDependencies,
  createZpk2tf
};

// node_modules/mathjs/lib/esm/entry/allFactoriesAny.js
var all = factoriesAny_exports;
export {
  AccessorNode,
  AccessorNodeDependencies,
  ArgumentsError,
  ArrayNode,
  ArrayNodeDependencies,
  AssignmentNode,
  AssignmentNodeDependencies,
  BigNumber,
  BigNumberDependencies,
  BlockNode,
  BlockNodeDependencies,
  Chain,
  ChainDependencies,
  Complex2 as Complex,
  ComplexDependencies,
  ConditionalNode,
  ConditionalNodeDependencies,
  ConstantNode,
  ConstantNodeDependencies,
  DenseMatrix,
  DenseMatrixDependencies,
  DimensionError,
  EDependencies,
  FibonacciHeap,
  FibonacciHeapDependencies,
  Fraction2 as Fraction,
  FractionDependencies,
  FunctionAssignmentNode,
  FunctionAssignmentNodeDependencies,
  FunctionNode,
  FunctionNodeDependencies,
  Help,
  HelpDependencies,
  ImmutableDenseMatrix,
  ImmutableDenseMatrixDependencies,
  Index,
  IndexDependencies,
  IndexError,
  IndexNode,
  IndexNodeDependencies,
  InfinityDependencies,
  LN10,
  LN10Dependencies,
  LN2,
  LN2Dependencies,
  LOG10E,
  LOG10EDependencies,
  LOG2E,
  LOG2EDependencies,
  Matrix,
  MatrixDependencies,
  NaNDependencies,
  Node,
  NodeDependencies,
  ObjectNode,
  ObjectNodeDependencies,
  OperatorNode,
  OperatorNodeDependencies,
  PIDependencies,
  ParenthesisNode,
  ParenthesisNodeDependencies,
  Parser,
  ParserDependencies,
  Range,
  RangeDependencies,
  RangeNode,
  RangeNodeDependencies,
  RelationalNode,
  RelationalNodeDependencies,
  ResultSet,
  ResultSetDependencies,
  SQRT1_2,
  SQRT1_2Dependencies,
  SQRT2,
  SQRT2Dependencies,
  Spa,
  SpaDependencies,
  SparseMatrix,
  SparseMatrixDependencies,
  SymbolNode,
  SymbolNodeDependencies,
  Unit,
  UnitDependencies,
  _Infinity,
  _NaN,
  _false,
  _null,
  _true,
  abs,
  absDependencies,
  acos,
  acosDependencies,
  acosh,
  acoshDependencies,
  acot,
  acotDependencies,
  acoth,
  acothDependencies,
  acsc,
  acscDependencies,
  acsch,
  acschDependencies,
  add,
  addDependencies,
  addScalar,
  addScalarDependencies,
  all,
  and,
  andDependencies,
  andTransformDependencies,
  apply,
  arg,
  argDependencies,
  asec,
  asecDependencies,
  asech,
  asechDependencies,
  asin,
  asinDependencies,
  asinh,
  asinhDependencies,
  atan,
  atan2,
  atan2Dependencies,
  atanDependencies,
  atanh,
  atanhDependencies,
  atomicMass,
  atomicMassDependencies,
  avogadro,
  avogadroDependencies,
  bellNumbers,
  bellNumbersDependencies,
  bigint,
  bigintDependencies,
  bignumber,
  bignumberDependencies,
  bin,
  binDependencies,
  bitAnd,
  bitAndDependencies,
  bitAndTransformDependencies,
  bitNot,
  bitNotDependencies,
  bitOr,
  bitOrDependencies,
  bitOrTransformDependencies,
  bitXor2 as bitXor,
  bitXorDependencies,
  bohrMagneton,
  bohrMagnetonDependencies,
  bohrRadius,
  bohrRadiusDependencies,
  boltzmann,
  boltzmannDependencies,
  boolean,
  booleanDependencies,
  catalan,
  catalanDependencies,
  cbrt,
  cbrtDependencies,
  ceil,
  ceilDependencies,
  chain,
  chainDependencies,
  classicalElectronRadius,
  classicalElectronRadiusDependencies,
  clone2 as clone,
  cloneDependencies,
  column,
  columnDependencies,
  columnTransformDependencies,
  combinations,
  combinationsDependencies,
  combinationsWithRep,
  combinationsWithRepDependencies,
  compare,
  compareDependencies,
  compareNatural,
  compareNaturalDependencies,
  compareText,
  compareTextDependencies,
  compile,
  compileDependencies,
  complex,
  complexDependencies,
  composition,
  compositionDependencies,
  concat2 as concat,
  concatDependencies,
  concatTransformDependencies,
  conductanceQuantum,
  conductanceQuantumDependencies,
  config,
  conj,
  conjDependencies,
  corr,
  corrDependencies,
  cos,
  cosDependencies,
  cosh3 as cosh,
  coshDependencies,
  cot,
  cotDependencies,
  coth,
  cothDependencies,
  coulomb,
  coulombDependencies,
  count,
  countDependencies,
  create,
  createAbs,
  createAccessorNode,
  createAcos,
  createAcosh,
  createAcot,
  createAcoth,
  createAcsc,
  createAcsch,
  createAdd,
  createAddScalar,
  createAnd,
  createAndTransform,
  createArg,
  createArrayNode,
  createAsec,
  createAsech,
  createAsin,
  createAsinh,
  createAssignmentNode,
  createAtan,
  createAtan2,
  createAtanh,
  createAtomicMass,
  createAvogadro,
  createBellNumbers,
  createBigNumberClass,
  createBigint,
  createBignumber,
  createBin,
  createBitAnd,
  createBitAndTransform,
  createBitNot,
  createBitOr,
  createBitOrTransform,
  createBitXor,
  createBlockNode,
  createBohrMagneton,
  createBohrRadius,
  createBoltzmann,
  createBoolean,
  createCatalan,
  createCbrt,
  createCeil,
  createChain,
  createChainClass,
  createClassicalElectronRadius,
  createClone,
  createColumn,
  createColumnTransform,
  createCombinations,
  createCombinationsWithRep,
  createCompare,
  createCompareNatural,
  createCompareText,
  createCompile,
  createComplex,
  createComplexClass,
  createComposition,
  createConcat,
  createConcatTransform,
  createConditionalNode,
  createConductanceQuantum,
  createConj,
  createConstantNode,
  createCorr,
  createCos,
  createCosh,
  createCot,
  createCoth,
  createCoulomb,
  createCount,
  createCreateUnit,
  createCross,
  createCsc,
  createCsch,
  createCtranspose,
  createCube,
  createCumSum,
  createCumSumTransform,
  createDeepEqual,
  createDenseMatrixClass,
  createDerivative,
  createDet,
  createDeuteronMass,
  createDiag,
  createDiff,
  createDiffTransform,
  createDistance,
  createDivide,
  createDivideScalar,
  createDot,
  createDotDivide,
  createDotMultiply,
  createDotPow,
  createE,
  createEfimovFactor,
  createEigs,
  createElectricConstant,
  createElectronMass,
  createElementaryCharge,
  createEqual,
  createEqualScalar,
  createEqualText,
  createErf,
  createEvaluate,
  createExp,
  createExpm,
  createExpm1,
  createFactorial,
  createFalse,
  createFaraday,
  createFermiCoupling,
  createFft,
  createFibonacciHeapClass,
  createFilter,
  createFilterTransform,
  createFineStructure,
  createFirstRadiation,
  createFix,
  createFlatten,
  createFloor,
  createForEach,
  createForEachTransform,
  createFormat,
  createFraction,
  createFractionClass,
  createFreqz,
  createFunctionAssignmentNode,
  createFunctionNode,
  createGamma,
  createGasConstant,
  createGcd,
  createGetMatrixDataType,
  createGravitationConstant,
  createGravity,
  createHartreeEnergy,
  createHasNumericValue,
  createHelp,
  createHelpClass,
  createHex,
  createHypot,
  createI,
  createIdentity,
  createIfft,
  createIm,
  createImmutableDenseMatrixClass,
  createIndex,
  createIndexClass,
  createIndexNode,
  createIndexTransform,
  createInfinity,
  createIntersect,
  createInv,
  createInverseConductanceQuantum,
  createInvmod,
  createIsInteger,
  createIsNaN,
  createIsNegative,
  createIsNumeric,
  createIsPositive,
  createIsPrime,
  createIsZero,
  createKldivergence,
  createKlitzing,
  createKron,
  createLN10,
  createLN2,
  createLOG10E,
  createLOG2E,
  createLarger,
  createLargerEq,
  createLcm,
  createLeafCount,
  createLeftShift,
  createLgamma,
  createLog,
  createLog10,
  createLog1p,
  createLog2,
  createLoschmidt,
  createLsolve,
  createLsolveAll,
  createLup,
  createLusolve,
  createLyap,
  createMad,
  createMagneticConstant,
  createMagneticFluxQuantum,
  createMap,
  createMapSlices,
  createMapSlicesTransform,
  createMapTransform,
  createMatrix,
  createMatrixClass,
  createMatrixFromColumns,
  createMatrixFromFunction,
  createMatrixFromRows,
  createMax,
  createMaxTransform,
  createMean,
  createMeanTransform,
  createMedian,
  createMin,
  createMinTransform,
  createMod,
  createMode,
  createMolarMass,
  createMolarMassC12,
  createMolarPlanckConstant,
  createMolarVolume,
  createMultinomial,
  createMultiply,
  createMultiplyScalar,
  createNaN,
  createNeutronMass,
  createNode,
  createNorm,
  createNot,
  createNthRoot,
  createNthRoots,
  createNuclearMagneton,
  createNull,
  createNumber,
  createNumeric,
  createObjectNode,
  createOct,
  createOnes,
  createOperatorNode,
  createOr,
  createOrTransform,
  createParenthesisNode,
  createParse,
  createParser,
  createParserClass,
  createPartitionSelect,
  createPermutations,
  createPhi,
  createPi,
  createPickRandom,
  createPinv,
  createPlanckCharge,
  createPlanckConstant,
  createPlanckLength,
  createPlanckMass,
  createPlanckTemperature,
  createPlanckTime,
  createPolynomialRoot,
  createPow,
  createPrint,
  createPrintTransform,
  createProd,
  createProtonMass,
  createQr,
  createQuantileSeq,
  createQuantileSeqTransform,
  createQuantumOfCirculation,
  createRandom,
  createRandomInt,
  createRange,
  createRangeClass,
  createRangeNode,
  createRangeTransform,
  createRationalize,
  createRe,
  createReducedPlanckConstant,
  createRelationalNode,
  createReplacer,
  createReshape,
  createResize,
  createResolve,
  createResultSet,
  createReviver,
  createRightArithShift,
  createRightLogShift,
  createRotate,
  createRotationMatrix,
  createRound,
  createRow,
  createRowTransform,
  createRydberg,
  createSQRT1_2,
  createSQRT2,
  createSackurTetrode,
  createSchur,
  createSec,
  createSech,
  createSecondRadiation,
  createSetCartesian,
  createSetDifference,
  createSetDistinct,
  createSetIntersect,
  createSetIsSubset,
  createSetMultiplicity,
  createSetPowerset,
  createSetSize,
  createSetSymDifference,
  createSetUnion,
  createSign,
  createSimplify,
  createSimplifyConstant,
  createSimplifyCore,
  createSin,
  createSinh,
  createSize,
  createSlu,
  createSmaller,
  createSmallerEq,
  createSolveODE,
  createSort,
  createSpaClass,
  createSparse,
  createSparseMatrixClass,
  createSpeedOfLight,
  createSplitUnit,
  createSqrt,
  createSqrtm,
  createSquare,
  createSqueeze,
  createStd,
  createStdTransform,
  createStefanBoltzmann,
  createStirlingS2,
  createString,
  createSubset,
  createSubsetTransform,
  createSubtract,
  createSubtractScalar,
  createSum,
  createSumTransform,
  createSylvester,
  createSymbolNode,
  createSymbolicEqual,
  createTan,
  createTanh,
  createTau,
  createThomsonCrossSection,
  createTo,
  createTrace,
  createTranspose,
  createTrue,
  createTypeOf,
  createTyped,
  createUnaryMinus,
  createUnaryPlus,
  createUnequal,
  createUnit,
  createUnitClass,
  createUnitDependencies,
  createUnitFunction,
  createUppercaseE,
  createUppercasePi,
  createUsolve,
  createUsolveAll,
  createVacuumImpedance,
  createVariance,
  createVarianceTransform,
  createVersion,
  createWeakMixingAngle,
  createWienDisplacement,
  createXgcd,
  createXor,
  createZeros,
  createZeta,
  createZpk2tf,
  cross,
  crossDependencies,
  csc,
  cscDependencies,
  csch,
  cschDependencies,
  ctranspose,
  ctransposeDependencies,
  cube,
  cubeDependencies,
  cumsum,
  cumsumDependencies,
  cumsumTransformDependencies,
  deepEqual,
  deepEqualDependencies,
  derivative,
  derivativeDependencies,
  det,
  detDependencies,
  deuteronMass,
  deuteronMassDependencies,
  diag,
  diagDependencies,
  diff,
  diffDependencies,
  diffTransformDependencies,
  distance,
  distanceDependencies,
  divide,
  divideDependencies,
  divideScalar,
  divideScalarDependencies,
  embeddedDocs as docs,
  dot,
  dotDependencies,
  dotDivide,
  dotDivideDependencies,
  dotMultiply,
  dotMultiplyDependencies,
  dotPow,
  dotPowDependencies,
  e,
  eDependencies,
  efimovFactor,
  efimovFactorDependencies,
  eigs,
  eigsDependencies,
  electricConstant,
  electricConstantDependencies,
  electronMass,
  electronMassDependencies,
  elementaryCharge,
  elementaryChargeDependencies,
  equal,
  equalDependencies,
  equalScalar,
  equalScalarDependencies,
  equalText,
  equalTextDependencies,
  erf,
  erfDependencies,
  evaluate,
  evaluateDependencies,
  exp,
  expDependencies,
  expm,
  expm1,
  expm1Dependencies,
  expmDependencies,
  factorial,
  factorialDependencies,
  factory,
  falseDependencies,
  faraday,
  faradayDependencies,
  fermiCoupling,
  fermiCouplingDependencies,
  fft,
  fftDependencies,
  filter,
  filterDependencies,
  filterTransformDependencies,
  fineStructure,
  fineStructureDependencies,
  firstRadiation,
  firstRadiationDependencies,
  fix,
  fixDependencies,
  flatten2 as flatten,
  flattenDependencies,
  floor,
  floorDependencies,
  forEach,
  forEachDependencies,
  forEachTransformDependencies,
  format3 as format,
  formatDependencies,
  fraction,
  fractionDependencies,
  freqz,
  freqzDependencies,
  gamma,
  gammaDependencies,
  gasConstant,
  gasConstantDependencies,
  gcd2 as gcd,
  gcdDependencies,
  getMatrixDataType,
  getMatrixDataTypeDependencies,
  gravitationConstant,
  gravitationConstantDependencies,
  gravity,
  gravityDependencies,
  hartreeEnergy,
  hartreeEnergyDependencies,
  hasNumericValue,
  hasNumericValueDependencies,
  help,
  helpDependencies,
  hex,
  hexDependencies,
  hypot2 as hypot,
  hypotDependencies,
  i,
  iDependencies,
  identity,
  identityDependencies,
  ifft,
  ifftDependencies,
  im,
  imDependencies,
  index,
  indexDependencies,
  indexTransformDependencies,
  intersect,
  intersectDependencies,
  inv,
  invDependencies,
  inverseConductanceQuantum,
  inverseConductanceQuantumDependencies,
  invmod,
  invmodDependencies,
  isAccessorNode,
  isArray,
  isArrayNode,
  isAssignmentNode,
  isBigInt,
  isBigNumber,
  isBlockNode,
  isBoolean,
  isChain,
  isCollection,
  isComplex,
  isConditionalNode,
  isConstantNode,
  isDate,
  isDenseMatrix,
  isFraction,
  isFunction,
  isFunctionAssignmentNode,
  isFunctionNode,
  isHelp,
  isIndex,
  isIndexNode,
  isInteger2 as isInteger,
  isIntegerDependencies,
  isMap,
  isMatrix,
  isNaN2 as isNaN,
  isNaNDependencies,
  isNegative,
  isNegativeDependencies,
  isNode,
  isNull,
  isNumber,
  isNumeric,
  isNumericDependencies,
  isObject,
  isObjectNode,
  isObjectWrappingMap,
  isOperatorNode,
  isParenthesisNode,
  isPartitionedMap,
  isPositive,
  isPositiveDependencies,
  isPrime,
  isPrimeDependencies,
  isRange,
  isRangeNode,
  isRegExp,
  isRelationalNode,
  isResultSet,
  isSparseMatrix,
  isString,
  isSymbolNode,
  isUndefined,
  isUnit,
  isZero,
  isZeroDependencies,
  kldivergence,
  kldivergenceDependencies,
  klitzing,
  klitzingDependencies,
  kron,
  kronDependencies,
  larger,
  largerDependencies,
  largerEq,
  largerEqDependencies,
  lcm,
  lcmDependencies,
  leafCount,
  leafCountDependencies,
  leftShift,
  leftShiftDependencies,
  lgamma,
  lgammaDependencies,
  log,
  log10,
  log10Dependencies,
  log1p2 as log1p,
  log1pDependencies,
  log2,
  log2Dependencies,
  logDependencies,
  loschmidt,
  loschmidtDependencies,
  lsolve,
  lsolveAll,
  lsolveAllDependencies,
  lsolveDependencies,
  lup,
  lupDependencies,
  lusolve,
  lusolveDependencies,
  lyap,
  lyapDependencies,
  mad,
  madDependencies,
  magneticConstant,
  magneticConstantDependencies,
  magneticFluxQuantum,
  magneticFluxQuantumDependencies,
  map,
  mapDependencies,
  mapSlices,
  mapSlicesDependencies,
  mapSlicesTransformDependencies,
  mapTransformDependencies,
  matrix,
  matrixDependencies,
  matrixFromColumns,
  matrixFromColumnsDependencies,
  matrixFromFunction,
  matrixFromFunctionDependencies,
  matrixFromRows,
  matrixFromRowsDependencies,
  max,
  maxDependencies,
  maxTransformDependencies,
  mean,
  meanDependencies,
  meanTransformDependencies,
  median,
  medianDependencies,
  min,
  minDependencies,
  minTransformDependencies,
  mod,
  modDependencies,
  mode,
  modeDependencies,
  molarMass,
  molarMassC12,
  molarMassC12Dependencies,
  molarMassDependencies,
  molarPlanckConstant,
  molarPlanckConstantDependencies,
  molarVolume,
  molarVolumeDependencies,
  multinomial,
  multinomialDependencies,
  multiply,
  multiplyDependencies,
  multiplyScalar,
  multiplyScalarDependencies,
  neutronMass,
  neutronMassDependencies,
  norm,
  normDependencies,
  not,
  notDependencies,
  nthRoot,
  nthRootDependencies,
  nthRoots,
  nthRootsDependencies,
  nuclearMagneton,
  nuclearMagnetonDependencies,
  nullDependencies,
  number,
  numberDependencies,
  numeric,
  numericDependencies,
  oct,
  octDependencies,
  ones,
  onesDependencies,
  or,
  orDependencies,
  orTransformDependencies,
  parse3 as parse,
  parseDependencies,
  parser,
  parserDependencies,
  partitionSelect,
  partitionSelectDependencies,
  permutations,
  permutationsDependencies,
  phi,
  phiDependencies,
  pi,
  piDependencies,
  pickRandom,
  pickRandomDependencies,
  pinv,
  pinvDependencies,
  planckCharge,
  planckChargeDependencies,
  planckConstant,
  planckConstantDependencies,
  planckLength,
  planckLengthDependencies,
  planckMass,
  planckMassDependencies,
  planckTemperature,
  planckTemperatureDependencies,
  planckTime,
  planckTimeDependencies,
  polynomialRoot,
  polynomialRootDependencies,
  pow,
  powDependencies,
  print,
  printDependencies,
  printTransformDependencies,
  prod,
  prodDependencies,
  protonMass,
  protonMassDependencies,
  qr,
  qrDependencies,
  quantileSeq,
  quantileSeqDependencies,
  quantileSeqTransformDependencies,
  quantumOfCirculation,
  quantumOfCirculationDependencies,
  random,
  randomDependencies,
  randomInt,
  randomIntDependencies,
  range,
  rangeDependencies,
  rangeTransformDependencies,
  rationalize,
  rationalizeDependencies,
  re,
  reDependencies,
  reducedPlanckConstant,
  reducedPlanckConstantDependencies,
  replacer,
  replacerDependencies,
  reshape2 as reshape,
  reshapeDependencies,
  resize2 as resize,
  resizeDependencies,
  resolve,
  resolveDependencies,
  reviver,
  reviverDependencies,
  rightArithShift,
  rightArithShiftDependencies,
  rightLogShift,
  rightLogShiftDependencies,
  rotate,
  rotateDependencies,
  rotationMatrix,
  rotationMatrixDependencies,
  round,
  roundDependencies,
  row,
  rowDependencies,
  rowTransformDependencies,
  rydberg,
  rydbergDependencies,
  sackurTetrode,
  sackurTetrodeDependencies,
  schur,
  schurDependencies,
  sec,
  secDependencies,
  sech,
  sechDependencies,
  secondRadiation,
  secondRadiationDependencies,
  setCartesian,
  setCartesianDependencies,
  setDifference,
  setDifferenceDependencies,
  setDistinct,
  setDistinctDependencies,
  setIntersect,
  setIntersectDependencies,
  setIsSubset,
  setIsSubsetDependencies,
  setMultiplicity,
  setMultiplicityDependencies,
  setPowerset,
  setPowersetDependencies,
  setSize,
  setSizeDependencies,
  setSymDifference,
  setSymDifferenceDependencies,
  setUnion,
  setUnionDependencies,
  sign,
  signDependencies,
  simplify,
  simplifyConstant,
  simplifyConstantDependencies,
  simplifyCore,
  simplifyCoreDependencies,
  simplifyDependencies,
  sin,
  sinDependencies,
  sinh2 as sinh,
  sinhDependencies,
  size,
  sizeDependencies,
  slu,
  sluDependencies,
  smaller,
  smallerDependencies,
  smallerEq,
  smallerEqDependencies,
  solveODE,
  solveODEDependencies,
  sort,
  sortDependencies,
  sparse,
  sparseDependencies,
  speedOfLight,
  speedOfLightDependencies,
  splitUnit,
  splitUnitDependencies,
  sqrt,
  sqrtDependencies,
  sqrtm,
  sqrtmDependencies,
  square,
  squareDependencies,
  squeeze2 as squeeze,
  squeezeDependencies,
  std,
  stdDependencies,
  stdTransformDependencies,
  stefanBoltzmann,
  stefanBoltzmannDependencies,
  stirlingS2,
  stirlingS2Dependencies,
  string,
  stringDependencies,
  subset,
  subsetDependencies,
  subsetTransformDependencies,
  subtract,
  subtractDependencies,
  subtractScalar,
  subtractScalarDependencies,
  sum,
  sumDependencies,
  sumTransformDependencies,
  sylvester,
  sylvesterDependencies,
  symbolicEqual,
  symbolicEqualDependencies,
  tan,
  tanDependencies,
  tanh2 as tanh,
  tanhDependencies,
  tau,
  tauDependencies,
  thomsonCrossSection,
  thomsonCrossSectionDependencies,
  to,
  toDependencies,
  trace,
  traceDependencies,
  transpose,
  transposeDependencies,
  trueDependencies,
  typeOf2 as typeOf,
  typeOfDependencies,
  typed,
  typedDependencies,
  unaryMinus,
  unaryMinusDependencies,
  unaryPlus,
  unaryPlusDependencies,
  unequal,
  unequalDependencies,
  unit,
  unitDependencies,
  usolve,
  usolveAll,
  usolveAllDependencies,
  usolveDependencies,
  vacuumImpedance,
  vacuumImpedanceDependencies,
  variance,
  varianceDependencies,
  varianceTransformDependencies,
  version,
  versionDependencies,
  weakMixingAngle,
  weakMixingAngleDependencies,
  wienDisplacement,
  wienDisplacementDependencies,
  xgcd,
  xgcdDependencies,
  xor,
  xorDependencies,
  zeros,
  zerosDependencies,
  zeta,
  zetaDependencies,
  zpk2tf,
  zpk2tfDependencies
};
//# sourceMappingURL=mathjs.js.map
