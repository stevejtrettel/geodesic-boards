{"version":3,"file":"three-custom-shader-material.cjs.js","sources":["../../src/defaults.ts","../../src/maps/keywordMap.ts","../../src/maps/availabilityMap.ts","../../src/maps/patchMap.ts","../../src/maps/requiredPropsMap.ts","../../src/sdbm.js","../../src/utils.ts","../../src/index.ts"],"sourcesContent":["export const defaultCsmDefinitions = /* glsl */ `\r\n    \r\n#ifdef IS_VERTEX\r\n    vec3 csm_Position;\r\n    vec4 csm_PositionRaw;\r\n    vec3 csm_Normal;\r\n\r\n    // csm_PointSize\r\n    #ifdef IS_POINTSMATERIAL\r\n        float csm_PointSize;\r\n    #endif\r\n#else\r\n    vec4 csm_DiffuseColor;\r\n    vec4 csm_FragColor;\r\n    float csm_UnlitFac;\r\n\r\n    // csm_Emissive, csm_Roughness, csm_Metalness\r\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL\r\n        vec3 csm_Emissive;\r\n        float csm_Roughness;\r\n        float csm_Metalness;\r\n        float csm_Iridescence;\r\n        \r\n        #if defined IS_MESHPHYSICALMATERIAL\r\n            float csm_Clearcoat;\r\n            float csm_ClearcoatRoughness;\r\n            vec3 csm_ClearcoatNormal;\r\n            float csm_Transmission;\r\n            float csm_Thickness;\r\n        #endif\r\n    #endif\r\n\r\n    // csm_AO\r\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL\r\n        float csm_AO;\r\n    #endif\r\n\r\n    // csm_Bump\r\n    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL \r\n        vec3 csm_Bump;\r\n        vec3 csm_FragNormal;\r\n    #endif\r\n\r\n    float csm_DepthAlpha;\r\n#endif\r\n`;\r\n\r\nexport const defaultCsmMainDefinitions = /* glsl */ `\r\n\r\n#ifdef IS_VERTEX\r\n    // csm_Position & csm_PositionRaw\r\n    #ifdef IS_UNKNOWN\r\n        csm_Position = vec3(0.0);\r\n        csm_PositionRaw = vec4(0.0);\r\n        csm_Normal = vec3(0.0);\r\n    #else\r\n        csm_Position = position;\r\n        csm_PositionRaw = projectionMatrix * modelViewMatrix * vec4(position, 1.);\r\n        csm_Normal = normal;\r\n    #endif\r\n\r\n    // csm_PointSize\r\n    #ifdef IS_POINTSMATERIAL\r\n        csm_PointSize = size;\r\n    #endif\r\n#else\r\n    csm_UnlitFac = 0.0;\r\n\r\n    // csm_DiffuseColor & csm_FragColor\r\n    #if defined IS_UNKNOWN || defined IS_SHADERMATERIAL || defined IS_MESHDEPTHMATERIAL || defined IS_MESHDISTANCEMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_SHADOWMATERIAL\r\n        csm_DiffuseColor = vec4(1.0, 0.0, 1.0, 1.0);\r\n        csm_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\r\n    #else\r\n        #ifdef USE_MAP\r\n            vec4 _csm_sampledDiffuseColor = texture2D(map, vMapUv);\r\n\r\n            #ifdef DECODE_VIDEO_TEXTURE\r\n            // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)\r\n            _csm_sampledDiffuseColor = vec4(mix(pow(_csm_sampledDiffuseColor.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), _csm_sampledDiffuseColor.rgb * 0.0773993808, vec3(lessThanEqual(_csm_sampledDiffuseColor.rgb, vec3(0.04045)))), _csm_sampledDiffuseColor.w);\r\n            #endif\r\n\r\n            csm_DiffuseColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;\r\n            csm_FragColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;\r\n        #else\r\n            csm_DiffuseColor = vec4(diffuse, opacity);\r\n            csm_FragColor = vec4(diffuse, opacity);\r\n        #endif\r\n    #endif\r\n\r\n    // csm_Emissive, csm_Roughness, csm_Metalness\r\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL\r\n        csm_Emissive = emissive;\r\n        csm_Roughness = roughness;\r\n        csm_Metalness = metalness;\r\n\r\n        #ifdef USE_IRIDESCENCE\r\n            csm_Iridescence = iridescence;\r\n        #else\r\n            csm_Iridescence = 0.0;\r\n        #endif\r\n\r\n        #if defined IS_MESHPHYSICALMATERIAL\r\n            #ifdef USE_CLEARCOAT\r\n                csm_Clearcoat = clearcoat;\r\n                csm_ClearcoatRoughness = clearcoatRoughness;\r\n            #else\r\n                csm_Clearcoat = 0.0;\r\n                csm_ClearcoatRoughness = 0.0;\r\n            #endif\r\n\r\n            #ifdef USE_TRANSMISSION\r\n                csm_Transmission = transmission;\r\n                csm_Thickness = thickness;\r\n            #else\r\n                csm_Transmission = 0.0;\r\n                csm_Thickness = 0.0;\r\n            #endif\r\n        #endif\r\n    #endif\r\n\r\n    // csm_AO\r\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL\r\n        csm_AO = 0.0;\r\n    #endif\r\n\r\n    // csm_Bump\r\n    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL \r\n        csm_Bump = vec3(0.0);\r\n        #ifdef FLAT_SHADED\r\n            vec3 fdx = dFdx( vViewPosition );\r\n            vec3 fdy = dFdy( vViewPosition );\r\n            csm_FragNormal = normalize( cross( fdx, fdy ) );\r\n        #else\r\n            csm_FragNormal = normalize(vNormal);\r\n            #ifdef DOUBLE_SIDED\r\n                csm_FragNormal *= gl_FrontFacing ? 1.0 : - 1.0;\r\n            #endif\r\n        #endif\r\n    #endif\r\n\r\n    csm_DepthAlpha = 1.0;\r\n#endif\r\n`;\r\n\r\nexport const defaultVertDefinitions = /* glsl */ `\r\n    varying mat4 csm_internal_vModelViewMatrix;\r\n`;\r\n\r\nexport const defaultVertMain = /* glsl */ `\r\n    csm_internal_vModelViewMatrix = modelViewMatrix;\r\n`;\r\n\r\nexport const defaultFragDefinitions = /* glsl */ `\r\n    varying mat4 csm_internal_vModelViewMatrix;\r\n`;\r\n\r\nexport const defaultFragMain = /* glsl */ `\r\n    \r\n`;\r\n","export const keywordMap = {\r\n  // PBR (frag)\r\n  diffuse: \"csm_DiffuseColor\", // Color + alpha\r\n  roughness: \"csm_Roughness\", // Roughness\r\n  metalness: \"csm_Metalness\", // Metalness\r\n  emissive: \"csm_Emissive\", // Emissive\r\n  ao: \"csm_AO\", // AO\r\n  bump: \"csm_Bump\", // Bump\r\n  fragNormal: \"csm_FragNormal\", // Fragment Normal\r\n  clearcoat: \"csm_Clearcoat\", // Clearcoat factor\r\n  clearcoatRoughness: \"csm_ClearcoatRoughness\", // Clearcoat roughness\r\n  clearcoatNormal: \"csm_ClearcoatNormal\", // Clearcoat normals\r\n  transmission: \"csm_Transmission\", // Transmission\r\n  thickness: \"csm_Thickness\", // Thickness\r\n  iridescence: \"csm_Iridescence\", // Iridescence\r\n\r\n  // Extras\r\n  pointSize: \"csm_PointSize\", // gl_PointSize (Frag)\r\n  fragColor: \"csm_FragColor\", // gl_FragColor (Frag)\r\n  depthAlpha: \"csm_DepthAlpha\", // Depth (MeshDepthMaterial)\r\n  unlitFac: \"csm_UnlitFac\", // Unlit factor (mix between csm_FragColor and csm_DiffuseColor)\r\n\r\n  // Vert\r\n  position: \"csm_Position\", // gl_Position\r\n  positionRaw: \"csm_PositionRaw\", // gl_Position (without projection)\r\n  normal: \"csm_Normal\", // Vertex Normal\r\n};\r\n","import { keywordMap } from \"./keywordMap\";\r\n\r\n// Map of CSM keywords to the materials they are available in\r\n// Some keywords are only available in certain materials\r\nexport const availabilityMap = {\r\n  [`${keywordMap.position}`]: \"*\",\r\n  [`${keywordMap.positionRaw}`]: \"*\",\r\n  [`${keywordMap.normal}`]: \"*\",\r\n  [`${keywordMap.depthAlpha}`]: \"*\",\r\n  [`${keywordMap.pointSize}`]: [\"PointsMaterial\"],\r\n\r\n  [`${keywordMap.diffuse}`]: \"*\",\r\n  [`${keywordMap.fragColor}`]: \"*\",\r\n  [`${keywordMap.fragNormal}`]: \"*\",\r\n  [`${keywordMap.unlitFac}`]: \"*\",\r\n  [`${keywordMap.emissive}`]: [\"MeshStandardMaterial\", \"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.roughness}`]: [\"MeshStandardMaterial\", \"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.metalness}`]: [\"MeshStandardMaterial\", \"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.iridescence}`]: [\r\n    \"MeshStandardMaterial\",\r\n    \"MeshPhysicalMaterial\",\r\n  ],\r\n  [`${keywordMap.ao}`]: [\r\n    \"MeshStandardMaterial\",\r\n    \"MeshPhysicalMaterial\",\r\n    \"MeshBasicMaterial\",\r\n    \"MeshLambertMaterial\",\r\n    \"MeshPhongMaterial\",\r\n    \"MeshToonMaterial\",\r\n  ],\r\n  [`${keywordMap.bump}`]: [\r\n    \"MeshLambertMaterial\",\r\n    \"MeshMatcapMaterial\",\r\n    \"MeshNormalMaterial\",\r\n    \"MeshPhongMaterial\",\r\n    \"MeshPhysicalMaterial\",\r\n    \"MeshStandardMaterial\",\r\n    \"MeshToonMaterial\",\r\n    \"ShadowMaterial\",\r\n  ],\r\n  [`${keywordMap.clearcoat}`]: [\"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.clearcoatRoughness}`]: [\"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.clearcoatNormal}`]: [\"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.transmission}`]: [\"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.thickness}`]: [\"MeshPhysicalMaterial\"],\r\n};\r\n","import * as THREE from \"three\";\r\nimport { CSMPatchMap } from \"../types\";\r\nimport { keywordMap } from \"./keywordMap\";\r\n\r\n// Map of CSM keywords to their substitutions\r\nexport const defaultPatchMap: CSMPatchMap = {\r\n  // VERT\r\n  \"*\": {\r\n    \"#include <lights_physical_fragment>\":\r\n      THREE.ShaderChunk.lights_physical_fragment,\r\n    \"#include <transmission_fragment>\": THREE.ShaderChunk.transmission_fragment,\r\n  },\r\n  [`${keywordMap.normal}`]: {\r\n    \"#include <beginnormal_vertex>\": `\r\n    vec3 objectNormal = ${keywordMap.normal};\r\n    #ifdef USE_TANGENT\r\n\t    vec3 objectTangent = vec3( tangent.xyz );\r\n    #endif\r\n    `,\r\n  },\r\n  [`${keywordMap.position}`]: {\r\n    \"#include <begin_vertex>\": `\r\n    vec3 transformed = ${keywordMap.position};\r\n  `,\r\n  },\r\n  [`${keywordMap.positionRaw}`]: {\r\n    \"#include <begin_vertex>\": `\r\n    vec4 csm_internal_positionUnprojected = ${keywordMap.positionRaw};\r\n    mat4x4 csm_internal_unprojectMatrix = projectionMatrix * modelViewMatrix;\r\n    #ifdef USE_INSTANCING\r\n      csm_internal_unprojectMatrix = csm_internal_unprojectMatrix * instanceMatrix;\r\n    #endif\r\n    csm_internal_positionUnprojected = inverse(csm_internal_unprojectMatrix) * csm_internal_positionUnprojected;\r\n    vec3 transformed = csm_internal_positionUnprojected.xyz;\r\n  `,\r\n  },\r\n  [`${keywordMap.pointSize}`]: {\r\n    \"gl_PointSize = size;\": `\r\n    gl_PointSize = ${keywordMap.pointSize};\r\n    `,\r\n  },\r\n\r\n  // FRAG\r\n\r\n  [`${keywordMap.diffuse}`]: {\r\n    \"#include <color_fragment>\": `\r\n    #include <color_fragment>\r\n    diffuseColor = ${keywordMap.diffuse};\r\n  `,\r\n  },\r\n  [`${keywordMap.fragColor}`]: {\r\n    \"#include <opaque_fragment>\": `\r\n    #include <opaque_fragment>\r\n    gl_FragColor = mix(gl_FragColor, ${keywordMap.fragColor}, ${keywordMap.unlitFac});\r\n  `,\r\n  },\r\n  [`${keywordMap.emissive}`]: {\r\n    \"vec3 totalEmissiveRadiance = emissive;\": `\r\n    vec3 totalEmissiveRadiance = ${keywordMap.emissive};\r\n    `,\r\n  },\r\n  [`${keywordMap.roughness}`]: {\r\n    \"#include <roughnessmap_fragment>\": `\r\n    #include <roughnessmap_fragment>\r\n    roughnessFactor = ${keywordMap.roughness};\r\n    `,\r\n  },\r\n  [`${keywordMap.metalness}`]: {\r\n    \"#include <metalnessmap_fragment>\": `\r\n    #include <metalnessmap_fragment>\r\n    metalnessFactor = ${keywordMap.metalness};\r\n    `,\r\n  },\r\n  [`${keywordMap.ao}`]: {\r\n    \"#include <aomap_fragment>\": `\r\n    #include <aomap_fragment>\r\n    reflectedLight.indirectDiffuse *= 1. - ${keywordMap.ao};\r\n    `,\r\n  },\r\n  [`${keywordMap.bump}`]: {\r\n    \"#include <normal_fragment_maps>\": `\r\n    #include <normal_fragment_maps>\r\n\r\n    vec3 csm_internal_orthogonal = ${keywordMap.bump} - (dot(${keywordMap.bump}, normal) * normal);\r\n    vec3 csm_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_internal_orthogonal;\r\n    normal = normalize(normal - csm_internal_projectedbump);\r\n    `,\r\n  },\r\n  [`${keywordMap.fragNormal}`]: {\r\n    \"#include <normal_fragment_maps>\": `\r\n      #include <normal_fragment_maps>\r\n      normal = ${keywordMap.fragNormal};\r\n    `,\r\n  },\r\n  [`${keywordMap.depthAlpha}`]: {\r\n    \"gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\": `\r\n      gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity * 1.0 - ${keywordMap.depthAlpha} );\r\n    `,\r\n    \"gl_FragColor = packDepthToRGBA( fragCoordZ );\": `\r\n      if(${keywordMap.depthAlpha} < 1.0) discard;\r\n      gl_FragColor = packDepthToRGBA( dist );\r\n    `,\r\n    \"gl_FragColor = packDepthToRGBA( dist );\": `\r\n      if(${keywordMap.depthAlpha} < 1.0) discard;\r\n      gl_FragColor = packDepthToRGBA( dist );\r\n    `,\r\n  },\r\n  [`${keywordMap.clearcoat}`]: {\r\n    \"material.clearcoat = clearcoat;\": `material.clearcoat = ${keywordMap.clearcoat};`,\r\n  },\r\n  [`${keywordMap.clearcoatRoughness}`]: {\r\n    \"material.clearcoatRoughness = clearcoatRoughness;\": `material.clearcoatRoughness = ${keywordMap.clearcoatRoughness};`,\r\n  },\r\n  [`${keywordMap.clearcoatNormal}`]: {\r\n    \"#include <clearcoat_normal_fragment_begin>\": `\r\n      vec3 csm_coat_internal_orthogonal = csm_ClearcoatNormal - (dot(csm_ClearcoatNormal, nonPerturbedNormal) * nonPerturbedNormal);\r\n      vec3 csm_coat_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_coat_internal_orthogonal;\r\n      vec3 clearcoatNormal = normalize(nonPerturbedNormal - csm_coat_internal_projectedbump);\r\n    `,\r\n  },\r\n  [`${keywordMap.transmission}`]: {\r\n    \"material.transmission = transmission;\": `\r\n      material.transmission = ${keywordMap.transmission};\r\n    `,\r\n  },\r\n  [`${keywordMap.thickness}`]: {\r\n    \"material.thickness = thickness;\": `\r\n      material.thickness = ${keywordMap.thickness};\r\n    `,\r\n  },\r\n  [`${keywordMap.iridescence}`]: {\r\n    \"material.iridescence = iridescence;\": `\r\n      material.iridescence = ${keywordMap.iridescence};\r\n    `,\r\n  },\r\n};\r\n","import { keywordMap } from \"./keywordMap\";\r\n\r\n/**\r\n * Map of props to their keywords\r\n * this is because Three only injects some defines if certain properties are set in the material options.\r\n *\r\n * For example, \"clearcoat\" must be set for 3js to include the #USE_CLEARCOAT define in the shader.\r\n * and thus for our custom clearcoar variant to work\r\n */\r\nexport const requiredPropsMap = {\r\n  clearcoat: [\r\n    keywordMap.clearcoat,\r\n    keywordMap.clearcoatNormal,\r\n    keywordMap.clearcoatRoughness,\r\n  ],\r\n  transmission: [keywordMap.transmission],\r\n  iridescence: [keywordMap.iridescence],\r\n};\r\n","//https://github.com/sindresorhus/sdbm\r\n\r\nexport default function sdbm(string) {\r\n  let hash = 0;\r\n\r\n  for (let i = 0; i < string.length; i++) {\r\n    hash = string.charCodeAt(i) + (hash << 6) + (hash << 16) - hash;\r\n  }\r\n\r\n  // Convert it to an unsigned 32-bit integer.\r\n  const h = hash >>> 0;\r\n  const str = String(h);\r\n  return str;\r\n}\r\n","import { MaterialConstructor } from \"./types\";\r\n\r\n// Hacky, yikes!\r\nexport function isConstructor<T extends MaterialConstructor>(\r\n  f: T | InstanceType<T>\r\n): f is T {\r\n  try {\r\n    // @ts-ignore\r\n    new f();\r\n  } catch (err) {\r\n    if ((err as any).message.indexOf(\"is not a constructor\") >= 0) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n// Remove all comments in a string\r\n// both block and inline comments\r\nexport function stripComments(str: string) {\r\n  return str.replace(/\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*/g, \"\");\r\n}\r\n","import * as THREE from \"three\";\r\nimport {\r\n  defaultCsmDefinitions,\r\n  defaultCsmMainDefinitions,\r\n  defaultFragDefinitions,\r\n  defaultFragMain,\r\n  defaultVertDefinitions,\r\n  defaultVertMain,\r\n} from \"./defaults\";\r\nimport { availabilityMap, defaultPatchMap, keywordMap } from \"./maps\";\r\nimport { requiredPropsMap } from \"./maps/requiredPropsMap\";\r\nimport hash from \"./sdbm\";\r\nimport * as TYPES from \"./types\";\r\nimport { isConstructor, stripComments } from \"./utils\";\r\n\r\nexport default class CustomShaderMaterial<\r\n  T extends TYPES.MaterialConstructor = typeof THREE.Material\r\n> extends THREE.Material {\r\n  uniforms: TYPES.Uniform = {};\r\n  vertexShader: string = \"\";\r\n  fragmentShader: string = \"\";\r\n\r\n  constructor({\r\n    baseMaterial,\r\n    vertexShader,\r\n    fragmentShader,\r\n    uniforms,\r\n    patchMap,\r\n    cacheKey,\r\n    ...opts\r\n  }: TYPES.CustomShaderMaterialParameters<T>) {\r\n    if (!baseMaterial) {\r\n      throw new Error(\"CustomShaderMaterial: baseMaterial is required.\");\r\n    }\r\n\r\n    let base: THREE.Material;\r\n    if (isConstructor(baseMaterial)) {\r\n      // If base material is a constructor, instantiate it\r\n      // if opts is empty, replace it with undefined\r\n      const isEmptyOpts = Object.keys(opts).length === 0;\r\n      base = new baseMaterial(isEmptyOpts ? undefined : opts);\r\n    } else {\r\n      // Else, use the already created instance as the base material\r\n      // and copy options onto it\r\n      base = baseMaterial;\r\n      Object.assign(base, opts);\r\n    }\r\n\r\n    // Blacklist some materials that are not supported\r\n    const blackList = [\"ShaderMaterial\", \"RawShaderMaterial\"];\r\n    if (blackList.includes(base.type)) {\r\n      throw new Error(\r\n        `CustomShaderMaterial does not support ${base.type} as a base material.`\r\n      );\r\n    }\r\n\r\n    super();\r\n\r\n    // Return a proxy to the base material with CSM types and methods\r\n    const extendedBase = base as typeof base & TYPES.CSMProxy<T>;\r\n    extendedBase.name = `CustomShaderMaterial<${base.name || base.type}>`;\r\n    extendedBase.update = this.update.bind(extendedBase);\r\n    extendedBase.__csm = {\r\n      prevOnBeforeCompile: base.onBeforeCompile,\r\n      baseMaterial: base,\r\n      vertexShader,\r\n      fragmentShader,\r\n      uniforms,\r\n      patchMap,\r\n      cacheKey,\r\n    };\r\n\r\n    const prevUniforms = extendedBase.uniforms || {};\r\n    const newUniforms = uniforms || {};\r\n    const mergedUniforms = { ...prevUniforms, ...newUniforms };\r\n\r\n    extendedBase.uniforms = this.uniforms = mergedUniforms;\r\n    extendedBase.vertexShader = this.vertexShader = vertexShader || \"\";\r\n    extendedBase.fragmentShader = this.fragmentShader = fragmentShader || \"\";\r\n\r\n    // Initialize custom shaders\r\n    extendedBase.update({\r\n      fragmentShader: extendedBase.fragmentShader,\r\n      vertexShader: extendedBase.vertexShader,\r\n      uniforms: extendedBase.uniforms,\r\n      patchMap,\r\n      cacheKey,\r\n    });\r\n\r\n    // Merge \"this\" with the extended base\r\n    Object.assign(this, extendedBase);\r\n\r\n    // Copy getters and setters from the base material\r\n    const gettersAndSetters = Object.getOwnPropertyDescriptors(\r\n      Object.getPrototypeOf(extendedBase)\r\n    );\r\n\r\n    for (const key in gettersAndSetters) {\r\n      const descriptor = gettersAndSetters[key];\r\n      if (descriptor.get || descriptor.set) {\r\n        Object.defineProperty(this, key, descriptor);\r\n      }\r\n    }\r\n\r\n    // Override type setter because of this BS: https://github.com/mrdoob/three.js/blob/841ca14e89f3ec925e071a321958e49a883343c0/src/materials/Material.js#L22\r\n    Object.defineProperty(this, \"type\", {\r\n      get() {\r\n        return base.type;\r\n      },\r\n      set(value) {\r\n        base.type = value;\r\n      },\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  update({\r\n    fragmentShader: _fs,\r\n    vertexShader: _vs,\r\n    uniforms,\r\n    cacheKey,\r\n    patchMap,\r\n  }: Omit<TYPES.CustomShaderMaterialBaseParameters<T>, \"baseMaterial\">) {\r\n    // Strip comments from shaders, makes it so that commented keywords are not detected\r\n    const vertexShader = stripComments(_vs || \"\");\r\n    const fragmentShader = stripComments(_fs || \"\");\r\n\r\n    // Get typed `this` for the proxy\r\n    const self = this as typeof this & TYPES.CSMProxy<T>;\r\n\r\n    // Replace the shaders if they are provided\r\n    if (uniforms) self.uniforms = uniforms;\r\n    if (_vs) self.vertexShader = _vs;\r\n    if (_fs) self.fragmentShader = _fs;\r\n\r\n    // Some keywords require certain properties to be set for their chunks to be included via #ifdef\r\n    // so we must check if the shaders contain these keywords and set the properties accordingly\r\n    Object.entries(requiredPropsMap).forEach(([prop, matchKeywords]) => {\r\n      for (const keyword in matchKeywords) {\r\n        const matchKeyword = matchKeywords[keyword];\r\n        if (\r\n          (fragmentShader && fragmentShader.includes(matchKeyword)) ||\r\n          (vertexShader && vertexShader.includes(matchKeyword))\r\n        ) {\r\n          // @ts-ignore\r\n          if (!self[prop]) {\r\n            // @ts-ignore\r\n            self[prop] = 1;\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    // Check it the previous onBeforeCompile exists\r\n    const prevOnBeforeCompile = self.__csm.prevOnBeforeCompile;\r\n\r\n    // Helper function to extend the shader\r\n    const extendShader = (\r\n      prevShader: string,\r\n      newShader?: string,\r\n      isFrag?: boolean\r\n    ) => {\r\n      let mainBody: string | undefined;\r\n      let beforeMain: string = \"\";\r\n\r\n      // Prepare the main body and beforeMain\r\n      if (newShader) {\r\n        // Simpler approach to extract main function body\r\n        const mainStartIndex = newShader.search(/void\\s+main\\s*\\(\\s*\\)\\s*{/);\r\n        if (mainStartIndex !== -1) {\r\n          // Get everything before main function\r\n          beforeMain = newShader.slice(0, mainStartIndex);\r\n\r\n          // Find the matching closing brace using brace counting\r\n          let braceCount = 0;\r\n          let mainEndIndex = -1;\r\n\r\n          for (let i = mainStartIndex; i < newShader.length; i++) {\r\n            if (newShader[i] === \"{\") braceCount++;\r\n            if (newShader[i] === \"}\") {\r\n              braceCount--;\r\n              if (braceCount === 0) {\r\n                mainEndIndex = i;\r\n                break;\r\n              }\r\n            }\r\n          }\r\n\r\n          if (mainEndIndex !== -1) {\r\n            // Extract main body without the outer braces\r\n            const fullMain = newShader.slice(mainStartIndex, mainEndIndex + 1);\r\n            mainBody = fullMain.slice(fullMain.indexOf(\"{\") + 1, -1);\r\n          }\r\n        } else {\r\n          beforeMain = newShader;\r\n        }\r\n      }\r\n\r\n      // Set csm_UnlitFac if csm_FragColor is used to preserve\r\n      // legacy behavior.\r\n      if (isFrag) {\r\n        const hasFragColor = newShader\r\n          ? newShader.includes(keywordMap.fragColor)\r\n          : false;\r\n        if (hasFragColor && mainBody) {\r\n          mainBody = \"csm_UnlitFac = 1.0;\\n\" + mainBody;\r\n        }\r\n      }\r\n\r\n      const defaultsAlreadyIncluded = prevShader.includes(\"//~CSM_DEFAULTS\");\r\n\r\n      // Inject\r\n      if (defaultsAlreadyIncluded) {\r\n        prevShader = prevShader.replace(\r\n          \"void main() {\",\r\n          `\r\n          // THREE-CustomShaderMaterial by Faraz Shaikh: https://github.com/FarazzShaikh/THREE-CustomShaderMaterial\r\n  \r\n          ${beforeMain}\r\n          \r\n          void main() {\r\n          `\r\n        );\r\n\r\n        const lastMainEndIndex = prevShader.lastIndexOf(\"//~CSM_MAIN_END\");\r\n\r\n        if (lastMainEndIndex !== -1) {\r\n          const toAppend = `\r\n            ${mainBody ? `${mainBody}` : \"\"}\r\n            //~CSM_MAIN_END\r\n          `;\r\n          prevShader =\r\n            prevShader.slice(0, lastMainEndIndex) +\r\n            toAppend +\r\n            prevShader.slice(lastMainEndIndex);\r\n        }\r\n      } else {\r\n        const regex = /void\\s*main\\s*\\(\\s*\\)\\s*{/gm;\r\n\r\n        prevShader = prevShader.replace(\r\n          regex,\r\n          `\r\n          // THREE-CustomShaderMaterial by Faraz Shaikh: https://github.com/FarazzShaikh/THREE-CustomShaderMaterial\r\n  \r\n          //~CSM_DEFAULTS\r\n          ${isFrag ? defaultFragDefinitions : defaultVertDefinitions}\r\n          ${defaultCsmDefinitions}\r\n  \r\n          ${beforeMain}\r\n          \r\n          void main() {\r\n            {\r\n              ${defaultCsmMainDefinitions}\r\n            }\r\n            ${isFrag ? defaultFragMain : defaultVertMain}\r\n\r\n            ${mainBody ? `${mainBody}` : \"\"}\r\n            //~CSM_MAIN_END\r\n          `\r\n        );\r\n      }\r\n\r\n      return prevShader;\r\n    };\r\n\r\n    // Override onBeforeCompile\r\n    self.onBeforeCompile = (\r\n      shader: THREE.WebGLProgramParametersWithUniforms,\r\n      renderer: THREE.WebGLRenderer\r\n    ) => {\r\n      // Apply previous onBeforeCompile\r\n      prevOnBeforeCompile?.(shader, renderer);\r\n\r\n      const userPatchMap = patchMap || {};\r\n      // const mergedPatchMap = { ...defaultPatchMap, ...userPatchMap };\r\n\r\n      // Append some defines\r\n      const type = self.type;\r\n      const typeDefine = type\r\n        ? `#define IS_${type.toUpperCase()};\\n`\r\n        : `#define IS_UNKNOWN;\\n`;\r\n      shader.vertexShader =\r\n        typeDefine + \"#define IS_VERTEX\\n\" + shader.vertexShader;\r\n      shader.fragmentShader =\r\n        typeDefine + \"#define IS_FRAGMENT\\n\" + shader.fragmentShader;\r\n\r\n      // Check if the keyword is available in the current material type\r\n      const runPatchMap = (_patchMap: TYPES.CSMPatchMap) => {\r\n        for (const keyword in _patchMap) {\r\n          const doesIncludeInVert =\r\n            keyword === \"*\" || (vertexShader && vertexShader.includes(keyword));\r\n          const doesIncludeInFrag =\r\n            keyword === \"*\" ||\r\n            (fragmentShader && fragmentShader.includes(keyword));\r\n\r\n          if (doesIncludeInFrag || doesIncludeInVert) {\r\n            const availableIn = availabilityMap[keyword];\r\n\r\n            if (\r\n              availableIn &&\r\n              availableIn !== \"*\" &&\r\n              (Array.isArray(availableIn)\r\n                ? !availableIn.includes(type)\r\n                : availableIn !== type)\r\n            ) {\r\n              console.error(\r\n                `CustomShaderMaterial: ${keyword} is not available in ${type}. Shader cannot compile.`\r\n              );\r\n              return;\r\n            }\r\n\r\n            const patchMap = _patchMap[keyword];\r\n\r\n            for (const toReplace in patchMap) {\r\n              const replaceWith = patchMap[toReplace];\r\n\r\n              if (typeof replaceWith === \"object\") {\r\n                const type = replaceWith.type;\r\n                const value = replaceWith.value;\r\n\r\n                if (type === \"fs\") {\r\n                  shader.fragmentShader = shader.fragmentShader.replace(\r\n                    toReplace,\r\n                    value\r\n                  );\r\n                } else if (type === \"vs\") {\r\n                  shader.vertexShader = shader.vertexShader.replace(\r\n                    toReplace,\r\n                    value\r\n                  );\r\n                }\r\n              } else if (replaceWith) {\r\n                shader.vertexShader = shader.vertexShader.replace(\r\n                  toReplace,\r\n                  replaceWith\r\n                );\r\n                shader.fragmentShader = shader.fragmentShader.replace(\r\n                  toReplace,\r\n                  replaceWith\r\n                );\r\n              }\r\n            }\r\n          }\r\n        }\r\n      };\r\n\r\n      runPatchMap(defaultPatchMap);\r\n      runPatchMap(userPatchMap);\r\n\r\n      // Extend the shaders\r\n      shader.vertexShader = extendShader(\r\n        shader.vertexShader,\r\n        vertexShader,\r\n        false\r\n      );\r\n\r\n      shader.fragmentShader = extendShader(\r\n        shader.fragmentShader,\r\n        fragmentShader,\r\n        true\r\n      );\r\n\r\n      if (uniforms) {\r\n        shader.uniforms = { ...shader.uniforms, ...self.uniforms };\r\n      }\r\n\r\n      self.uniforms = shader.uniforms;\r\n    };\r\n\r\n    const prevCacheKey = self.customProgramCacheKey;\r\n\r\n    self.customProgramCacheKey = () => {\r\n      return (\r\n        (cacheKey?.() || hash((vertexShader || \"\") + (fragmentShader || \"\"))) +\r\n        prevCacheKey?.call(self)\r\n      );\r\n    };\r\n\r\n    self.needsUpdate = true;\r\n  }\r\n\r\n  clone() {\r\n    // Get typed `this` for the proxy\r\n    const self = this as typeof this & TYPES.CSMProxy<T>;\r\n\r\n    // @ts-ignore\r\n    const newObj = new self.constructor({\r\n      baseMaterial: self.__csm.baseMaterial.clone(),\r\n      vertexShader: self.__csm.vertexShader,\r\n      fragmentShader: self.__csm.fragmentShader,\r\n      uniforms: self.__csm.uniforms,\r\n      patchMap: self.__csm.patchMap,\r\n      cacheKey: self.__csm.cacheKey,\r\n    });\r\n\r\n    return newObj;\r\n  }\r\n}\r\n\r\nexport {\r\n  type CSMPatchMap,\r\n  type CSMProxy,\r\n  type CustomShaderMaterialParameters,\r\n  type MaterialConstructor,\r\n} from \"./types\";\r\n"],"names":["defaultCsmDefinitions","defaultCsmMainDefinitions","defaultVertDefinitions","defaultVertMain","defaultFragDefinitions","defaultFragMain","keywordMap","availabilityMap","defaultPatchMap","THREE","requiredPropsMap","sdbm","string","hash","i","h","isConstructor","f","err","stripComments","str","CustomShaderMaterial","baseMaterial","vertexShader","fragmentShader","uniforms","patchMap","cacheKey","opts","base","isEmptyOpts","extendedBase","mergedUniforms","gettersAndSetters","key","descriptor","value","_fs","_vs","self","prop","matchKeywords","keyword","matchKeyword","prevOnBeforeCompile","extendShader","prevShader","newShader","isFrag","mainBody","beforeMain","mainStartIndex","braceCount","mainEndIndex","fullMain","lastMainEndIndex","toAppend","regex","shader","renderer","userPatchMap","type","typeDefine","runPatchMap","_patchMap","doesIncludeInVert","availableIn","toReplace","replaceWith","prevCacheKey"],"mappings":"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"}