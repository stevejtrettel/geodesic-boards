{"version":3,"file":"three-custom-shader-material.es.js","sources":["../../src/defaults.ts","../../src/maps/keywordMap.ts","../../src/maps/availabilityMap.ts","../../src/maps/patchMap.ts","../../src/maps/requiredPropsMap.ts","../../src/sdbm.js","../../src/utils.ts","../../src/index.ts"],"sourcesContent":["export const defaultCsmDefinitions = /* glsl */ `\r\n    \r\n#ifdef IS_VERTEX\r\n    vec3 csm_Position;\r\n    vec4 csm_PositionRaw;\r\n    vec3 csm_Normal;\r\n\r\n    // csm_PointSize\r\n    #ifdef IS_POINTSMATERIAL\r\n        float csm_PointSize;\r\n    #endif\r\n#else\r\n    vec4 csm_DiffuseColor;\r\n    vec4 csm_FragColor;\r\n    float csm_UnlitFac;\r\n\r\n    // csm_Emissive, csm_Roughness, csm_Metalness\r\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL\r\n        vec3 csm_Emissive;\r\n        float csm_Roughness;\r\n        float csm_Metalness;\r\n        float csm_Iridescence;\r\n        \r\n        #if defined IS_MESHPHYSICALMATERIAL\r\n            float csm_Clearcoat;\r\n            float csm_ClearcoatRoughness;\r\n            vec3 csm_ClearcoatNormal;\r\n            float csm_Transmission;\r\n            float csm_Thickness;\r\n        #endif\r\n    #endif\r\n\r\n    // csm_AO\r\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL\r\n        float csm_AO;\r\n    #endif\r\n\r\n    // csm_Bump\r\n    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL \r\n        vec3 csm_Bump;\r\n        vec3 csm_FragNormal;\r\n    #endif\r\n\r\n    float csm_DepthAlpha;\r\n#endif\r\n`;\r\n\r\nexport const defaultCsmMainDefinitions = /* glsl */ `\r\n\r\n#ifdef IS_VERTEX\r\n    // csm_Position & csm_PositionRaw\r\n    #ifdef IS_UNKNOWN\r\n        csm_Position = vec3(0.0);\r\n        csm_PositionRaw = vec4(0.0);\r\n        csm_Normal = vec3(0.0);\r\n    #else\r\n        csm_Position = position;\r\n        csm_PositionRaw = projectionMatrix * modelViewMatrix * vec4(position, 1.);\r\n        csm_Normal = normal;\r\n    #endif\r\n\r\n    // csm_PointSize\r\n    #ifdef IS_POINTSMATERIAL\r\n        csm_PointSize = size;\r\n    #endif\r\n#else\r\n    csm_UnlitFac = 0.0;\r\n\r\n    // csm_DiffuseColor & csm_FragColor\r\n    #if defined IS_UNKNOWN || defined IS_SHADERMATERIAL || defined IS_MESHDEPTHMATERIAL || defined IS_MESHDISTANCEMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_SHADOWMATERIAL\r\n        csm_DiffuseColor = vec4(1.0, 0.0, 1.0, 1.0);\r\n        csm_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\r\n    #else\r\n        #ifdef USE_MAP\r\n            vec4 _csm_sampledDiffuseColor = texture2D(map, vMapUv);\r\n\r\n            #ifdef DECODE_VIDEO_TEXTURE\r\n            // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)\r\n            _csm_sampledDiffuseColor = vec4(mix(pow(_csm_sampledDiffuseColor.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), _csm_sampledDiffuseColor.rgb * 0.0773993808, vec3(lessThanEqual(_csm_sampledDiffuseColor.rgb, vec3(0.04045)))), _csm_sampledDiffuseColor.w);\r\n            #endif\r\n\r\n            csm_DiffuseColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;\r\n            csm_FragColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;\r\n        #else\r\n            csm_DiffuseColor = vec4(diffuse, opacity);\r\n            csm_FragColor = vec4(diffuse, opacity);\r\n        #endif\r\n    #endif\r\n\r\n    // csm_Emissive, csm_Roughness, csm_Metalness\r\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL\r\n        csm_Emissive = emissive;\r\n        csm_Roughness = roughness;\r\n        csm_Metalness = metalness;\r\n\r\n        #ifdef USE_IRIDESCENCE\r\n            csm_Iridescence = iridescence;\r\n        #else\r\n            csm_Iridescence = 0.0;\r\n        #endif\r\n\r\n        #if defined IS_MESHPHYSICALMATERIAL\r\n            #ifdef USE_CLEARCOAT\r\n                csm_Clearcoat = clearcoat;\r\n                csm_ClearcoatRoughness = clearcoatRoughness;\r\n            #else\r\n                csm_Clearcoat = 0.0;\r\n                csm_ClearcoatRoughness = 0.0;\r\n            #endif\r\n\r\n            #ifdef USE_TRANSMISSION\r\n                csm_Transmission = transmission;\r\n                csm_Thickness = thickness;\r\n            #else\r\n                csm_Transmission = 0.0;\r\n                csm_Thickness = 0.0;\r\n            #endif\r\n        #endif\r\n    #endif\r\n\r\n    // csm_AO\r\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL\r\n        csm_AO = 0.0;\r\n    #endif\r\n\r\n    // csm_Bump\r\n    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL \r\n        csm_Bump = vec3(0.0);\r\n        #ifdef FLAT_SHADED\r\n            vec3 fdx = dFdx( vViewPosition );\r\n            vec3 fdy = dFdy( vViewPosition );\r\n            csm_FragNormal = normalize( cross( fdx, fdy ) );\r\n        #else\r\n            csm_FragNormal = normalize(vNormal);\r\n            #ifdef DOUBLE_SIDED\r\n                csm_FragNormal *= gl_FrontFacing ? 1.0 : - 1.0;\r\n            #endif\r\n        #endif\r\n    #endif\r\n\r\n    csm_DepthAlpha = 1.0;\r\n#endif\r\n`;\r\n\r\nexport const defaultVertDefinitions = /* glsl */ `\r\n    varying mat4 csm_internal_vModelViewMatrix;\r\n`;\r\n\r\nexport const defaultVertMain = /* glsl */ `\r\n    csm_internal_vModelViewMatrix = modelViewMatrix;\r\n`;\r\n\r\nexport const defaultFragDefinitions = /* glsl */ `\r\n    varying mat4 csm_internal_vModelViewMatrix;\r\n`;\r\n\r\nexport const defaultFragMain = /* glsl */ `\r\n    \r\n`;\r\n","export const keywordMap = {\r\n  // PBR (frag)\r\n  diffuse: \"csm_DiffuseColor\", // Color + alpha\r\n  roughness: \"csm_Roughness\", // Roughness\r\n  metalness: \"csm_Metalness\", // Metalness\r\n  emissive: \"csm_Emissive\", // Emissive\r\n  ao: \"csm_AO\", // AO\r\n  bump: \"csm_Bump\", // Bump\r\n  fragNormal: \"csm_FragNormal\", // Fragment Normal\r\n  clearcoat: \"csm_Clearcoat\", // Clearcoat factor\r\n  clearcoatRoughness: \"csm_ClearcoatRoughness\", // Clearcoat roughness\r\n  clearcoatNormal: \"csm_ClearcoatNormal\", // Clearcoat normals\r\n  transmission: \"csm_Transmission\", // Transmission\r\n  thickness: \"csm_Thickness\", // Thickness\r\n  iridescence: \"csm_Iridescence\", // Iridescence\r\n\r\n  // Extras\r\n  pointSize: \"csm_PointSize\", // gl_PointSize (Frag)\r\n  fragColor: \"csm_FragColor\", // gl_FragColor (Frag)\r\n  depthAlpha: \"csm_DepthAlpha\", // Depth (MeshDepthMaterial)\r\n  unlitFac: \"csm_UnlitFac\", // Unlit factor (mix between csm_FragColor and csm_DiffuseColor)\r\n\r\n  // Vert\r\n  position: \"csm_Position\", // gl_Position\r\n  positionRaw: \"csm_PositionRaw\", // gl_Position (without projection)\r\n  normal: \"csm_Normal\", // Vertex Normal\r\n};\r\n","import { keywordMap } from \"./keywordMap\";\r\n\r\n// Map of CSM keywords to the materials they are available in\r\n// Some keywords are only available in certain materials\r\nexport const availabilityMap = {\r\n  [`${keywordMap.position}`]: \"*\",\r\n  [`${keywordMap.positionRaw}`]: \"*\",\r\n  [`${keywordMap.normal}`]: \"*\",\r\n  [`${keywordMap.depthAlpha}`]: \"*\",\r\n  [`${keywordMap.pointSize}`]: [\"PointsMaterial\"],\r\n\r\n  [`${keywordMap.diffuse}`]: \"*\",\r\n  [`${keywordMap.fragColor}`]: \"*\",\r\n  [`${keywordMap.fragNormal}`]: \"*\",\r\n  [`${keywordMap.unlitFac}`]: \"*\",\r\n  [`${keywordMap.emissive}`]: [\"MeshStandardMaterial\", \"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.roughness}`]: [\"MeshStandardMaterial\", \"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.metalness}`]: [\"MeshStandardMaterial\", \"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.iridescence}`]: [\r\n    \"MeshStandardMaterial\",\r\n    \"MeshPhysicalMaterial\",\r\n  ],\r\n  [`${keywordMap.ao}`]: [\r\n    \"MeshStandardMaterial\",\r\n    \"MeshPhysicalMaterial\",\r\n    \"MeshBasicMaterial\",\r\n    \"MeshLambertMaterial\",\r\n    \"MeshPhongMaterial\",\r\n    \"MeshToonMaterial\",\r\n  ],\r\n  [`${keywordMap.bump}`]: [\r\n    \"MeshLambertMaterial\",\r\n    \"MeshMatcapMaterial\",\r\n    \"MeshNormalMaterial\",\r\n    \"MeshPhongMaterial\",\r\n    \"MeshPhysicalMaterial\",\r\n    \"MeshStandardMaterial\",\r\n    \"MeshToonMaterial\",\r\n    \"ShadowMaterial\",\r\n  ],\r\n  [`${keywordMap.clearcoat}`]: [\"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.clearcoatRoughness}`]: [\"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.clearcoatNormal}`]: [\"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.transmission}`]: [\"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.thickness}`]: [\"MeshPhysicalMaterial\"],\r\n};\r\n","import * as THREE from \"three\";\r\nimport { CSMPatchMap } from \"../types\";\r\nimport { keywordMap } from \"./keywordMap\";\r\n\r\n// Map of CSM keywords to their substitutions\r\nexport const defaultPatchMap: CSMPatchMap = {\r\n  // VERT\r\n  \"*\": {\r\n    \"#include <lights_physical_fragment>\":\r\n      THREE.ShaderChunk.lights_physical_fragment,\r\n    \"#include <transmission_fragment>\": THREE.ShaderChunk.transmission_fragment,\r\n  },\r\n  [`${keywordMap.normal}`]: {\r\n    \"#include <beginnormal_vertex>\": `\r\n    vec3 objectNormal = ${keywordMap.normal};\r\n    #ifdef USE_TANGENT\r\n\t    vec3 objectTangent = vec3( tangent.xyz );\r\n    #endif\r\n    `,\r\n  },\r\n  [`${keywordMap.position}`]: {\r\n    \"#include <begin_vertex>\": `\r\n    vec3 transformed = ${keywordMap.position};\r\n  `,\r\n  },\r\n  [`${keywordMap.positionRaw}`]: {\r\n    \"#include <begin_vertex>\": `\r\n    vec4 csm_internal_positionUnprojected = ${keywordMap.positionRaw};\r\n    mat4x4 csm_internal_unprojectMatrix = projectionMatrix * modelViewMatrix;\r\n    #ifdef USE_INSTANCING\r\n      csm_internal_unprojectMatrix = csm_internal_unprojectMatrix * instanceMatrix;\r\n    #endif\r\n    csm_internal_positionUnprojected = inverse(csm_internal_unprojectMatrix) * csm_internal_positionUnprojected;\r\n    vec3 transformed = csm_internal_positionUnprojected.xyz;\r\n  `,\r\n  },\r\n  [`${keywordMap.pointSize}`]: {\r\n    \"gl_PointSize = size;\": `\r\n    gl_PointSize = ${keywordMap.pointSize};\r\n    `,\r\n  },\r\n\r\n  // FRAG\r\n\r\n  [`${keywordMap.diffuse}`]: {\r\n    \"#include <color_fragment>\": `\r\n    #include <color_fragment>\r\n    diffuseColor = ${keywordMap.diffuse};\r\n  `,\r\n  },\r\n  [`${keywordMap.fragColor}`]: {\r\n    \"#include <opaque_fragment>\": `\r\n    #include <opaque_fragment>\r\n    gl_FragColor = mix(gl_FragColor, ${keywordMap.fragColor}, ${keywordMap.unlitFac});\r\n  `,\r\n  },\r\n  [`${keywordMap.emissive}`]: {\r\n    \"vec3 totalEmissiveRadiance = emissive;\": `\r\n    vec3 totalEmissiveRadiance = ${keywordMap.emissive};\r\n    `,\r\n  },\r\n  [`${keywordMap.roughness}`]: {\r\n    \"#include <roughnessmap_fragment>\": `\r\n    #include <roughnessmap_fragment>\r\n    roughnessFactor = ${keywordMap.roughness};\r\n    `,\r\n  },\r\n  [`${keywordMap.metalness}`]: {\r\n    \"#include <metalnessmap_fragment>\": `\r\n    #include <metalnessmap_fragment>\r\n    metalnessFactor = ${keywordMap.metalness};\r\n    `,\r\n  },\r\n  [`${keywordMap.ao}`]: {\r\n    \"#include <aomap_fragment>\": `\r\n    #include <aomap_fragment>\r\n    reflectedLight.indirectDiffuse *= 1. - ${keywordMap.ao};\r\n    `,\r\n  },\r\n  [`${keywordMap.bump}`]: {\r\n    \"#include <normal_fragment_maps>\": `\r\n    #include <normal_fragment_maps>\r\n\r\n    vec3 csm_internal_orthogonal = ${keywordMap.bump} - (dot(${keywordMap.bump}, normal) * normal);\r\n    vec3 csm_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_internal_orthogonal;\r\n    normal = normalize(normal - csm_internal_projectedbump);\r\n    `,\r\n  },\r\n  [`${keywordMap.fragNormal}`]: {\r\n    \"#include <normal_fragment_maps>\": `\r\n      #include <normal_fragment_maps>\r\n      normal = ${keywordMap.fragNormal};\r\n    `,\r\n  },\r\n  [`${keywordMap.depthAlpha}`]: {\r\n    \"gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\": `\r\n      gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity * 1.0 - ${keywordMap.depthAlpha} );\r\n    `,\r\n    \"gl_FragColor = packDepthToRGBA( fragCoordZ );\": `\r\n      if(${keywordMap.depthAlpha} < 1.0) discard;\r\n      gl_FragColor = packDepthToRGBA( dist );\r\n    `,\r\n    \"gl_FragColor = packDepthToRGBA( dist );\": `\r\n      if(${keywordMap.depthAlpha} < 1.0) discard;\r\n      gl_FragColor = packDepthToRGBA( dist );\r\n    `,\r\n  },\r\n  [`${keywordMap.clearcoat}`]: {\r\n    \"material.clearcoat = clearcoat;\": `material.clearcoat = ${keywordMap.clearcoat};`,\r\n  },\r\n  [`${keywordMap.clearcoatRoughness}`]: {\r\n    \"material.clearcoatRoughness = clearcoatRoughness;\": `material.clearcoatRoughness = ${keywordMap.clearcoatRoughness};`,\r\n  },\r\n  [`${keywordMap.clearcoatNormal}`]: {\r\n    \"#include <clearcoat_normal_fragment_begin>\": `\r\n      vec3 csm_coat_internal_orthogonal = csm_ClearcoatNormal - (dot(csm_ClearcoatNormal, nonPerturbedNormal) * nonPerturbedNormal);\r\n      vec3 csm_coat_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_coat_internal_orthogonal;\r\n      vec3 clearcoatNormal = normalize(nonPerturbedNormal - csm_coat_internal_projectedbump);\r\n    `,\r\n  },\r\n  [`${keywordMap.transmission}`]: {\r\n    \"material.transmission = transmission;\": `\r\n      material.transmission = ${keywordMap.transmission};\r\n    `,\r\n  },\r\n  [`${keywordMap.thickness}`]: {\r\n    \"material.thickness = thickness;\": `\r\n      material.thickness = ${keywordMap.thickness};\r\n    `,\r\n  },\r\n  [`${keywordMap.iridescence}`]: {\r\n    \"material.iridescence = iridescence;\": `\r\n      material.iridescence = ${keywordMap.iridescence};\r\n    `,\r\n  },\r\n};\r\n","import { keywordMap } from \"./keywordMap\";\r\n\r\n/**\r\n * Map of props to their keywords\r\n * this is because Three only injects some defines if certain properties are set in the material options.\r\n *\r\n * For example, \"clearcoat\" must be set for 3js to include the #USE_CLEARCOAT define in the shader.\r\n * and thus for our custom clearcoar variant to work\r\n */\r\nexport const requiredPropsMap = {\r\n  clearcoat: [\r\n    keywordMap.clearcoat,\r\n    keywordMap.clearcoatNormal,\r\n    keywordMap.clearcoatRoughness,\r\n  ],\r\n  transmission: [keywordMap.transmission],\r\n  iridescence: [keywordMap.iridescence],\r\n};\r\n","//https://github.com/sindresorhus/sdbm\r\n\r\nexport default function sdbm(string) {\r\n  let hash = 0;\r\n\r\n  for (let i = 0; i < string.length; i++) {\r\n    hash = string.charCodeAt(i) + (hash << 6) + (hash << 16) - hash;\r\n  }\r\n\r\n  // Convert it to an unsigned 32-bit integer.\r\n  const h = hash >>> 0;\r\n  const str = String(h);\r\n  return str;\r\n}\r\n","import { MaterialConstructor } from \"./types\";\r\n\r\n// Hacky, yikes!\r\nexport function isConstructor<T extends MaterialConstructor>(\r\n  f: T | InstanceType<T>\r\n): f is T {\r\n  try {\r\n    // @ts-ignore\r\n    new f();\r\n  } catch (err) {\r\n    if ((err as any).message.indexOf(\"is not a constructor\") >= 0) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n// Remove all comments in a string\r\n// both block and inline comments\r\nexport function stripComments(str: string) {\r\n  return str.replace(/\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*/g, \"\");\r\n}\r\n","import * as THREE from \"three\";\r\nimport {\r\n  defaultCsmDefinitions,\r\n  defaultCsmMainDefinitions,\r\n  defaultFragDefinitions,\r\n  defaultFragMain,\r\n  defaultVertDefinitions,\r\n  defaultVertMain,\r\n} from \"./defaults\";\r\nimport { availabilityMap, defaultPatchMap, keywordMap } from \"./maps\";\r\nimport { requiredPropsMap } from \"./maps/requiredPropsMap\";\r\nimport hash from \"./sdbm\";\r\nimport * as TYPES from \"./types\";\r\nimport { isConstructor, stripComments } from \"./utils\";\r\n\r\nexport default class CustomShaderMaterial<\r\n  T extends TYPES.MaterialConstructor = typeof THREE.Material\r\n> extends THREE.Material {\r\n  uniforms: TYPES.Uniform = {};\r\n  vertexShader: string = \"\";\r\n  fragmentShader: string = \"\";\r\n\r\n  constructor({\r\n    baseMaterial,\r\n    vertexShader,\r\n    fragmentShader,\r\n    uniforms,\r\n    patchMap,\r\n    cacheKey,\r\n    ...opts\r\n  }: TYPES.CustomShaderMaterialParameters<T>) {\r\n    if (!baseMaterial) {\r\n      throw new Error(\"CustomShaderMaterial: baseMaterial is required.\");\r\n    }\r\n\r\n    let base: THREE.Material;\r\n    if (isConstructor(baseMaterial)) {\r\n      // If base material is a constructor, instantiate it\r\n      // if opts is empty, replace it with undefined\r\n      const isEmptyOpts = Object.keys(opts).length === 0;\r\n      base = new baseMaterial(isEmptyOpts ? undefined : opts);\r\n    } else {\r\n      // Else, use the already created instance as the base material\r\n      // and copy options onto it\r\n      base = baseMaterial;\r\n      Object.assign(base, opts);\r\n    }\r\n\r\n    // Blacklist some materials that are not supported\r\n    const blackList = [\"ShaderMaterial\", \"RawShaderMaterial\"];\r\n    if (blackList.includes(base.type)) {\r\n      throw new Error(\r\n        `CustomShaderMaterial does not support ${base.type} as a base material.`\r\n      );\r\n    }\r\n\r\n    super();\r\n\r\n    // Return a proxy to the base material with CSM types and methods\r\n    const extendedBase = base as typeof base & TYPES.CSMProxy<T>;\r\n    extendedBase.name = `CustomShaderMaterial<${base.name || base.type}>`;\r\n    extendedBase.update = this.update.bind(extendedBase);\r\n    extendedBase.__csm = {\r\n      prevOnBeforeCompile: base.onBeforeCompile,\r\n      baseMaterial: base,\r\n      vertexShader,\r\n      fragmentShader,\r\n      uniforms,\r\n      patchMap,\r\n      cacheKey,\r\n    };\r\n\r\n    const prevUniforms = extendedBase.uniforms || {};\r\n    const newUniforms = uniforms || {};\r\n    const mergedUniforms = { ...prevUniforms, ...newUniforms };\r\n\r\n    extendedBase.uniforms = this.uniforms = mergedUniforms;\r\n    extendedBase.vertexShader = this.vertexShader = vertexShader || \"\";\r\n    extendedBase.fragmentShader = this.fragmentShader = fragmentShader || \"\";\r\n\r\n    // Initialize custom shaders\r\n    extendedBase.update({\r\n      fragmentShader: extendedBase.fragmentShader,\r\n      vertexShader: extendedBase.vertexShader,\r\n      uniforms: extendedBase.uniforms,\r\n      patchMap,\r\n      cacheKey,\r\n    });\r\n\r\n    // Merge \"this\" with the extended base\r\n    Object.assign(this, extendedBase);\r\n\r\n    // Copy getters and setters from the base material\r\n    const gettersAndSetters = Object.getOwnPropertyDescriptors(\r\n      Object.getPrototypeOf(extendedBase)\r\n    );\r\n\r\n    for (const key in gettersAndSetters) {\r\n      const descriptor = gettersAndSetters[key];\r\n      if (descriptor.get || descriptor.set) {\r\n        Object.defineProperty(this, key, descriptor);\r\n      }\r\n    }\r\n\r\n    // Override type setter because of this BS: https://github.com/mrdoob/three.js/blob/841ca14e89f3ec925e071a321958e49a883343c0/src/materials/Material.js#L22\r\n    Object.defineProperty(this, \"type\", {\r\n      get() {\r\n        return base.type;\r\n      },\r\n      set(value) {\r\n        base.type = value;\r\n      },\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  update({\r\n    fragmentShader: _fs,\r\n    vertexShader: _vs,\r\n    uniforms,\r\n    cacheKey,\r\n    patchMap,\r\n  }: Omit<TYPES.CustomShaderMaterialBaseParameters<T>, \"baseMaterial\">) {\r\n    // Strip comments from shaders, makes it so that commented keywords are not detected\r\n    const vertexShader = stripComments(_vs || \"\");\r\n    const fragmentShader = stripComments(_fs || \"\");\r\n\r\n    // Get typed `this` for the proxy\r\n    const self = this as typeof this & TYPES.CSMProxy<T>;\r\n\r\n    // Replace the shaders if they are provided\r\n    if (uniforms) self.uniforms = uniforms;\r\n    if (_vs) self.vertexShader = _vs;\r\n    if (_fs) self.fragmentShader = _fs;\r\n\r\n    // Some keywords require certain properties to be set for their chunks to be included via #ifdef\r\n    // so we must check if the shaders contain these keywords and set the properties accordingly\r\n    Object.entries(requiredPropsMap).forEach(([prop, matchKeywords]) => {\r\n      for (const keyword in matchKeywords) {\r\n        const matchKeyword = matchKeywords[keyword];\r\n        if (\r\n          (fragmentShader && fragmentShader.includes(matchKeyword)) ||\r\n          (vertexShader && vertexShader.includes(matchKeyword))\r\n        ) {\r\n          // @ts-ignore\r\n          if (!self[prop]) {\r\n            // @ts-ignore\r\n            self[prop] = 1;\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    // Check it the previous onBeforeCompile exists\r\n    const prevOnBeforeCompile = self.__csm.prevOnBeforeCompile;\r\n\r\n    // Helper function to extend the shader\r\n    const extendShader = (\r\n      prevShader: string,\r\n      newShader?: string,\r\n      isFrag?: boolean\r\n    ) => {\r\n      let mainBody: string | undefined;\r\n      let beforeMain: string = \"\";\r\n\r\n      // Prepare the main body and beforeMain\r\n      if (newShader) {\r\n        // Simpler approach to extract main function body\r\n        const mainStartIndex = newShader.search(/void\\s+main\\s*\\(\\s*\\)\\s*{/);\r\n        if (mainStartIndex !== -1) {\r\n          // Get everything before main function\r\n          beforeMain = newShader.slice(0, mainStartIndex);\r\n\r\n          // Find the matching closing brace using brace counting\r\n          let braceCount = 0;\r\n          let mainEndIndex = -1;\r\n\r\n          for (let i = mainStartIndex; i < newShader.length; i++) {\r\n            if (newShader[i] === \"{\") braceCount++;\r\n            if (newShader[i] === \"}\") {\r\n              braceCount--;\r\n              if (braceCount === 0) {\r\n                mainEndIndex = i;\r\n                break;\r\n              }\r\n            }\r\n          }\r\n\r\n          if (mainEndIndex !== -1) {\r\n            // Extract main body without the outer braces\r\n            const fullMain = newShader.slice(mainStartIndex, mainEndIndex + 1);\r\n            mainBody = fullMain.slice(fullMain.indexOf(\"{\") + 1, -1);\r\n          }\r\n        } else {\r\n          beforeMain = newShader;\r\n        }\r\n      }\r\n\r\n      // Set csm_UnlitFac if csm_FragColor is used to preserve\r\n      // legacy behavior.\r\n      if (isFrag) {\r\n        const hasFragColor = newShader\r\n          ? newShader.includes(keywordMap.fragColor)\r\n          : false;\r\n        if (hasFragColor && mainBody) {\r\n          mainBody = \"csm_UnlitFac = 1.0;\\n\" + mainBody;\r\n        }\r\n      }\r\n\r\n      const defaultsAlreadyIncluded = prevShader.includes(\"//~CSM_DEFAULTS\");\r\n\r\n      // Inject\r\n      if (defaultsAlreadyIncluded) {\r\n        prevShader = prevShader.replace(\r\n          \"void main() {\",\r\n          `\r\n          // THREE-CustomShaderMaterial by Faraz Shaikh: https://github.com/FarazzShaikh/THREE-CustomShaderMaterial\r\n  \r\n          ${beforeMain}\r\n          \r\n          void main() {\r\n          `\r\n        );\r\n\r\n        const lastMainEndIndex = prevShader.lastIndexOf(\"//~CSM_MAIN_END\");\r\n\r\n        if (lastMainEndIndex !== -1) {\r\n          const toAppend = `\r\n            ${mainBody ? `${mainBody}` : \"\"}\r\n            //~CSM_MAIN_END\r\n          `;\r\n          prevShader =\r\n            prevShader.slice(0, lastMainEndIndex) +\r\n            toAppend +\r\n            prevShader.slice(lastMainEndIndex);\r\n        }\r\n      } else {\r\n        const regex = /void\\s*main\\s*\\(\\s*\\)\\s*{/gm;\r\n\r\n        prevShader = prevShader.replace(\r\n          regex,\r\n          `\r\n          // THREE-CustomShaderMaterial by Faraz Shaikh: https://github.com/FarazzShaikh/THREE-CustomShaderMaterial\r\n  \r\n          //~CSM_DEFAULTS\r\n          ${isFrag ? defaultFragDefinitions : defaultVertDefinitions}\r\n          ${defaultCsmDefinitions}\r\n  \r\n          ${beforeMain}\r\n          \r\n          void main() {\r\n            {\r\n              ${defaultCsmMainDefinitions}\r\n            }\r\n            ${isFrag ? defaultFragMain : defaultVertMain}\r\n\r\n            ${mainBody ? `${mainBody}` : \"\"}\r\n            //~CSM_MAIN_END\r\n          `\r\n        );\r\n      }\r\n\r\n      return prevShader;\r\n    };\r\n\r\n    // Override onBeforeCompile\r\n    self.onBeforeCompile = (\r\n      shader: THREE.WebGLProgramParametersWithUniforms,\r\n      renderer: THREE.WebGLRenderer\r\n    ) => {\r\n      // Apply previous onBeforeCompile\r\n      prevOnBeforeCompile?.(shader, renderer);\r\n\r\n      const userPatchMap = patchMap || {};\r\n      // const mergedPatchMap = { ...defaultPatchMap, ...userPatchMap };\r\n\r\n      // Append some defines\r\n      const type = self.type;\r\n      const typeDefine = type\r\n        ? `#define IS_${type.toUpperCase()};\\n`\r\n        : `#define IS_UNKNOWN;\\n`;\r\n      shader.vertexShader =\r\n        typeDefine + \"#define IS_VERTEX\\n\" + shader.vertexShader;\r\n      shader.fragmentShader =\r\n        typeDefine + \"#define IS_FRAGMENT\\n\" + shader.fragmentShader;\r\n\r\n      // Check if the keyword is available in the current material type\r\n      const runPatchMap = (_patchMap: TYPES.CSMPatchMap) => {\r\n        for (const keyword in _patchMap) {\r\n          const doesIncludeInVert =\r\n            keyword === \"*\" || (vertexShader && vertexShader.includes(keyword));\r\n          const doesIncludeInFrag =\r\n            keyword === \"*\" ||\r\n            (fragmentShader && fragmentShader.includes(keyword));\r\n\r\n          if (doesIncludeInFrag || doesIncludeInVert) {\r\n            const availableIn = availabilityMap[keyword];\r\n\r\n            if (\r\n              availableIn &&\r\n              availableIn !== \"*\" &&\r\n              (Array.isArray(availableIn)\r\n                ? !availableIn.includes(type)\r\n                : availableIn !== type)\r\n            ) {\r\n              console.error(\r\n                `CustomShaderMaterial: ${keyword} is not available in ${type}. Shader cannot compile.`\r\n              );\r\n              return;\r\n            }\r\n\r\n            const patchMap = _patchMap[keyword];\r\n\r\n            for (const toReplace in patchMap) {\r\n              const replaceWith = patchMap[toReplace];\r\n\r\n              if (typeof replaceWith === \"object\") {\r\n                const type = replaceWith.type;\r\n                const value = replaceWith.value;\r\n\r\n                if (type === \"fs\") {\r\n                  shader.fragmentShader = shader.fragmentShader.replace(\r\n                    toReplace,\r\n                    value\r\n                  );\r\n                } else if (type === \"vs\") {\r\n                  shader.vertexShader = shader.vertexShader.replace(\r\n                    toReplace,\r\n                    value\r\n                  );\r\n                }\r\n              } else if (replaceWith) {\r\n                shader.vertexShader = shader.vertexShader.replace(\r\n                  toReplace,\r\n                  replaceWith\r\n                );\r\n                shader.fragmentShader = shader.fragmentShader.replace(\r\n                  toReplace,\r\n                  replaceWith\r\n                );\r\n              }\r\n            }\r\n          }\r\n        }\r\n      };\r\n\r\n      runPatchMap(defaultPatchMap);\r\n      runPatchMap(userPatchMap);\r\n\r\n      // Extend the shaders\r\n      shader.vertexShader = extendShader(\r\n        shader.vertexShader,\r\n        vertexShader,\r\n        false\r\n      );\r\n\r\n      shader.fragmentShader = extendShader(\r\n        shader.fragmentShader,\r\n        fragmentShader,\r\n        true\r\n      );\r\n\r\n      if (uniforms) {\r\n        shader.uniforms = { ...shader.uniforms, ...self.uniforms };\r\n      }\r\n\r\n      self.uniforms = shader.uniforms;\r\n    };\r\n\r\n    const prevCacheKey = self.customProgramCacheKey;\r\n\r\n    self.customProgramCacheKey = () => {\r\n      return (\r\n        (cacheKey?.() || hash((vertexShader || \"\") + (fragmentShader || \"\"))) +\r\n        prevCacheKey?.call(self)\r\n      );\r\n    };\r\n\r\n    self.needsUpdate = true;\r\n  }\r\n\r\n  clone() {\r\n    // Get typed `this` for the proxy\r\n    const self = this as typeof this & TYPES.CSMProxy<T>;\r\n\r\n    // @ts-ignore\r\n    const newObj = new self.constructor({\r\n      baseMaterial: self.__csm.baseMaterial.clone(),\r\n      vertexShader: self.__csm.vertexShader,\r\n      fragmentShader: self.__csm.fragmentShader,\r\n      uniforms: self.__csm.uniforms,\r\n      patchMap: self.__csm.patchMap,\r\n      cacheKey: self.__csm.cacheKey,\r\n    });\r\n\r\n    return newObj;\r\n  }\r\n}\r\n\r\nexport {\r\n  type CSMPatchMap,\r\n  type CSMProxy,\r\n  type CustomShaderMaterialParameters,\r\n  type MaterialConstructor,\r\n} from \"./types\";\r\n"],"names":["defaultCsmDefinitions","defaultCsmMainDefinitions","defaultVertDefinitions","defaultVertMain","defaultFragDefinitions","defaultFragMain","keywordMap","availabilityMap","defaultPatchMap","THREE","requiredPropsMap","sdbm","string","hash","i","h","isConstructor","f","err","stripComments","str","CustomShaderMaterial","baseMaterial","vertexShader","fragmentShader","uniforms","patchMap","cacheKey","opts","base","isEmptyOpts","extendedBase","mergedUniforms","gettersAndSetters","key","descriptor","value","_fs","_vs","self","prop","matchKeywords","keyword","matchKeyword","prevOnBeforeCompile","extendShader","prevShader","newShader","isFrag","mainBody","beforeMain","mainStartIndex","braceCount","mainEndIndex","fullMain","lastMainEndIndex","toAppend","regex","shader","renderer","userPatchMap","type","typeDefine","runPatchMap","_patchMap","doesIncludeInVert","availableIn","toReplace","replaceWith","prevCacheKey"],"mappings":"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"}